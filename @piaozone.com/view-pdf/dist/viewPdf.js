(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"));
	else if(typeof define === 'function' && define.amd)
		define(["React"], factory);
	else if(typeof exports === 'object')
		exports["ViewPdf"] = factory(require("React"));
	else
		root["ViewPdf"] = factory(root["React"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var pdfjs_dist__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);
/* harmony import */ var pdfjs_dist__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(pdfjs_dist__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
/* harmony import */ var pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _toolbar__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24);
/* harmony import */ var _piaozone_com_spin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(28);
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(27);
/* harmony import */ var pdfjs_dist_web_pdf_viewer_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(30);
/* harmony import */ var pdfjs_dist_web_pdf_viewer_css__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(pdfjs_dist_web_pdf_viewer_css__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(31);
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_style_css__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _sliderBar__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(32);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



 // import workerSrc from 'pdfjs-dist/build/pdf.worker.entry';







 // const PRINT_UNITS = 150 / 72.0;

var userAgent = typeof navigator !== 'undefined' && navigator.userAgent || '';
var platform = typeof navigator !== 'undefined' && navigator.platform || '';
var maxTouchPoints = typeof navigator !== 'undefined' && navigator.maxTouchPoints || 1;
var maxCanvasPixels = 16777216; // PDF之外占据的宽度 -18 padding -18减去滚动条宽度（不确定）
// let autoWidth = 36;
// let textLayerTop = 3;
// let scaleInterval = 0.05;

var isAndroid = /Android/.test(userAgent);
var isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === 'MacIntel' && maxTouchPoints > 1;

(function checkCanvasSizeLimitation() {
  if (isIOS || isAndroid) {
    maxCanvasPixels = 5242880; // autoWidth -= 18;
    // textLayerTop -= 1;
    // 手机上面缩放对清晰度影响更小
    // scaleInterval = 0.4;
  }
})();

var ViewPdf = /*#__PURE__*/function (_React$Component) {
  _inherits(ViewPdf, _React$Component);

  var _super = _createSuper(ViewPdf);

  function ViewPdf(props) {
    var _this;

    _classCallCheck(this, ViewPdf);

    _this = _super.apply(this, arguments);

    _defineProperty(_assertThisInitialized(_this), "calibrationData", function () {
      //校准
      var newScale = _this.scale;
      newScale = newScale.toFixed(2);
      newScale = Math.round(newScale * 100) / 100;

      _this.foreceRender(true, newScale);
    });

    _defineProperty(_assertThisInitialized(_this), "mySetState", function (data) {
      if (_this._isAmounted) {
        _this.setState(data);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "foreceRender", /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(ignoreStatus) {
        var scale,
            visibileEles,
            oldScale,
            oldScrollTop,
            tempViewers,
            i,
            view,
            _i,
            viewInfo,
            _args = arguments;

        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                scale = _args.length > 1 && _args[1] !== undefined ? _args[1] : _this.scale;

                if (_this._isAmounted) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return");

              case 3:
                visibileEles = [];
                oldScale = _this.scale;

                if (!(scale !== _this.scale)) {
                  _context.next = 25;
                  break;
                }

                _this.scale = scale;

                _this.mySetState({
                  scale: scale
                });

                oldScrollTop = _this.viewerContainer.scrollTop;

                _this.clear();

                tempViewers = [];
                i = 1;

              case 12:
                if (!(i <= _this.numPages)) {
                  _context.next = 20;
                  break;
                }

                _context.next = 15;
                return _this._getView(i);

              case 15:
                view = _context.sent;
                tempViewers.push(view);

              case 17:
                i++;
                _context.next = 12;
                break;

              case 20:
                _this.mySetState({
                  viewers: tempViewers
                });

                _this.viewerContainer.scrollTop = oldScrollTop * (_this.scale / oldScale);
                visibileEles = Object(_tools__WEBPACK_IMPORTED_MODULE_6__["getVisibleElements"])(_this.viewerContainer, tempViewers, true);
                _context.next = 26;
                break;

              case 25:
                visibileEles = Object(_tools__WEBPACK_IMPORTED_MODULE_6__["getVisibleElements"])(_this.viewerContainer, _this.state.viewers, true);

              case 26:
                _i = 0;

              case 27:
                if (!(_i < visibileEles.views.length)) {
                  _context.next = 40;
                  break;
                }

                viewInfo = visibileEles.views[_i].view;

                if (!ignoreStatus) {
                  _context.next = 34;
                  break;
                }

                _context.next = 32;
                return _this._renderPage(viewInfo);

              case 32:
                _context.next = 37;
                break;

              case 34:
                if (!(viewInfo.renderStatus === 0)) {
                  _context.next = 37;
                  break;
                }

                _context.next = 37;
                return _this._renderPage(viewInfo);

              case 37:
                _i++;
                _context.next = 27;
                break;

              case 40:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());

    _defineProperty(_assertThisInitialized(_this), "init", function () {
      _this.printContainer = document.getElementById('printContainer');
      _this.wrapperPdfs = document.getElementById('viewer');
      _this.viewerContainer = document.getElementById('viewerContainer');
      _this.sidebarContent = document.getElementById('sidebarContent');
      _this.hideCanvas = document.createElement('canvas');
      _this.ctx = _this.hideCanvas.getContext('2d');

      _this.clear();

      Object(_tools__WEBPACK_IMPORTED_MODULE_6__["watchScroll"])(_this.viewerContainer, function () {
        _this.foreceRender();
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_getView", function (num) {
      var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _this.scale;
      return new Promise(function (resolve) {
        _this.pdfDoc.getPage(num).then( /*#__PURE__*/function () {
          var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(page) {
            var outCanvas, pdfPageRotate, totalRotation, newScale, viewport, canvasSize;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    outCanvas = document.createElement('div');
                    outCanvas.className = 'page loading';
                    outCanvas.id = 'pageContainer' + num;
                    pdfPageRotate = page.rotate;
                    totalRotation = (_this.rotation + pdfPageRotate) % 360;
                    newScale = Object(_tools__WEBPACK_IMPORTED_MODULE_6__["getScale"])(page, scale, {
                      container: _this.viewerContainer,
                      rotation: _this.rotation
                    });
                    viewport = Object(_tools__WEBPACK_IMPORTED_MODULE_6__["getViewport"])(page, _tools__WEBPACK_IMPORTED_MODULE_6__["CSS_UNITS"] * newScale, totalRotation);
                    _this.scale = newScale;

                    if (_this.state.scale !== newScale) {
                      _this.mySetState({
                        scale: newScale
                      });
                    }

                    canvasSize = Object(_tools__WEBPACK_IMPORTED_MODULE_6__["getCanvasCSSWH"])(viewport, _this.ctx, {
                      useOnlyCssZoom: _this.props.useOnlyCssZoom,
                      maxCanvasPixels: maxCanvasPixels,
                      CSS_UNITS: _tools__WEBPACK_IMPORTED_MODULE_6__["CSS_UNITS"]
                    });
                    outCanvas.style.width = canvasSize.styleWidth + 'px';
                    outCanvas.style.height = canvasSize.styleHeight + 18 + 'px';

                    _this.wrapperPdfs.appendChild(outCanvas);

                    resolve({
                      id: num,
                      renderStatus: 0,
                      page: page,
                      pageNum: num,
                      viewport: viewport,
                      pageContainer: outCanvas,
                      canvasSize: canvasSize
                    });

                  case 14:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2);
          }));

          return function (_x2) {
            return _ref2.apply(this, arguments);
          };
        }());
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_renderPage", function (view) {
      return new Promise(function (resolve) {
        var pageContainer = view.pageContainer,
            viewport = view.viewport,
            page = view.page,
            canvasSize = view.canvasSize,
            pageNum = view.pageNum,
            renderStatus = view.renderStatus;

        if (renderStatus === 1) {
          resolve({
            errcode: '0000',
            description: 'success'
          });
          return;
        }

        view.renderStatus = 2; // 正在渲染中

        var wrapperCanvasEl = document.createElement('div');
        wrapperCanvasEl.className = 'canvasWrapper';
        wrapperCanvasEl.style.width = canvasSize.styleWidth + 'px';
        wrapperCanvasEl.style.height = canvasSize.styleHeight + 'px';
        var canvas = document.createElement('canvas');
        canvas.id = 'page' + pageNum;
        var ctx = canvas.getContext('2d');
        canvas.width = canvasSize.width;
        canvas.height = canvasSize.height;
        canvas.style.width = canvasSize.styleWidth + 'px';
        canvas.style.height = canvasSize.styleHeight + 'px';
        var outputScale = canvasSize.outputScale;
        var transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];
        var renderContext = {
          canvasContext: ctx,
          transform: transform,
          viewport: viewport,
          renderInteractiveForms: !!_this.props.renderInteractiveForms
        };

        try {
          var pagesContainerRotate = _this.state.pagesContainerRotate;
          var currentPageRotate = pagesContainerRotate[pageNum];

          if (currentPageRotate || Number(currentPageRotate) === 0) {
            pageContainer.style.transform = 'rotate(' + currentPageRotate + 'deg)';

            while (pageContainer.hasChildNodes()) {
              pageContainer.removeChild(pageContainer.lastChild);
            }
          }

          var pageRendering = page.render(renderContext);
          pageRendering.promise.then(function () {
            // 渲染成功
            wrapperCanvasEl.appendChild(canvas);
            pageContainer.appendChild(wrapperCanvasEl);
            page.getTextContent({// normalizeWhitespace: true
            }).then(function (oldTextContent) {
              var items = oldTextContent.items;
              var newItems = [];

              for (var i = 0; i < items.length; i++) {
                var curItem = items[i];
                var str = curItem.str || '';

                if (typeof str.trim === 'function') {
                  str = str.trim();
                } else {
                  str = str.replace(/^\s+/, '').replace(/\s+$/, '');
                }

                if (str) {
                  newItems.push(curItem);
                }
              }

              var textContent = _objectSpread(_objectSpread({}, oldTextContent), {}, {
                items: newItems
              });

              var textLayerDiv = document.createElement('div');
              textLayerDiv.setAttribute('class', 'textLayer');
              pageContainer.appendChild(textLayerDiv); // 创建新的TextLayerBuilder实例

              var textLayer = new pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_3__["TextLayerBuilder"]({
                eventBus: _this.eventBus,
                textLayerDiv: textLayerDiv,
                pageIndex: page.pageIndex,
                viewport: viewport
              });
              textLayer.setTextContent(textContent);
              textLayer.render();
              pageContainer.className = 'page';
              view.renderStatus = 1; // 渲染结束

              page.cleanup();
              resolve({
                errcode: '0000',
                description: 'success'
              });
            });
          }, function (error) {
            window.console && console.log('pdf预览异常', error);
            page.cleanup();
            resolve({
              errcode: '5000',
              description: 'pdf预览异常'
            });
          });
        } catch (error) {
          window.console && console.log('pdf处理异常', error);
          page.cleanup();
          resolve({
            errcode: '5000',
            description: 'pdf处理异常'
          });
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_rotatePage", function (pageNum, dir) {
      // 旋转当前页
      var _this$state = _this.state,
          pagesContainerRotate = _this$state.pagesContainerRotate,
          viewers = _this$state.viewers;
      var currentView = viewers[pageNum - 1];
      var currentPageRotate = pagesContainerRotate[pageNum] || 0;

      if (dir === 's') {
        currentPageRotate = currentPageRotate <= -360 ? 0 : currentPageRotate + 90;
      } else {
        currentPageRotate = currentPageRotate >= 360 ? 0 : currentPageRotate - 90;
      }

      _this.setState({
        pagesContainerRotate: _objectSpread(_objectSpread({}, pagesContainerRotate), {}, _defineProperty({}, pageNum, currentPageRotate))
      }, function () {
        var setPageRotate = _this.props.setPageRotate;

        if (setPageRotate) {
          if (setPageRotate) {
            setPageRotate(pageNum, currentPageRotate);
          }
        }

        currentView.renderStatus = 0;

        _this._renderPage(currentView);
      });
    });

    _defineProperty(_assertThisInitialized(_this), "rotateRight", function (pageNum) {
      _this._rotatePage(pageNum, 's');
    });

    _defineProperty(_assertThisInitialized(_this), "rotateLeft", function (pageNum) {
      _this._rotatePage(pageNum);
    });

    _defineProperty(_assertThisInitialized(_this), "goToPage", function (pageNum) {
      var viewers = _this.state.viewers;
      var top = 0;

      for (var i = 0; i < pageNum - 1; i++) {
        top += viewers[i].canvasSize.styleHeight + 11;
      }

      _this.mySetState({
        activePageNum: pageNum
      });

      _this.viewerContainer.scrollTop = top;
    });

    _defineProperty(_assertThisInitialized(_this), "request", function (url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve) {
        var xhr = new XMLHttpRequest();

        var onResponseProgress = options.onResponseProgress || function (f) {
          return f;
        };

        xhr.onload = function () {
          resolve({
            response: xhr.response
          });
        };

        xhr.onprogress = function () {
          var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          onResponseProgress(evt.loaded, evt.total, xhr);
        };

        try {
          xhr.open('GET', url);
          xhr.responseType = 'arraybuffer';
          xhr.send();
        } catch (e) {
          resolve({
            errcode: 'err',
            description: '获取文件异常'
          });
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this), "_loadFile", function (url, data) {
      var fileType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '1.pdf';
      var filename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      return new Promise(function (resolve) {
        if (data) {
          _this.mySetState({
            docRaw: data,
            fileType: fileType,
            filename: filename || ''
          });

          _this.fileType = fileType;
          pdfjs_dist__WEBPACK_IMPORTED_MODULE_2__["getDocument"]({
            data: new Uint8Array(data),
            cMapPacked: _this.props.cMapPacked,
            cMapUrl: _this.props.cMapUrl
          }).promise.then(function (pdf) {
            resolve({
              errcode: '0000',
              description: 'success',
              data: pdf
            });
          });
        } else {
          _this.fileType = '';

          _this.request(url, {
            onResponseProgress: function onResponseProgress(loaded, total, xhr) {
              if (!_this.fileType) {
                var info = Object(_tools__WEBPACK_IMPORTED_MODULE_6__["getDownloadInfo"])(xhr);
                _this.fileType = info.fileType;

                _this.mySetState({
                  fileType: info.fileType,
                  filename: info.filename
                });
              }

              _this.mySetState({
                percent: (parseFloat(loaded / total) * 100).toFixed(2)
              });
            }
          }).then(function (_ref3) {
            var response = _ref3.response;

            _this.mySetState({
              docRaw: response
            });

            if (_this.fileType === 'pdf') {
              pdfjs_dist__WEBPACK_IMPORTED_MODULE_2__["getDocument"]({
                data: new Uint8Array(response),
                cMapPacked: _this.props.cMapPacked,
                cMapUrl: _this.props.cMapUrl
              }).promise.then(function (pdf) {
                resolve({
                  errcode: '0000',
                  description: 'success',
                  data: pdf
                });
              });
            } else if (_this.fileType === 'json') {
              var dataStr = _this.buf2char(response);

              var jsonData = {
                errcode: '5000',
                description: '服务器异常，请稍后再试'
              };

              try {
                jsonData = JSON.parse(dataStr);
              } catch (error) {
                console.error('json转换异常', error);
              }

              _this.setState({
                responseErr: jsonData.description
              });
            }
          });
        }
      });
    });

    _defineProperty(_assertThisInitialized(_this), "clear", function () {
      var container = _this.wrapperPdfs;

      if (container) {
        while (container.hasChildNodes()) {
          container.removeChild(container.lastChild);
        }
      }

      var div = _this.printContainer;

      if (div) {
        while (div.hasChildNodes()) {
          div.removeChild(div.lastChild);
        }
      }

      _this.mySetState({
        viewers: []
      });
    });

    _defineProperty(_assertThisInitialized(_this), "toggleSlide", function () {
      _this.mySetState({
        openSlide: !_this.state.openSlide
      });
    });

    _this.eventBus = new pdfjs_dist_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_3__["EventBus"]();
    _this.renderLimit = 3;
    _this.scale = props.scale || 'auto';
    _this.rotation = 0;
    pdfjs_dist__WEBPACK_IMPORTED_MODULE_2__["GlobalWorkerOptions"].workerSrc = props.pdfWorkUrl;
    _this.state = {
      docRaw: null,
      fileType: '',
      filename: '',
      viewers: [],
      activePageNum: 1,
      openSlide: props.openSlide || false,
      currentPageNum: 1,
      loadFile: true,
      percent: 0.00,
      numPages: 0,
      scale: props.scale || 'auto',
      pagesContainerRotate: props.pagesContainerRotate || {},
      // 没页旋转角度
      currentFileSrc: ''
    };
    return _this;
  }

  _createClass(ViewPdf, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startRender();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var src = nextProps.src,
          pagesContainerRotate = nextProps.pagesContainerRotate;
      var currentFileSrc = this.state.currentFileSrc;

      if (src !== currentFileSrc && currentFileSrc) {
        this.startRender(src);
      }

      this.setState({
        currentFileSrc: src,
        pagesContainerRotate: pagesContainerRotate
      });
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._isAmounted = false;
    }
  }, {
    key: "startRender",
    value: function () {
      var _startRender = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(src) {
        var _this2 = this;

        var resDoc, tempViewers, i, view, visibileEles, activePageNum, _i2;

        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._isAmounted = true;
                _context3.next = 3;
                return this._loadFile(src || this.props.src, this.props.data, this.props.fileType, this.props.filename);

              case 3:
                resDoc = _context3.sent;

                if (!(this.fileType === 'pdf')) {
                  _context3.next = 30;
                  break;
                }

                this.init();
                this.pdfDoc = resDoc.data;
                this.numPages = this.pdfDoc.numPages;
                console.log('this.numPages-----test--', this.numPages);
                tempViewers = [];
                i = 1;

              case 11:
                if (!(i <= this.numPages)) {
                  _context3.next = 19;
                  break;
                }

                _context3.next = 14;
                return this._getView(i);

              case 14:
                view = _context3.sent;
                tempViewers.push(view);

              case 16:
                i++;
                _context3.next = 11;
                break;

              case 19:
                visibileEles = Object(_tools__WEBPACK_IMPORTED_MODULE_6__["getVisibleElements"])(this.viewerContainer, tempViewers, true);
                activePageNum = visibileEles.views.length > 0 ? visibileEles.views[0].view.pageNum : 1;
                this.mySetState({
                  loadFile: false,
                  numPages: this.numPages,
                  activePageNum: activePageNum,
                  viewers: tempViewers
                });
                _i2 = 0;

              case 23:
                if (!(_i2 < visibileEles.views.length)) {
                  _context3.next = 29;
                  break;
                }

                _context3.next = 26;
                return this._renderPage(visibileEles.views[_i2].view);

              case 26:
                _i2++;
                _context3.next = 23;
                break;

              case 29:
                setTimeout(function () {
                  if (_this2.numPages == 1) {
                    //处理单页第一次渲染电子签不显示bug
                    _this2.calibrationData();
                  }
                }, 50);

              case 30:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function startRender(_x3) {
        return _startRender.apply(this, arguments);
      }

      return startRender;
    }()
  }, {
    key: "base64ToUint8Array",
    value: function base64ToUint8Array(base64) {
      var raw = window.atob(base64);
      var rawLength = raw.length;
      var array = new Uint8Array(new ArrayBuffer(rawLength));

      for (var i = 0; i < rawLength; i++) {
        array[i] = raw.charCodeAt(i);
      }

      return array;
    }
  }, {
    key: "uint8ArrayToBase64",
    value: function uint8ArrayToBase64(buffer) {
      var array = new Uint8Array(buffer);
      var res = '';
      var chunk = 8 * 1024;
      var i;

      for (i = 0; i < array.length / chunk; i++) {
        res += String.fromCharCode.apply(null, array.slice(i * chunk, (i + 1) * chunk));
      }

      res += String.fromCharCode.apply(null, array.slice(i * chunk)); // const str = String.fromCharCode(...new Uint8Array(buffer));

      return 'data:image/jpeg;base64,' + window.btoa(res);
    } // buffer转换为字符串

  }, {
    key: "buf2char",
    value: function buf2char(buffer) {
      var array = new Uint8Array(buffer);
      var res = '';
      var chunk = 8 * 1024;
      var i;

      for (i = 0; i < array.length / chunk; i++) {
        res += String.fromCharCode.apply(null, array.slice(i * chunk, (i + 1) * chunk));
      }

      res += String.fromCharCode.apply(null, array.slice(i * chunk));
      return decodeURIComponent(escape(res));
    }
  }, {
    key: "render",
    value: function render() {
      var defaultCls = ['pwy-render-in-body clearBoth'];
      var _this$state2 = this.state,
          loadFile = _this$state2.loadFile,
          percent = _this$state2.percent,
          numPages = _this$state2.numPages,
          scale = _this$state2.scale,
          openSlide = _this$state2.openSlide,
          activePageNum = _this$state2.activePageNum,
          viewers = _this$state2.viewers,
          filename = _this$state2.filename,
          fileType = _this$state2.fileType,
          docRaw = _this$state2.docRaw,
          responseErr = _this$state2.responseErr;
      var _this$props = this.props,
          _this$props$style = _this$props.style,
          style = _this$props$style === void 0 ? {} : _this$props$style,
          className = _this$props.className;

      if (className) {
        defaultCls = defaultCls.concat(className.split(' '));
      }

      if (openSlide) {
        defaultCls.push('sidebarOpen');
      }

      var isMobile = isAndroid || isIOS || document.body.clientWidth < 800;

      if (fileType === 'pdf') {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          id: "outerContainer",
          className: defaultCls.join(' ')
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          id: "sidebarContainer"
        }, !isMobile && viewers.length > 0 ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_sliderBar__WEBPACK_IMPORTED_MODULE_9__["default"], {
          sidebarContent: this.sidebarContent,
          viewerContainer: this.viewerContainer,
          viewers: viewers,
          activePageNum: activePageNum,
          goToPage: this.goToPage,
          rotateRight: this.rotateRight,
          rotateLeft: this.rotateLeft
        }) : null), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          id: "mainContainer"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_toolbar__WEBPACK_IMPORTED_MODULE_4__["default"], {
          fileType: fileType,
          viewers: viewers,
          filename: filename,
          percent: percent,
          loadFile: loadFile,
          docData: docRaw,
          numPages: numPages,
          activePageNum: activePageNum,
          eventBus: this.eventBus,
          scale: scale,
          foreceRender: this.foreceRender,
          wrapperPdfs: this.wrapperPdfs,
          viewerContainer: this.viewerContainer,
          toggleSlide: this.toggleSlide,
          isAndroid: isAndroid,
          isIOS: isIOS,
          goToPage: this.goToPage
        }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          style: style,
          id: "viewerContainer",
          tabIndex: "0"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          id: "viewer",
          className: "pdfViewer"
        })))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          id: "printContainer"
        }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          id: "mozPrintCallback-shim",
          hidden: true
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          className: "mozPrintCallback-dialog-box"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          className: "progress-row"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("progress", {
          value: "0",
          max: "100"
        }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
          className: "relative-progress"
        }, "0%")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          className: "progress-actions"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", {
          type: "button",
          className: "mozPrintCallback-cancel",
          value: "Cancel"
        })))));
      } else if (fileType === 'json') {
        // 后台返回异常信息
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("h3", {
          style: {
            textAlign: 'center',
            marginTop: 30
          }
        }, responseErr || '服务端异常, 请稍候再试！');
      }

      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_piaozone_com_spin__WEBPACK_IMPORTED_MODULE_5__["default"], null);
    }
  }]);

  return ViewPdf;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

ViewPdf.propTypes = {
  cMapPacked: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  cMapUrl: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  style: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,
  className: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  src: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  useOnlyCssZoom: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  renderInteractiveForms: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,
  filename: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  fileType: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  pagesContainerRotate: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object,
  setPageRotate: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func,
  scale: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,
  openSlide: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,
  pdfWorkUrl: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string
};
/* harmony default export */ __webpack_exports__["default"] = (ViewPdf);

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(3);

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(5)(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(4);
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(3);
var assign = __webpack_require__(6);

var ReactPropTypesSecret = __webpack_require__(7);
var checkPropTypes = __webpack_require__(8);

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var printWarning = function() {};

if (true) {
  var ReactPropTypesSecret = __webpack_require__(7);
  var loggedTypeFailures = {};
  var has = Function.call.bind(Object.prototype.hasOwnProperty);

  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (true) {
    for (var typeSpecName in typeSpecs) {
      if (has(typeSpecs, typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          if (typeof typeSpecs[typeSpecName] !== 'function') {
            var err = Error(
              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +
              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.'
            );
            err.name = 'Invariant Violation';
            throw err;
          }
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        if (error && !(error instanceof Error)) {
          printWarning(
            (componentName || 'React class') + ': type specification of ' +
            location + ' `' + typeSpecName + '` is invalid; the type checker ' +
            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +
            'You may have forgotten to pass an argument to the type checker ' +
            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +
            'shape all require an argument).'
          );
        }
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          printWarning(
            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')
          );
        }
      }
    }
  }
}

/**
 * Resets warning cache when testing.
 *
 * @private
 */
checkPropTypes.resetWarningCache = function() {
  if (true) {
    loggedTypeFailures = {};
  }
}

module.exports = checkPropTypes;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer, module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2021 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(this, function () {
  return (
    /******/
    function () {
      // webpackBootstrap

      /******/
      "use strict";
      /******/

      var __webpack_modules__ = [
        /* 0 */
      ,
      /* 1 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.addLinkAttributes = addLinkAttributes;
        exports.deprecated = deprecated;
        exports.getFilenameFromUrl = getFilenameFromUrl;
        exports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;
        exports.getXfaPageViewport = getXfaPageViewport;
        exports.isDataScheme = isDataScheme;
        exports.isPdfFile = isPdfFile;
        exports.isValidFetchUrl = isValidFetchUrl;
        exports.loadScript = loadScript;
        exports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PDFDateString = exports.PageViewport = exports.LinkTarget = exports.DOMSVGFactory = exports.DOMStandardFontDataFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = void 0;

        var _util = __w_pdfjs_require__(2);

        var _base_factory = __w_pdfjs_require__(5);

        var DEFAULT_LINK_REL = "noopener noreferrer nofollow";
        var SVG_NS = "http://www.w3.org/2000/svg";
        var PixelsPerInch = {
          CSS: 96.0,
          PDF: 72.0,

          get PDF_TO_CSS_UNITS() {
            return (0, _util.shadow)(this, "PDF_TO_CSS_UNITS", this.CSS / this.PDF);
          }

        };
        exports.PixelsPerInch = PixelsPerInch;

        var DOMCanvasFactory = /*#__PURE__*/function (_base_factory$BaseCan) {
          _inherits(DOMCanvasFactory, _base_factory$BaseCan);

          var _super = _createSuper(DOMCanvasFactory);

          function DOMCanvasFactory() {
            var _this;

            var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref$ownerDocument = _ref.ownerDocument,
                ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument;

            _classCallCheck(this, DOMCanvasFactory);

            _this = _super.call(this);
            _this._document = ownerDocument;
            return _this;
          }

          _createClass(DOMCanvasFactory, [{
            key: "_createCanvas",
            value: function _createCanvas(width, height) {
              var canvas = this._document.createElement("canvas");

              canvas.width = width;
              canvas.height = height;
              return canvas;
            }
          }]);

          return DOMCanvasFactory;
        }(_base_factory.BaseCanvasFactory);

        exports.DOMCanvasFactory = DOMCanvasFactory;

        function fetchData(_x) {
          return _fetchData.apply(this, arguments);
        }

        function _fetchData() {
          _fetchData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(url) {
            var asTypedArray,
                response,
                _args = arguments;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    asTypedArray = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;

                    if (!isValidFetchUrl(url, document.baseURI)) {
                      _context.next = 21;
                      break;
                    }

                    _context.next = 4;
                    return fetch(url);

                  case 4:
                    response = _context.sent;

                    if (response.ok) {
                      _context.next = 7;
                      break;
                    }

                    throw new Error(response.statusText);

                  case 7:
                    if (!asTypedArray) {
                      _context.next = 15;
                      break;
                    }

                    _context.t1 = Uint8Array;
                    _context.next = 11;
                    return response.arrayBuffer();

                  case 11:
                    _context.t2 = _context.sent;
                    _context.t0 = new _context.t1(_context.t2);
                    _context.next = 20;
                    break;

                  case 15:
                    _context.t3 = (0, _util.stringToBytes);
                    _context.next = 18;
                    return response.text();

                  case 18:
                    _context.t4 = _context.sent;
                    _context.t0 = (0, _context.t3)(_context.t4);

                  case 20:
                    return _context.abrupt("return", _context.t0);

                  case 21:
                    return _context.abrupt("return", new Promise(function (resolve, reject) {
                      var request = new XMLHttpRequest();
                      request.open("GET", url, true);

                      if (asTypedArray) {
                        request.responseType = "arraybuffer";
                      }

                      request.onreadystatechange = function () {
                        if (request.readyState !== XMLHttpRequest.DONE) {
                          return;
                        }

                        if (request.status === 200 || request.status === 0) {
                          var data;

                          if (asTypedArray && request.response) {
                            data = new Uint8Array(request.response);
                          } else if (!asTypedArray && request.responseText) {
                            data = (0, _util.stringToBytes)(request.responseText);
                          }

                          if (data) {
                            resolve(data);
                            return;
                          }
                        }

                        reject(new Error(request.statusText));
                      };

                      request.send(null);
                    }));

                  case 22:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));
          return _fetchData.apply(this, arguments);
        }

        var DOMCMapReaderFactory = /*#__PURE__*/function (_base_factory$BaseCMa) {
          _inherits(DOMCMapReaderFactory, _base_factory$BaseCMa);

          var _super2 = _createSuper(DOMCMapReaderFactory);

          function DOMCMapReaderFactory() {
            _classCallCheck(this, DOMCMapReaderFactory);

            return _super2.apply(this, arguments);
          }

          _createClass(DOMCMapReaderFactory, [{
            key: "_fetchData",
            value: function _fetchData(url, compressionType) {
              return fetchData(url, this.isCompressed).then(function (data) {
                return {
                  cMapData: data,
                  compressionType: compressionType
                };
              });
            }
          }]);

          return DOMCMapReaderFactory;
        }(_base_factory.BaseCMapReaderFactory);

        exports.DOMCMapReaderFactory = DOMCMapReaderFactory;

        var DOMStandardFontDataFactory = /*#__PURE__*/function (_base_factory$BaseSta) {
          _inherits(DOMStandardFontDataFactory, _base_factory$BaseSta);

          var _super3 = _createSuper(DOMStandardFontDataFactory);

          function DOMStandardFontDataFactory() {
            _classCallCheck(this, DOMStandardFontDataFactory);

            return _super3.apply(this, arguments);
          }

          _createClass(DOMStandardFontDataFactory, [{
            key: "_fetchData",
            value: function _fetchData(url) {
              return fetchData(url, true);
            }
          }]);

          return DOMStandardFontDataFactory;
        }(_base_factory.BaseStandardFontDataFactory);

        exports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;

        var DOMSVGFactory = /*#__PURE__*/function (_base_factory$BaseSVG) {
          _inherits(DOMSVGFactory, _base_factory$BaseSVG);

          var _super4 = _createSuper(DOMSVGFactory);

          function DOMSVGFactory() {
            _classCallCheck(this, DOMSVGFactory);

            return _super4.apply(this, arguments);
          }

          _createClass(DOMSVGFactory, [{
            key: "_createSVG",
            value: function _createSVG(type) {
              return document.createElementNS(SVG_NS, type);
            }
          }]);

          return DOMSVGFactory;
        }(_base_factory.BaseSVGFactory);

        exports.DOMSVGFactory = DOMSVGFactory;

        var PageViewport = /*#__PURE__*/function () {
          function PageViewport(_ref2) {
            var viewBox = _ref2.viewBox,
                scale = _ref2.scale,
                rotation = _ref2.rotation,
                _ref2$offsetX = _ref2.offsetX,
                offsetX = _ref2$offsetX === void 0 ? 0 : _ref2$offsetX,
                _ref2$offsetY = _ref2.offsetY,
                offsetY = _ref2$offsetY === void 0 ? 0 : _ref2$offsetY,
                _ref2$dontFlip = _ref2.dontFlip,
                dontFlip = _ref2$dontFlip === void 0 ? false : _ref2$dontFlip;

            _classCallCheck(this, PageViewport);

            this.viewBox = viewBox;
            this.scale = scale;
            this.rotation = rotation;
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            var centerX = (viewBox[2] + viewBox[0]) / 2;
            var centerY = (viewBox[3] + viewBox[1]) / 2;
            var rotateA, rotateB, rotateC, rotateD;
            rotation %= 360;

            if (rotation < 0) {
              rotation += 360;
            }

            switch (rotation) {
              case 180:
                rotateA = -1;
                rotateB = 0;
                rotateC = 0;
                rotateD = 1;
                break;

              case 90:
                rotateA = 0;
                rotateB = 1;
                rotateC = 1;
                rotateD = 0;
                break;

              case 270:
                rotateA = 0;
                rotateB = -1;
                rotateC = -1;
                rotateD = 0;
                break;

              case 0:
                rotateA = 1;
                rotateB = 0;
                rotateC = 0;
                rotateD = -1;
                break;

              default:
                throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
            }

            if (dontFlip) {
              rotateC = -rotateC;
              rotateD = -rotateD;
            }

            var offsetCanvasX, offsetCanvasY;
            var width, height;

            if (rotateA === 0) {
              offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
              offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
              width = Math.abs(viewBox[3] - viewBox[1]) * scale;
              height = Math.abs(viewBox[2] - viewBox[0]) * scale;
            } else {
              offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
              offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
              width = Math.abs(viewBox[2] - viewBox[0]) * scale;
              height = Math.abs(viewBox[3] - viewBox[1]) * scale;
            }

            this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
            this.width = width;
            this.height = height;
          }

          _createClass(PageViewport, [{
            key: "clone",
            value: function clone() {
              var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  _ref3$scale = _ref3.scale,
                  scale = _ref3$scale === void 0 ? this.scale : _ref3$scale,
                  _ref3$rotation = _ref3.rotation,
                  rotation = _ref3$rotation === void 0 ? this.rotation : _ref3$rotation,
                  _ref3$offsetX = _ref3.offsetX,
                  offsetX = _ref3$offsetX === void 0 ? this.offsetX : _ref3$offsetX,
                  _ref3$offsetY = _ref3.offsetY,
                  offsetY = _ref3$offsetY === void 0 ? this.offsetY : _ref3$offsetY,
                  _ref3$dontFlip = _ref3.dontFlip,
                  dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;

              return new PageViewport({
                viewBox: this.viewBox.slice(),
                scale: scale,
                rotation: rotation,
                offsetX: offsetX,
                offsetY: offsetY,
                dontFlip: dontFlip
              });
            }
          }, {
            key: "convertToViewportPoint",
            value: function convertToViewportPoint(x, y) {
              return _util.Util.applyTransform([x, y], this.transform);
            }
          }, {
            key: "convertToViewportRectangle",
            value: function convertToViewportRectangle(rect) {
              var topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);

              var bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);

              return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
            }
          }, {
            key: "convertToPdfPoint",
            value: function convertToPdfPoint(x, y) {
              return _util.Util.applyInverseTransform([x, y], this.transform);
            }
          }]);

          return PageViewport;
        }();

        exports.PageViewport = PageViewport;

        var RenderingCancelledException = /*#__PURE__*/function (_util$BaseException) {
          _inherits(RenderingCancelledException, _util$BaseException);

          var _super5 = _createSuper(RenderingCancelledException);

          function RenderingCancelledException(msg, type) {
            var _this2;

            _classCallCheck(this, RenderingCancelledException);

            _this2 = _super5.call(this, msg, "RenderingCancelledException");
            _this2.type = type;
            return _this2;
          }

          return _createClass(RenderingCancelledException);
        }(_util.BaseException);

        exports.RenderingCancelledException = RenderingCancelledException;
        var LinkTarget = {
          NONE: 0,
          SELF: 1,
          BLANK: 2,
          PARENT: 3,
          TOP: 4
        };
        exports.LinkTarget = LinkTarget;

        function addLinkAttributes(link) {
          var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              url = _ref4.url,
              target = _ref4.target,
              rel = _ref4.rel,
              _ref4$enabled = _ref4.enabled,
              enabled = _ref4$enabled === void 0 ? true : _ref4$enabled;

          (0, _util.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.');
          var urlNullRemoved = (0, _util.removeNullCharacters)(url);

          if (enabled) {
            link.href = link.title = urlNullRemoved;
          } else {
            link.href = "";
            link.title = "Disabled: ".concat(urlNullRemoved);

            link.onclick = function () {
              return false;
            };
          }

          var targetStr = "";

          switch (target) {
            case LinkTarget.NONE:
              break;

            case LinkTarget.SELF:
              targetStr = "_self";
              break;

            case LinkTarget.BLANK:
              targetStr = "_blank";
              break;

            case LinkTarget.PARENT:
              targetStr = "_parent";
              break;

            case LinkTarget.TOP:
              targetStr = "_top";
              break;
          }

          link.target = targetStr;
          link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL;
        }

        function isDataScheme(url) {
          var ii = url.length;
          var i = 0;

          while (i < ii && url[i].trim() === "") {
            i++;
          }

          return url.substring(i, i + 5).toLowerCase() === "data:";
        }

        function isPdfFile(filename) {
          return typeof filename === "string" && /\.pdf$/i.test(filename);
        }

        function getFilenameFromUrl(url) {
          var anchor = url.indexOf("#");
          var query = url.indexOf("?");
          var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
          return url.substring(url.lastIndexOf("/", end) + 1, end);
        }

        function getPdfFilenameFromUrl(url) {
          var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "document.pdf";

          if (typeof url !== "string") {
            return defaultFilename;
          }

          if (isDataScheme(url)) {
            (0, _util.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
            return defaultFilename;
          }

          var reURI = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/;
          var reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
          var splitURI = reURI.exec(url);
          var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);

          if (suggestedFilename) {
            suggestedFilename = suggestedFilename[0];

            if (suggestedFilename.includes("%")) {
              try {
                suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];
              } catch (ex) {}
            }
          }

          return suggestedFilename || defaultFilename;
        }

        var StatTimer = /*#__PURE__*/function () {
          function StatTimer() {
            _classCallCheck(this, StatTimer);

            this.started = Object.create(null);
            this.times = [];
          }

          _createClass(StatTimer, [{
            key: "time",
            value: function time(name) {
              if (name in this.started) {
                (0, _util.warn)("Timer is already running for ".concat(name));
              }

              this.started[name] = Date.now();
            }
          }, {
            key: "timeEnd",
            value: function timeEnd(name) {
              if (!(name in this.started)) {
                (0, _util.warn)("Timer has not been started for ".concat(name));
              }

              this.times.push({
                name: name,
                start: this.started[name],
                end: Date.now()
              });
              delete this.started[name];
            }
          }, {
            key: "toString",
            value: function toString() {
              var outBuf = [];
              var longest = 0;

              var _iterator = _createForOfIteratorHelper(this.times),
                  _step;

              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var time = _step.value;
                  var name = time.name;

                  if (name.length > longest) {
                    longest = name.length;
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }

              var _iterator2 = _createForOfIteratorHelper(this.times),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var _time = _step2.value;
                  var duration = _time.end - _time.start;
                  outBuf.push("".concat(_time.name.padEnd(longest), " ").concat(duration, "ms\n"));
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              return outBuf.join("");
            }
          }]);

          return StatTimer;
        }();

        exports.StatTimer = StatTimer;

        function isValidFetchUrl(url, baseUrl) {
          try {
            var _ref5 = baseUrl ? new URL(url, baseUrl) : new URL(url),
                protocol = _ref5.protocol;

            return protocol === "http:" || protocol === "https:";
          } catch (ex) {
            return false;
          }
        }

        function loadScript(src) {
          var removeScriptElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          return new Promise(function (resolve, reject) {
            var script = document.createElement("script");
            script.src = src;

            script.onload = function (evt) {
              if (removeScriptElement) {
                script.remove();
              }

              resolve(evt);
            };

            script.onerror = function () {
              reject(new Error("Cannot load script at: ".concat(script.src)));
            };

            (document.head || document.documentElement).appendChild(script);
          });
        }

        function deprecated(details) {
          console.log("Deprecated API usage: " + details);
        }

        var pdfDateStringRegex;

        var PDFDateString = /*#__PURE__*/function () {
          function PDFDateString() {
            _classCallCheck(this, PDFDateString);
          }

          _createClass(PDFDateString, null, [{
            key: "toDateObject",
            value: function toDateObject(input) {
              if (!input || !(0, _util.isString)(input)) {
                return null;
              }

              if (!pdfDateStringRegex) {
                pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
              }

              var matches = pdfDateStringRegex.exec(input);

              if (!matches) {
                return null;
              }

              var year = parseInt(matches[1], 10);
              var month = parseInt(matches[2], 10);
              month = month >= 1 && month <= 12 ? month - 1 : 0;
              var day = parseInt(matches[3], 10);
              day = day >= 1 && day <= 31 ? day : 1;
              var hour = parseInt(matches[4], 10);
              hour = hour >= 0 && hour <= 23 ? hour : 0;
              var minute = parseInt(matches[5], 10);
              minute = minute >= 0 && minute <= 59 ? minute : 0;
              var second = parseInt(matches[6], 10);
              second = second >= 0 && second <= 59 ? second : 0;
              var universalTimeRelation = matches[7] || "Z";
              var offsetHour = parseInt(matches[8], 10);
              offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
              var offsetMinute = parseInt(matches[9], 10) || 0;
              offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;

              if (universalTimeRelation === "-") {
                hour += offsetHour;
                minute += offsetMinute;
              } else if (universalTimeRelation === "+") {
                hour -= offsetHour;
                minute -= offsetMinute;
              }

              return new Date(Date.UTC(year, month, day, hour, minute, second));
            }
          }]);

          return PDFDateString;
        }();

        exports.PDFDateString = PDFDateString;

        function getXfaPageViewport(xfaPage, _ref6) {
          var _ref6$scale = _ref6.scale,
              scale = _ref6$scale === void 0 ? 1 : _ref6$scale,
              _ref6$rotation = _ref6.rotation,
              rotation = _ref6$rotation === void 0 ? 0 : _ref6$rotation;
          var _xfaPage$attributes$s = xfaPage.attributes.style,
              width = _xfaPage$attributes$s.width,
              height = _xfaPage$attributes$s.height;
          var viewBox = [0, 0, parseInt(width), parseInt(height)];
          return new PageViewport({
            viewBox: viewBox,
            scale: scale,
            rotation: rotation
          });
        }
        /***/

      },
      /* 2 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.arrayByteLength = arrayByteLength;
        exports.arraysToBytes = arraysToBytes;
        exports.assert = assert;
        exports.bytesToString = bytesToString;
        exports.createObjectURL = createObjectURL;
        exports.createPromiseCapability = createPromiseCapability;
        exports.createValidAbsoluteUrl = createValidAbsoluteUrl;
        exports.escapeString = escapeString;
        exports.getModificationDate = getModificationDate;
        exports.getVerbosityLevel = getVerbosityLevel;
        exports.info = info;
        exports.isArrayBuffer = isArrayBuffer;
        exports.isArrayEqual = isArrayEqual;
        exports.isAscii = isAscii;
        exports.isBool = isBool;
        exports.isNum = isNum;
        exports.isSameOrigin = isSameOrigin;
        exports.isString = isString;
        exports.objectFromMap = objectFromMap;
        exports.objectSize = objectSize;
        exports.removeNullCharacters = removeNullCharacters;
        exports.setVerbosityLevel = setVerbosityLevel;
        exports.shadow = shadow;
        exports.string32 = string32;
        exports.stringToBytes = stringToBytes;
        exports.stringToPDFString = stringToPDFString;
        exports.stringToUTF16BEString = stringToUTF16BEString;
        exports.stringToUTF8String = stringToUTF8String;
        exports.unreachable = unreachable;
        exports.utf8StringToString = utf8StringToString;
        exports.warn = warn;
        exports.VerbosityLevel = exports.Util = exports.UNSUPPORTED_FEATURES = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.RenderingIntentFlag = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.IsLittleEndianCached = exports.IsEvalSupportedCached = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FontType = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMode = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;

        __w_pdfjs_require__(3);

        var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];
        exports.IDENTITY_MATRIX = IDENTITY_MATRIX;
        var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
        exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;
        var RenderingIntentFlag = {
          ANY: 0x01,
          DISPLAY: 0x02,
          PRINT: 0x04,
          ANNOTATIONS_FORMS: 0x10,
          ANNOTATIONS_STORAGE: 0x20,
          ANNOTATIONS_DISABLE: 0x40,
          OPLIST: 0x100
        };
        exports.RenderingIntentFlag = RenderingIntentFlag;
        var AnnotationMode = {
          DISABLE: 0,
          ENABLE: 1,
          ENABLE_FORMS: 2,
          ENABLE_STORAGE: 3
        };
        exports.AnnotationMode = AnnotationMode;
        var PermissionFlag = {
          PRINT: 0x04,
          MODIFY_CONTENTS: 0x08,
          COPY: 0x10,
          MODIFY_ANNOTATIONS: 0x20,
          FILL_INTERACTIVE_FORMS: 0x100,
          COPY_FOR_ACCESSIBILITY: 0x200,
          ASSEMBLE: 0x400,
          PRINT_HIGH_QUALITY: 0x800
        };
        exports.PermissionFlag = PermissionFlag;
        var TextRenderingMode = {
          FILL: 0,
          STROKE: 1,
          FILL_STROKE: 2,
          INVISIBLE: 3,
          FILL_ADD_TO_PATH: 4,
          STROKE_ADD_TO_PATH: 5,
          FILL_STROKE_ADD_TO_PATH: 6,
          ADD_TO_PATH: 7,
          FILL_STROKE_MASK: 3,
          ADD_TO_PATH_FLAG: 4
        };
        exports.TextRenderingMode = TextRenderingMode;
        var ImageKind = {
          GRAYSCALE_1BPP: 1,
          RGB_24BPP: 2,
          RGBA_32BPP: 3
        };
        exports.ImageKind = ImageKind;
        var AnnotationType = {
          TEXT: 1,
          LINK: 2,
          FREETEXT: 3,
          LINE: 4,
          SQUARE: 5,
          CIRCLE: 6,
          POLYGON: 7,
          POLYLINE: 8,
          HIGHLIGHT: 9,
          UNDERLINE: 10,
          SQUIGGLY: 11,
          STRIKEOUT: 12,
          STAMP: 13,
          CARET: 14,
          INK: 15,
          POPUP: 16,
          FILEATTACHMENT: 17,
          SOUND: 18,
          MOVIE: 19,
          WIDGET: 20,
          SCREEN: 21,
          PRINTERMARK: 22,
          TRAPNET: 23,
          WATERMARK: 24,
          THREED: 25,
          REDACT: 26
        };
        exports.AnnotationType = AnnotationType;
        var AnnotationStateModelType = {
          MARKED: "Marked",
          REVIEW: "Review"
        };
        exports.AnnotationStateModelType = AnnotationStateModelType;
        var AnnotationMarkedState = {
          MARKED: "Marked",
          UNMARKED: "Unmarked"
        };
        exports.AnnotationMarkedState = AnnotationMarkedState;
        var AnnotationReviewState = {
          ACCEPTED: "Accepted",
          REJECTED: "Rejected",
          CANCELLED: "Cancelled",
          COMPLETED: "Completed",
          NONE: "None"
        };
        exports.AnnotationReviewState = AnnotationReviewState;
        var AnnotationReplyType = {
          GROUP: "Group",
          REPLY: "R"
        };
        exports.AnnotationReplyType = AnnotationReplyType;
        var AnnotationFlag = {
          INVISIBLE: 0x01,
          HIDDEN: 0x02,
          PRINT: 0x04,
          NOZOOM: 0x08,
          NOROTATE: 0x10,
          NOVIEW: 0x20,
          READONLY: 0x40,
          LOCKED: 0x80,
          TOGGLENOVIEW: 0x100,
          LOCKEDCONTENTS: 0x200
        };
        exports.AnnotationFlag = AnnotationFlag;
        var AnnotationFieldFlag = {
          READONLY: 0x0000001,
          REQUIRED: 0x0000002,
          NOEXPORT: 0x0000004,
          MULTILINE: 0x0001000,
          PASSWORD: 0x0002000,
          NOTOGGLETOOFF: 0x0004000,
          RADIO: 0x0008000,
          PUSHBUTTON: 0x0010000,
          COMBO: 0x0020000,
          EDIT: 0x0040000,
          SORT: 0x0080000,
          FILESELECT: 0x0100000,
          MULTISELECT: 0x0200000,
          DONOTSPELLCHECK: 0x0400000,
          DONOTSCROLL: 0x0800000,
          COMB: 0x1000000,
          RICHTEXT: 0x2000000,
          RADIOSINUNISON: 0x2000000,
          COMMITONSELCHANGE: 0x4000000
        };
        exports.AnnotationFieldFlag = AnnotationFieldFlag;
        var AnnotationBorderStyleType = {
          SOLID: 1,
          DASHED: 2,
          BEVELED: 3,
          INSET: 4,
          UNDERLINE: 5
        };
        exports.AnnotationBorderStyleType = AnnotationBorderStyleType;
        var AnnotationActionEventType = {
          E: "Mouse Enter",
          X: "Mouse Exit",
          D: "Mouse Down",
          U: "Mouse Up",
          Fo: "Focus",
          Bl: "Blur",
          PO: "PageOpen",
          PC: "PageClose",
          PV: "PageVisible",
          PI: "PageInvisible",
          K: "Keystroke",
          F: "Format",
          V: "Validate",
          C: "Calculate"
        };
        exports.AnnotationActionEventType = AnnotationActionEventType;
        var DocumentActionEventType = {
          WC: "WillClose",
          WS: "WillSave",
          DS: "DidSave",
          WP: "WillPrint",
          DP: "DidPrint"
        };
        exports.DocumentActionEventType = DocumentActionEventType;
        var PageActionEventType = {
          O: "PageOpen",
          C: "PageClose"
        };
        exports.PageActionEventType = PageActionEventType;
        var StreamType = {
          UNKNOWN: "UNKNOWN",
          FLATE: "FLATE",
          LZW: "LZW",
          DCT: "DCT",
          JPX: "JPX",
          JBIG: "JBIG",
          A85: "A85",
          AHX: "AHX",
          CCF: "CCF",
          RLX: "RLX"
        };
        exports.StreamType = StreamType;
        var FontType = {
          UNKNOWN: "UNKNOWN",
          TYPE1: "TYPE1",
          TYPE1STANDARD: "TYPE1STANDARD",
          TYPE1C: "TYPE1C",
          CIDFONTTYPE0: "CIDFONTTYPE0",
          CIDFONTTYPE0C: "CIDFONTTYPE0C",
          TRUETYPE: "TRUETYPE",
          CIDFONTTYPE2: "CIDFONTTYPE2",
          TYPE3: "TYPE3",
          OPENTYPE: "OPENTYPE",
          TYPE0: "TYPE0",
          MMTYPE1: "MMTYPE1"
        };
        exports.FontType = FontType;
        var VerbosityLevel = {
          ERRORS: 0,
          WARNINGS: 1,
          INFOS: 5
        };
        exports.VerbosityLevel = VerbosityLevel;
        var CMapCompressionType = {
          NONE: 0,
          BINARY: 1,
          STREAM: 2
        };
        exports.CMapCompressionType = CMapCompressionType;
        var OPS = {
          dependency: 1,
          setLineWidth: 2,
          setLineCap: 3,
          setLineJoin: 4,
          setMiterLimit: 5,
          setDash: 6,
          setRenderingIntent: 7,
          setFlatness: 8,
          setGState: 9,
          save: 10,
          restore: 11,
          transform: 12,
          moveTo: 13,
          lineTo: 14,
          curveTo: 15,
          curveTo2: 16,
          curveTo3: 17,
          closePath: 18,
          rectangle: 19,
          stroke: 20,
          closeStroke: 21,
          fill: 22,
          eoFill: 23,
          fillStroke: 24,
          eoFillStroke: 25,
          closeFillStroke: 26,
          closeEOFillStroke: 27,
          endPath: 28,
          clip: 29,
          eoClip: 30,
          beginText: 31,
          endText: 32,
          setCharSpacing: 33,
          setWordSpacing: 34,
          setHScale: 35,
          setLeading: 36,
          setFont: 37,
          setTextRenderingMode: 38,
          setTextRise: 39,
          moveText: 40,
          setLeadingMoveText: 41,
          setTextMatrix: 42,
          nextLine: 43,
          showText: 44,
          showSpacedText: 45,
          nextLineShowText: 46,
          nextLineSetSpacingShowText: 47,
          setCharWidth: 48,
          setCharWidthAndBounds: 49,
          setStrokeColorSpace: 50,
          setFillColorSpace: 51,
          setStrokeColor: 52,
          setStrokeColorN: 53,
          setFillColor: 54,
          setFillColorN: 55,
          setStrokeGray: 56,
          setFillGray: 57,
          setStrokeRGBColor: 58,
          setFillRGBColor: 59,
          setStrokeCMYKColor: 60,
          setFillCMYKColor: 61,
          shadingFill: 62,
          beginInlineImage: 63,
          beginImageData: 64,
          endInlineImage: 65,
          paintXObject: 66,
          markPoint: 67,
          markPointProps: 68,
          beginMarkedContent: 69,
          beginMarkedContentProps: 70,
          endMarkedContent: 71,
          beginCompat: 72,
          endCompat: 73,
          paintFormXObjectBegin: 74,
          paintFormXObjectEnd: 75,
          beginGroup: 76,
          endGroup: 77,
          beginAnnotations: 78,
          endAnnotations: 79,
          beginAnnotation: 80,
          endAnnotation: 81,
          paintJpegXObject: 82,
          paintImageMaskXObject: 83,
          paintImageMaskXObjectGroup: 84,
          paintImageXObject: 85,
          paintInlineImageXObject: 86,
          paintInlineImageXObjectGroup: 87,
          paintImageXObjectRepeat: 88,
          paintImageMaskXObjectRepeat: 89,
          paintSolidColorImageMask: 90,
          constructPath: 91
        };
        exports.OPS = OPS;
        var UNSUPPORTED_FEATURES = {
          unknown: "unknown",
          forms: "forms",
          javaScript: "javaScript",
          signatures: "signatures",
          smask: "smask",
          shadingPattern: "shadingPattern",
          font: "font",
          errorTilingPattern: "errorTilingPattern",
          errorExtGState: "errorExtGState",
          errorXObject: "errorXObject",
          errorFontLoadType3: "errorFontLoadType3",
          errorFontState: "errorFontState",
          errorFontMissing: "errorFontMissing",
          errorFontTranslate: "errorFontTranslate",
          errorColorSpace: "errorColorSpace",
          errorOperatorList: "errorOperatorList",
          errorFontToUnicode: "errorFontToUnicode",
          errorFontLoadNative: "errorFontLoadNative",
          errorFontBuildPath: "errorFontBuildPath",
          errorFontGetPath: "errorFontGetPath",
          errorMarkedContent: "errorMarkedContent",
          errorContentSubStream: "errorContentSubStream"
        };
        exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;
        var PasswordResponses = {
          NEED_PASSWORD: 1,
          INCORRECT_PASSWORD: 2
        };
        exports.PasswordResponses = PasswordResponses;
        var verbosity = VerbosityLevel.WARNINGS;

        function setVerbosityLevel(level) {
          if (Number.isInteger(level)) {
            verbosity = level;
          }
        }

        function getVerbosityLevel() {
          return verbosity;
        }

        function info(msg) {
          if (verbosity >= VerbosityLevel.INFOS) {
            console.log("Info: ".concat(msg));
          }
        }

        function warn(msg) {
          if (verbosity >= VerbosityLevel.WARNINGS) {
            console.log("Warning: ".concat(msg));
          }
        }

        function unreachable(msg) {
          throw new Error(msg);
        }

        function assert(cond, msg) {
          if (!cond) {
            unreachable(msg);
          }
        }

        function isSameOrigin(baseUrl, otherUrl) {
          var base;

          try {
            base = new URL(baseUrl);

            if (!base.origin || base.origin === "null") {
              return false;
            }
          } catch (e) {
            return false;
          }

          var other = new URL(otherUrl, base);
          return base.origin === other.origin;
        }

        function _isValidProtocol(url) {
          if (!url) {
            return false;
          }

          switch (url.protocol) {
            case "http:":
            case "https:":
            case "ftp:":
            case "mailto:":
            case "tel:":
              return true;

            default:
              return false;
          }
        }

        function createValidAbsoluteUrl(url) {
          var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (!url) {
            return null;
          }

          try {
            if (options && typeof url === "string") {
              if (options.addDefaultProtocol && url.startsWith("www.")) {
                var dots = url.match(/\./g);

                if (dots && dots.length >= 2) {
                  url = "http://".concat(url);
                }
              }

              if (options.tryConvertEncoding) {
                try {
                  url = stringToUTF8String(url);
                } catch (ex) {}
              }
            }

            var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);

            if (_isValidProtocol(absoluteUrl)) {
              return absoluteUrl;
            }
          } catch (ex) {}

          return null;
        }

        function shadow(obj, prop, value) {
          Object.defineProperty(obj, prop, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: false
          });
          return value;
        }

        var BaseException = function BaseExceptionClosure() {
          function BaseException(message, name) {
            if (this.constructor === BaseException) {
              unreachable("Cannot initialize BaseException.");
            }

            this.message = message;
            this.name = name;
          }

          BaseException.prototype = new Error();
          BaseException.constructor = BaseException;
          return BaseException;
        }();

        exports.BaseException = BaseException;

        var PasswordException = /*#__PURE__*/function (_BaseException) {
          _inherits(PasswordException, _BaseException);

          var _super6 = _createSuper(PasswordException);

          function PasswordException(msg, code) {
            var _this3;

            _classCallCheck(this, PasswordException);

            _this3 = _super6.call(this, msg, "PasswordException");
            _this3.code = code;
            return _this3;
          }

          return _createClass(PasswordException);
        }(BaseException);

        exports.PasswordException = PasswordException;

        var UnknownErrorException = /*#__PURE__*/function (_BaseException2) {
          _inherits(UnknownErrorException, _BaseException2);

          var _super7 = _createSuper(UnknownErrorException);

          function UnknownErrorException(msg, details) {
            var _this4;

            _classCallCheck(this, UnknownErrorException);

            _this4 = _super7.call(this, msg, "UnknownErrorException");
            _this4.details = details;
            return _this4;
          }

          return _createClass(UnknownErrorException);
        }(BaseException);

        exports.UnknownErrorException = UnknownErrorException;

        var InvalidPDFException = /*#__PURE__*/function (_BaseException3) {
          _inherits(InvalidPDFException, _BaseException3);

          var _super8 = _createSuper(InvalidPDFException);

          function InvalidPDFException(msg) {
            _classCallCheck(this, InvalidPDFException);

            return _super8.call(this, msg, "InvalidPDFException");
          }

          return _createClass(InvalidPDFException);
        }(BaseException);

        exports.InvalidPDFException = InvalidPDFException;

        var MissingPDFException = /*#__PURE__*/function (_BaseException4) {
          _inherits(MissingPDFException, _BaseException4);

          var _super9 = _createSuper(MissingPDFException);

          function MissingPDFException(msg) {
            _classCallCheck(this, MissingPDFException);

            return _super9.call(this, msg, "MissingPDFException");
          }

          return _createClass(MissingPDFException);
        }(BaseException);

        exports.MissingPDFException = MissingPDFException;

        var UnexpectedResponseException = /*#__PURE__*/function (_BaseException5) {
          _inherits(UnexpectedResponseException, _BaseException5);

          var _super10 = _createSuper(UnexpectedResponseException);

          function UnexpectedResponseException(msg, status) {
            var _this5;

            _classCallCheck(this, UnexpectedResponseException);

            _this5 = _super10.call(this, msg, "UnexpectedResponseException");
            _this5.status = status;
            return _this5;
          }

          return _createClass(UnexpectedResponseException);
        }(BaseException);

        exports.UnexpectedResponseException = UnexpectedResponseException;

        var FormatError = /*#__PURE__*/function (_BaseException6) {
          _inherits(FormatError, _BaseException6);

          var _super11 = _createSuper(FormatError);

          function FormatError(msg) {
            _classCallCheck(this, FormatError);

            return _super11.call(this, msg, "FormatError");
          }

          return _createClass(FormatError);
        }(BaseException);

        exports.FormatError = FormatError;

        var AbortException = /*#__PURE__*/function (_BaseException7) {
          _inherits(AbortException, _BaseException7);

          var _super12 = _createSuper(AbortException);

          function AbortException(msg) {
            _classCallCheck(this, AbortException);

            return _super12.call(this, msg, "AbortException");
          }

          return _createClass(AbortException);
        }(BaseException);

        exports.AbortException = AbortException;
        var NullCharactersRegExp = /\x00/g;

        function removeNullCharacters(str) {
          if (typeof str !== "string") {
            warn("The argument for removeNullCharacters must be a string.");
            return str;
          }

          return str.replace(NullCharactersRegExp, "");
        }

        function bytesToString(bytes) {
          assert(bytes !== null && _typeof(bytes) === "object" && bytes.length !== undefined, "Invalid argument for bytesToString");
          var length = bytes.length;
          var MAX_ARGUMENT_COUNT = 8192;

          if (length < MAX_ARGUMENT_COUNT) {
            return String.fromCharCode.apply(null, bytes);
          }

          var strBuf = [];

          for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
            var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
            var chunk = bytes.subarray(i, chunkEnd);
            strBuf.push(String.fromCharCode.apply(null, chunk));
          }

          return strBuf.join("");
        }

        function stringToBytes(str) {
          assert(typeof str === "string", "Invalid argument for stringToBytes");
          var length = str.length;
          var bytes = new Uint8Array(length);

          for (var i = 0; i < length; ++i) {
            bytes[i] = str.charCodeAt(i) & 0xff;
          }

          return bytes;
        }

        function arrayByteLength(arr) {
          if (arr.length !== undefined) {
            return arr.length;
          }

          assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument.");
          return arr.byteLength;
        }

        function arraysToBytes(arr) {
          var length = arr.length;

          if (length === 1 && arr[0] instanceof Uint8Array) {
            return arr[0];
          }

          var resultLength = 0;

          for (var i = 0; i < length; i++) {
            resultLength += arrayByteLength(arr[i]);
          }

          var pos = 0;
          var data = new Uint8Array(resultLength);

          for (var _i = 0; _i < length; _i++) {
            var item = arr[_i];

            if (!(item instanceof Uint8Array)) {
              if (typeof item === "string") {
                item = stringToBytes(item);
              } else {
                item = new Uint8Array(item);
              }
            }

            var itemLength = item.byteLength;
            data.set(item, pos);
            pos += itemLength;
          }

          return data;
        }

        function string32(value) {
          return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
        }

        function objectSize(obj) {
          return Object.keys(obj).length;
        }

        function objectFromMap(map) {
          var obj = Object.create(null);

          var _iterator3 = _createForOfIteratorHelper(map),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _step3$value = _slicedToArray(_step3.value, 2),
                  key = _step3$value[0],
                  value = _step3$value[1];

              obj[key] = value;
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          return obj;
        }

        function isLittleEndian() {
          var buffer8 = new Uint8Array(4);
          buffer8[0] = 1;
          var view32 = new Uint32Array(buffer8.buffer, 0, 1);
          return view32[0] === 1;
        }

        var IsLittleEndianCached = {
          get value() {
            return shadow(this, "value", isLittleEndian());
          }

        };
        exports.IsLittleEndianCached = IsLittleEndianCached;

        function isEvalSupported() {
          try {
            new Function("");
            return true;
          } catch (e) {
            return false;
          }
        }

        var IsEvalSupportedCached = {
          get value() {
            return shadow(this, "value", isEvalSupported());
          }

        };
        exports.IsEvalSupportedCached = IsEvalSupportedCached;

        var hexNumbers = _toConsumableArray(Array(256).keys()).map(function (n) {
          return n.toString(16).padStart(2, "0");
        });

        var Util = /*#__PURE__*/function () {
          function Util() {
            _classCallCheck(this, Util);
          }

          _createClass(Util, null, [{
            key: "makeHexColor",
            value: function makeHexColor(r, g, b) {
              return "#".concat(hexNumbers[r]).concat(hexNumbers[g]).concat(hexNumbers[b]);
            }
          }, {
            key: "transform",
            value: function transform(m1, m2) {
              return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
            }
          }, {
            key: "applyTransform",
            value: function applyTransform(p, m) {
              var xt = p[0] * m[0] + p[1] * m[2] + m[4];
              var yt = p[0] * m[1] + p[1] * m[3] + m[5];
              return [xt, yt];
            }
          }, {
            key: "applyInverseTransform",
            value: function applyInverseTransform(p, m) {
              var d = m[0] * m[3] - m[1] * m[2];
              var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
              var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
              return [xt, yt];
            }
          }, {
            key: "getAxialAlignedBoundingBox",
            value: function getAxialAlignedBoundingBox(r, m) {
              var p1 = Util.applyTransform(r, m);
              var p2 = Util.applyTransform(r.slice(2, 4), m);
              var p3 = Util.applyTransform([r[0], r[3]], m);
              var p4 = Util.applyTransform([r[2], r[1]], m);
              return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
            }
          }, {
            key: "inverseTransform",
            value: function inverseTransform(m) {
              var d = m[0] * m[3] - m[1] * m[2];
              return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
            }
          }, {
            key: "apply3dTransform",
            value: function apply3dTransform(m, v) {
              return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
            }
          }, {
            key: "singularValueDecompose2dScale",
            value: function singularValueDecompose2dScale(m) {
              var transpose = [m[0], m[2], m[1], m[3]];
              var a = m[0] * transpose[0] + m[1] * transpose[2];
              var b = m[0] * transpose[1] + m[1] * transpose[3];
              var c = m[2] * transpose[0] + m[3] * transpose[2];
              var d = m[2] * transpose[1] + m[3] * transpose[3];
              var first = (a + d) / 2;
              var second = Math.sqrt(Math.pow(a + d, 2) - 4 * (a * d - c * b)) / 2;
              var sx = first + second || 1;
              var sy = first - second || 1;
              return [Math.sqrt(sx), Math.sqrt(sy)];
            }
          }, {
            key: "normalizeRect",
            value: function normalizeRect(rect) {
              var r = rect.slice(0);

              if (rect[0] > rect[2]) {
                r[0] = rect[2];
                r[2] = rect[0];
              }

              if (rect[1] > rect[3]) {
                r[1] = rect[3];
                r[3] = rect[1];
              }

              return r;
            }
          }, {
            key: "intersect",
            value: function intersect(rect1, rect2) {
              function compare(a, b) {
                return a - b;
              }

              var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
              var orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
              var result = [];
              rect1 = Util.normalizeRect(rect1);
              rect2 = Util.normalizeRect(rect2);

              if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
                result[0] = orderedX[1];
                result[2] = orderedX[2];
              } else {
                return null;
              }

              if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
                result[1] = orderedY[1];
                result[3] = orderedY[2];
              } else {
                return null;
              }

              return result;
            }
          }]);

          return Util;
        }();

        exports.Util = Util;
        var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];

        function stringToPDFString(str) {
          var length = str.length,
              strBuf = [];

          if (str[0] === "\xFE" && str[1] === "\xFF") {
            for (var i = 2; i < length; i += 2) {
              strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));
            }
          } else if (str[0] === "\xFF" && str[1] === "\xFE") {
            for (var _i2 = 2; _i2 < length; _i2 += 2) {
              strBuf.push(String.fromCharCode(str.charCodeAt(_i2 + 1) << 8 | str.charCodeAt(_i2)));
            }
          } else {
            for (var _i3 = 0; _i3 < length; ++_i3) {
              var code = PDFStringTranslateTable[str.charCodeAt(_i3)];
              strBuf.push(code ? String.fromCharCode(code) : str.charAt(_i3));
            }
          }

          return strBuf.join("");
        }

        function escapeString(str) {
          return str.replace(/([()\\\n\r])/g, function (match) {
            if (match === "\n") {
              return "\\n";
            } else if (match === "\r") {
              return "\\r";
            }

            return "\\".concat(match);
          });
        }

        function isAscii(str) {
          return /^[\x00-\x7F]*$/.test(str);
        }

        function stringToUTF16BEString(str) {
          var buf = ["\xFE\xFF"];

          for (var i = 0, ii = str.length; i < ii; i++) {
            var _char = str.charCodeAt(i);

            buf.push(String.fromCharCode(_char >> 8 & 0xff), String.fromCharCode(_char & 0xff));
          }

          return buf.join("");
        }

        function stringToUTF8String(str) {
          return decodeURIComponent(escape(str));
        }

        function utf8StringToString(str) {
          return unescape(encodeURIComponent(str));
        }

        function isBool(v) {
          return typeof v === "boolean";
        }

        function isNum(v) {
          return typeof v === "number";
        }

        function isString(v) {
          return typeof v === "string";
        }

        function isArrayBuffer(v) {
          return _typeof(v) === "object" && v !== null && v.byteLength !== undefined;
        }

        function isArrayEqual(arr1, arr2) {
          if (arr1.length !== arr2.length) {
            return false;
          }

          for (var i = 0, ii = arr1.length; i < ii; i++) {
            if (arr1[i] !== arr2[i]) {
              return false;
            }
          }

          return true;
        }

        function getModificationDate() {
          var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();
          var buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
          return buffer.join("");
        }

        function createPromiseCapability() {
          var capability = Object.create(null);
          var isSettled = false;
          Object.defineProperty(capability, "settled", {
            get: function get() {
              return isSettled;
            }
          });
          capability.promise = new Promise(function (resolve, reject) {
            capability.resolve = function (data) {
              isSettled = true;
              resolve(data);
            };

            capability.reject = function (reason) {
              isSettled = true;
              reject(reason);
            };
          });
          return capability;
        }

        function createObjectURL(data) {
          var contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
          var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          if (URL.createObjectURL && !forceDataSchema) {
            return URL.createObjectURL(new Blob([data], {
              type: contentType
            }));
          }

          var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
          var buffer = "data:".concat(contentType, ";base64,");

          for (var i = 0, ii = data.length; i < ii; i += 3) {
            var b1 = data[i] & 0xff;
            var b2 = data[i + 1] & 0xff;
            var b3 = data[i + 2] & 0xff;
            var d1 = b1 >> 2,
                d2 = (b1 & 3) << 4 | b2 >> 4;
            var d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;
            var d4 = i + 2 < ii ? b3 & 0x3f : 64;
            buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];
          }

          return buffer;
        }
        /***/

      },
      /* 3 */

      /***/
      function (__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) {
        var _is_node = __w_pdfjs_require__(4);

        ;
        /***/
      },
      /* 4 */

      /***/
      function (__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.isNodeJS = void 0;
        var isNodeJS = (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
        exports.isNodeJS = isNodeJS;
        /***/
      },
      /* 5 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.BaseSVGFactory = exports.BaseStandardFontDataFactory = exports.BaseCMapReaderFactory = exports.BaseCanvasFactory = void 0;

        var _util = __w_pdfjs_require__(2);

        var BaseCanvasFactory = /*#__PURE__*/function () {
          function BaseCanvasFactory() {
            _classCallCheck(this, BaseCanvasFactory);

            if (this.constructor === BaseCanvasFactory) {
              (0, _util.unreachable)("Cannot initialize BaseCanvasFactory.");
            }
          }

          _createClass(BaseCanvasFactory, [{
            key: "create",
            value: function create(width, height) {
              if (width <= 0 || height <= 0) {
                throw new Error("Invalid canvas size");
              }

              var canvas = this._createCanvas(width, height);

              return {
                canvas: canvas,
                context: canvas.getContext("2d")
              };
            }
          }, {
            key: "reset",
            value: function reset(canvasAndContext, width, height) {
              if (!canvasAndContext.canvas) {
                throw new Error("Canvas is not specified");
              }

              if (width <= 0 || height <= 0) {
                throw new Error("Invalid canvas size");
              }

              canvasAndContext.canvas.width = width;
              canvasAndContext.canvas.height = height;
            }
          }, {
            key: "destroy",
            value: function destroy(canvasAndContext) {
              if (!canvasAndContext.canvas) {
                throw new Error("Canvas is not specified");
              }

              canvasAndContext.canvas.width = 0;
              canvasAndContext.canvas.height = 0;
              canvasAndContext.canvas = null;
              canvasAndContext.context = null;
            }
          }, {
            key: "_createCanvas",
            value: function _createCanvas(width, height) {
              (0, _util.unreachable)("Abstract method `_createCanvas` called.");
            }
          }]);

          return BaseCanvasFactory;
        }();

        exports.BaseCanvasFactory = BaseCanvasFactory;

        var BaseCMapReaderFactory = /*#__PURE__*/function () {
          function BaseCMapReaderFactory(_ref7) {
            var _ref7$baseUrl = _ref7.baseUrl,
                baseUrl = _ref7$baseUrl === void 0 ? null : _ref7$baseUrl,
                _ref7$isCompressed = _ref7.isCompressed,
                isCompressed = _ref7$isCompressed === void 0 ? false : _ref7$isCompressed;

            _classCallCheck(this, BaseCMapReaderFactory);

            if (this.constructor === BaseCMapReaderFactory) {
              (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory.");
            }

            this.baseUrl = baseUrl;
            this.isCompressed = isCompressed;
          }

          _createClass(BaseCMapReaderFactory, [{
            key: "fetch",
            value: function () {
              var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref8) {
                var _this6 = this;

                var name, url, compressionType;
                return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        name = _ref8.name;

                        if (this.baseUrl) {
                          _context2.next = 3;
                          break;
                        }

                        throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.');

                      case 3:
                        if (name) {
                          _context2.next = 5;
                          break;
                        }

                        throw new Error("CMap name must be specified.");

                      case 5:
                        url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
                        compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;
                        return _context2.abrupt("return", this._fetchData(url, compressionType)["catch"](function (reason) {
                          throw new Error("Unable to load ".concat(_this6.isCompressed ? "binary " : "", "CMap at: ").concat(url));
                        }));

                      case 8:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2, this);
              }));

              function fetch(_x2) {
                return _fetch.apply(this, arguments);
              }

              return fetch;
            }()
          }, {
            key: "_fetchData",
            value: function _fetchData(url, compressionType) {
              (0, _util.unreachable)("Abstract method `_fetchData` called.");
            }
          }]);

          return BaseCMapReaderFactory;
        }();

        exports.BaseCMapReaderFactory = BaseCMapReaderFactory;

        var BaseStandardFontDataFactory = /*#__PURE__*/function () {
          function BaseStandardFontDataFactory(_ref9) {
            var _ref9$baseUrl = _ref9.baseUrl,
                baseUrl = _ref9$baseUrl === void 0 ? null : _ref9$baseUrl;

            _classCallCheck(this, BaseStandardFontDataFactory);

            if (this.constructor === BaseStandardFontDataFactory) {
              (0, _util.unreachable)("Cannot initialize BaseStandardFontDataFactory.");
            }

            this.baseUrl = baseUrl;
          }

          _createClass(BaseStandardFontDataFactory, [{
            key: "fetch",
            value: function () {
              var _fetch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref10) {
                var filename, url;
                return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                  while (1) {
                    switch (_context3.prev = _context3.next) {
                      case 0:
                        filename = _ref10.filename;

                        if (this.baseUrl) {
                          _context3.next = 3;
                          break;
                        }

                        throw new Error('The standard font "baseUrl" parameter must be specified, ensure that ' + 'the "standardFontDataUrl" API parameter is provided.');

                      case 3:
                        if (filename) {
                          _context3.next = 5;
                          break;
                        }

                        throw new Error("Font filename must be specified.");

                      case 5:
                        url = "".concat(this.baseUrl).concat(filename);
                        return _context3.abrupt("return", this._fetchData(url)["catch"](function (reason) {
                          throw new Error("Unable to load font data at: ".concat(url));
                        }));

                      case 7:
                      case "end":
                        return _context3.stop();
                    }
                  }
                }, _callee3, this);
              }));

              function fetch(_x3) {
                return _fetch2.apply(this, arguments);
              }

              return fetch;
            }()
          }, {
            key: "_fetchData",
            value: function _fetchData(url) {
              (0, _util.unreachable)("Abstract method `_fetchData` called.");
            }
          }]);

          return BaseStandardFontDataFactory;
        }();

        exports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;

        var BaseSVGFactory = /*#__PURE__*/function () {
          function BaseSVGFactory() {
            _classCallCheck(this, BaseSVGFactory);

            if (this.constructor === BaseSVGFactory) {
              (0, _util.unreachable)("Cannot initialize BaseSVGFactory.");
            }
          }

          _createClass(BaseSVGFactory, [{
            key: "create",
            value: function create(width, height) {
              if (width <= 0 || height <= 0) {
                throw new Error("Invalid SVG dimensions");
              }

              var svg = this._createSVG("svg:svg");

              svg.setAttribute("version", "1.1");
              svg.setAttribute("width", "".concat(width, "px"));
              svg.setAttribute("height", "".concat(height, "px"));
              svg.setAttribute("preserveAspectRatio", "none");
              svg.setAttribute("viewBox", "0 0 ".concat(width, " ").concat(height));
              return svg;
            }
          }, {
            key: "createElement",
            value: function createElement(type) {
              if (typeof type !== "string") {
                throw new Error("Invalid SVG element type");
              }

              return this._createSVG(type);
            }
          }, {
            key: "_createSVG",
            value: function _createSVG(type) {
              (0, _util.unreachable)("Abstract method `_createSVG` called.");
            }
          }]);

          return BaseSVGFactory;
        }();

        exports.BaseSVGFactory = BaseSVGFactory;
        /***/
      },
      /* 6 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.getDocument = getDocument;
        exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;
        exports.version = exports.RenderTask = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultCMapReaderFactory = exports.DefaultCanvasFactory = exports.build = void 0;

        var _util = __w_pdfjs_require__(2);

        var _display_utils = __w_pdfjs_require__(1);

        var _font_loader = __w_pdfjs_require__(7);

        var _node_utils = __w_pdfjs_require__(8);

        var _annotation_storage = __w_pdfjs_require__(9);

        var _canvas = __w_pdfjs_require__(10);

        var _worker_options = __w_pdfjs_require__(12);

        var _is_node = __w_pdfjs_require__(4);

        var _message_handler = __w_pdfjs_require__(13);

        var _metadata = __w_pdfjs_require__(14);

        var _optional_content_config = __w_pdfjs_require__(15);

        var _transport_stream = __w_pdfjs_require__(16);

        var _xfa_text = __w_pdfjs_require__(17);

        var DEFAULT_RANGE_CHUNK_SIZE = 65536;
        var RENDERING_CANCELLED_TIMEOUT = 100;
        var DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
        exports.DefaultCanvasFactory = DefaultCanvasFactory;
        var DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
        exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
        var DefaultStandardFontDataFactory = _is_node.isNodeJS ? _node_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
        exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
        var createPDFNetworkStream;

        function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {
          createPDFNetworkStream = pdfNetworkStreamFactory;
        }

        function getDocument(src) {
          var task = new PDFDocumentLoadingTask();
          var source;

          if (typeof src === "string" || src instanceof URL) {
            source = {
              url: src
            };
          } else if ((0, _util.isArrayBuffer)(src)) {
            source = {
              data: src
            };
          } else if (src instanceof PDFDataRangeTransport) {
            source = {
              range: src
            };
          } else {
            if (_typeof(src) !== "object") {
              throw new Error("Invalid parameter in getDocument, " + "need either string, URL, Uint8Array, or parameter object.");
            }

            if (!src.url && !src.data && !src.range) {
              throw new Error("Invalid parameter object: need either .data, .range or .url");
            }

            source = src;
          }

          var params = Object.create(null);
          var rangeTransport = null,
              worker = null;

          for (var key in source) {
            var value = source[key];

            switch (key) {
              case "url":
                if (typeof window !== "undefined") {
                  try {
                    params[key] = new URL(value, window.location).href;
                    continue;
                  } catch (ex) {
                    (0, _util.warn)("Cannot create valid URL: \"".concat(ex, "\"."));
                  }
                } else if (typeof value === "string" || value instanceof URL) {
                  params[key] = value.toString();
                  continue;
                }

                throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");

              case "range":
                rangeTransport = value;
                continue;

              case "worker":
                worker = value;
                continue;

              case "data":
                if (_is_node.isNodeJS && typeof Buffer !== "undefined" && value instanceof Buffer) {
                  params[key] = new Uint8Array(value);
                } else if (value instanceof Uint8Array) {
                  break;
                } else if (typeof value === "string") {
                  params[key] = (0, _util.stringToBytes)(value);
                } else if (_typeof(value) === "object" && value !== null && !isNaN(value.length)) {
                  params[key] = new Uint8Array(value);
                } else if ((0, _util.isArrayBuffer)(value)) {
                  params[key] = new Uint8Array(value);
                } else {
                  throw new Error("Invalid PDF binary data: either typed array, " + "string, or array-like object is expected in the data property.");
                }

                continue;
            }

            params[key] = value;
          }

          params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;
          params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;
          params.StandardFontDataFactory = params.StandardFontDataFactory || DefaultStandardFontDataFactory;
          params.ignoreErrors = params.stopAtErrors !== true;
          params.fontExtraProperties = params.fontExtraProperties === true;
          params.pdfBug = params.pdfBug === true;
          params.enableXfa = params.enableXfa === true;

          if (typeof params.docBaseUrl !== "string" || (0, _display_utils.isDataScheme)(params.docBaseUrl)) {
            params.docBaseUrl = null;
          }

          if (!Number.isInteger(params.maxImageSize)) {
            params.maxImageSize = -1;
          }

          if (typeof params.useWorkerFetch !== "boolean") {
            params.useWorkerFetch = params.CMapReaderFactory === _display_utils.DOMCMapReaderFactory && params.StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory;
          }

          if (typeof params.isEvalSupported !== "boolean") {
            params.isEvalSupported = true;
          }

          if (typeof params.disableFontFace !== "boolean") {
            params.disableFontFace = _is_node.isNodeJS;
          }

          if (typeof params.useSystemFonts !== "boolean") {
            params.useSystemFonts = !_is_node.isNodeJS && !params.disableFontFace;
          }

          if (typeof params.ownerDocument === "undefined") {
            params.ownerDocument = globalThis.document;
          }

          if (typeof params.disableRange !== "boolean") {
            params.disableRange = false;
          }

          if (typeof params.disableStream !== "boolean") {
            params.disableStream = false;
          }

          if (typeof params.disableAutoFetch !== "boolean") {
            params.disableAutoFetch = false;
          }

          (0, _util.setVerbosityLevel)(params.verbosity);

          if (!worker) {
            var workerParams = {
              verbosity: params.verbosity,
              port: _worker_options.GlobalWorkerOptions.workerPort
            };
            worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);
            task._worker = worker;
          }

          var docId = task.docId;
          worker.promise.then(function () {
            if (task.destroyed) {
              throw new Error("Loading aborted");
            }

            var workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);

            var networkStreamPromise = new Promise(function (resolve) {
              var networkStream;

              if (rangeTransport) {
                networkStream = new _transport_stream.PDFDataTransportStream({
                  length: params.length,
                  initialData: params.initialData,
                  progressiveDone: params.progressiveDone,
                  contentDispositionFilename: params.contentDispositionFilename,
                  disableRange: params.disableRange,
                  disableStream: params.disableStream
                }, rangeTransport);
              } else if (!params.data) {
                networkStream = createPDFNetworkStream({
                  url: params.url,
                  length: params.length,
                  httpHeaders: params.httpHeaders,
                  withCredentials: params.withCredentials,
                  rangeChunkSize: params.rangeChunkSize,
                  disableRange: params.disableRange,
                  disableStream: params.disableStream
                });
              }

              resolve(networkStream);
            });
            return Promise.all([workerIdPromise, networkStreamPromise]).then(function (_ref11) {
              var _ref12 = _slicedToArray(_ref11, 2),
                  workerId = _ref12[0],
                  networkStream = _ref12[1];

              if (task.destroyed) {
                throw new Error("Loading aborted");
              }

              var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);
              messageHandler.postMessageTransfers = worker.postMessageTransfers;
              var transport = new WorkerTransport(messageHandler, task, networkStream, params);
              task._transport = transport;
              messageHandler.send("Ready", null);
            });
          })["catch"](task._capability.reject);
          return task;
        }

        function _fetchDocument(_x4, _x5, _x6, _x7) {
          return _fetchDocument2.apply(this, arguments);
        }

        function _fetchDocument2() {
          _fetchDocument2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(worker, source, pdfDataRangeTransport, docId) {
            var workerId;
            return _regeneratorRuntime().wrap(function _callee9$(_context9) {
              while (1) {
                switch (_context9.prev = _context9.next) {
                  case 0:
                    if (!worker.destroyed) {
                      _context9.next = 2;
                      break;
                    }

                    throw new Error("Worker was destroyed");

                  case 2:
                    if (pdfDataRangeTransport) {
                      source.length = pdfDataRangeTransport.length;
                      source.initialData = pdfDataRangeTransport.initialData;
                      source.progressiveDone = pdfDataRangeTransport.progressiveDone;
                      source.contentDispositionFilename = pdfDataRangeTransport.contentDispositionFilename;
                    }

                    _context9.next = 5;
                    return worker.messageHandler.sendWithPromise("GetDocRequest", {
                      docId: docId,
                      apiVersion: '2.11.338',
                      source: {
                        data: source.data,
                        url: source.url,
                        password: source.password,
                        disableAutoFetch: source.disableAutoFetch,
                        rangeChunkSize: source.rangeChunkSize,
                        length: source.length
                      },
                      maxImageSize: source.maxImageSize,
                      disableFontFace: source.disableFontFace,
                      postMessageTransfers: worker.postMessageTransfers,
                      docBaseUrl: source.docBaseUrl,
                      ignoreErrors: source.ignoreErrors,
                      isEvalSupported: source.isEvalSupported,
                      fontExtraProperties: source.fontExtraProperties,
                      enableXfa: source.enableXfa,
                      useSystemFonts: source.useSystemFonts,
                      cMapUrl: source.useWorkerFetch ? source.cMapUrl : null,
                      standardFontDataUrl: source.useWorkerFetch ? source.standardFontDataUrl : null
                    });

                  case 5:
                    workerId = _context9.sent;

                    if (!worker.destroyed) {
                      _context9.next = 8;
                      break;
                    }

                    throw new Error("Worker was destroyed");

                  case 8:
                    return _context9.abrupt("return", workerId);

                  case 9:
                  case "end":
                    return _context9.stop();
                }
              }
            }, _callee9);
          }));
          return _fetchDocument2.apply(this, arguments);
        }

        var PDFDocumentLoadingTask = /*#__PURE__*/function () {
          function PDFDocumentLoadingTask() {
            _classCallCheck(this, PDFDocumentLoadingTask);

            this._capability = (0, _util.createPromiseCapability)();
            this._transport = null;
            this._worker = null;
            this.docId = "d".concat(PDFDocumentLoadingTask.idCounters.doc++);
            this.destroyed = false;
            this.onPassword = null;
            this.onProgress = null;
            this.onUnsupportedFeature = null;
          }

          _createClass(PDFDocumentLoadingTask, [{
            key: "promise",
            get: function get() {
              return this._capability.promise;
            }
          }, {
            key: "destroy",
            value: function () {
              var _destroy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
                var _this$_transport;

                return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        this.destroyed = true;
                        _context4.next = 3;
                        return (_this$_transport = this._transport) === null || _this$_transport === void 0 ? void 0 : _this$_transport.destroy();

                      case 3:
                        this._transport = null;

                        if (this._worker) {
                          this._worker.destroy();

                          this._worker = null;
                        }

                      case 5:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4, this);
              }));

              function destroy() {
                return _destroy.apply(this, arguments);
              }

              return destroy;
            }()
          }], [{
            key: "idCounters",
            get: function get() {
              return (0, _util.shadow)(this, "idCounters", {
                doc: 0
              });
            }
          }]);

          return PDFDocumentLoadingTask;
        }();

        exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;

        var PDFDataRangeTransport = /*#__PURE__*/function () {
          function PDFDataRangeTransport(length, initialData) {
            var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

            _classCallCheck(this, PDFDataRangeTransport);

            this.length = length;
            this.initialData = initialData;
            this.progressiveDone = progressiveDone;
            this.contentDispositionFilename = contentDispositionFilename;
            this._rangeListeners = [];
            this._progressListeners = [];
            this._progressiveReadListeners = [];
            this._progressiveDoneListeners = [];
            this._readyCapability = (0, _util.createPromiseCapability)();
          }

          _createClass(PDFDataRangeTransport, [{
            key: "addRangeListener",
            value: function addRangeListener(listener) {
              this._rangeListeners.push(listener);
            }
          }, {
            key: "addProgressListener",
            value: function addProgressListener(listener) {
              this._progressListeners.push(listener);
            }
          }, {
            key: "addProgressiveReadListener",
            value: function addProgressiveReadListener(listener) {
              this._progressiveReadListeners.push(listener);
            }
          }, {
            key: "addProgressiveDoneListener",
            value: function addProgressiveDoneListener(listener) {
              this._progressiveDoneListeners.push(listener);
            }
          }, {
            key: "onDataRange",
            value: function onDataRange(begin, chunk) {
              var _iterator4 = _createForOfIteratorHelper(this._rangeListeners),
                  _step4;

              try {
                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                  var listener = _step4.value;
                  listener(begin, chunk);
                }
              } catch (err) {
                _iterator4.e(err);
              } finally {
                _iterator4.f();
              }
            }
          }, {
            key: "onDataProgress",
            value: function onDataProgress(loaded, total) {
              var _this7 = this;

              this._readyCapability.promise.then(function () {
                var _iterator5 = _createForOfIteratorHelper(_this7._progressListeners),
                    _step5;

                try {
                  for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                    var listener = _step5.value;
                    listener(loaded, total);
                  }
                } catch (err) {
                  _iterator5.e(err);
                } finally {
                  _iterator5.f();
                }
              });
            }
          }, {
            key: "onDataProgressiveRead",
            value: function onDataProgressiveRead(chunk) {
              var _this8 = this;

              this._readyCapability.promise.then(function () {
                var _iterator6 = _createForOfIteratorHelper(_this8._progressiveReadListeners),
                    _step6;

                try {
                  for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                    var listener = _step6.value;
                    listener(chunk);
                  }
                } catch (err) {
                  _iterator6.e(err);
                } finally {
                  _iterator6.f();
                }
              });
            }
          }, {
            key: "onDataProgressiveDone",
            value: function onDataProgressiveDone() {
              var _this9 = this;

              this._readyCapability.promise.then(function () {
                var _iterator7 = _createForOfIteratorHelper(_this9._progressiveDoneListeners),
                    _step7;

                try {
                  for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                    var listener = _step7.value;
                    listener();
                  }
                } catch (err) {
                  _iterator7.e(err);
                } finally {
                  _iterator7.f();
                }
              });
            }
          }, {
            key: "transportReady",
            value: function transportReady() {
              this._readyCapability.resolve();
            }
          }, {
            key: "requestDataRange",
            value: function requestDataRange(begin, end) {
              (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
            }
          }, {
            key: "abort",
            value: function abort() {}
          }]);

          return PDFDataRangeTransport;
        }();

        exports.PDFDataRangeTransport = PDFDataRangeTransport;

        var PDFDocumentProxy = /*#__PURE__*/function () {
          function PDFDocumentProxy(pdfInfo, transport) {
            _classCallCheck(this, PDFDocumentProxy);

            this._pdfInfo = pdfInfo;
            this._transport = transport;
            Object.defineProperty(this, "fingerprint", {
              get: function get() {
                (0, _display_utils.deprecated)("`PDFDocumentProxy.fingerprint`, " + "please use `PDFDocumentProxy.fingerprints` instead.");
                return this.fingerprints[0];
              }
            });
          }

          _createClass(PDFDocumentProxy, [{
            key: "annotationStorage",
            get: function get() {
              return this._transport.annotationStorage;
            }
          }, {
            key: "numPages",
            get: function get() {
              return this._pdfInfo.numPages;
            }
          }, {
            key: "fingerprints",
            get: function get() {
              return this._pdfInfo.fingerprints;
            }
          }, {
            key: "isPureXfa",
            get: function get() {
              return !!this._transport._htmlForXfa;
            }
          }, {
            key: "allXfaHtml",
            get: function get() {
              return this._transport._htmlForXfa;
            }
          }, {
            key: "getPage",
            value: function getPage(pageNumber) {
              return this._transport.getPage(pageNumber);
            }
          }, {
            key: "getPageIndex",
            value: function getPageIndex(ref) {
              return this._transport.getPageIndex(ref);
            }
          }, {
            key: "getDestinations",
            value: function getDestinations() {
              return this._transport.getDestinations();
            }
          }, {
            key: "getDestination",
            value: function getDestination(id) {
              return this._transport.getDestination(id);
            }
          }, {
            key: "getPageLabels",
            value: function getPageLabels() {
              return this._transport.getPageLabels();
            }
          }, {
            key: "getPageLayout",
            value: function getPageLayout() {
              return this._transport.getPageLayout();
            }
          }, {
            key: "getPageMode",
            value: function getPageMode() {
              return this._transport.getPageMode();
            }
          }, {
            key: "getViewerPreferences",
            value: function getViewerPreferences() {
              return this._transport.getViewerPreferences();
            }
          }, {
            key: "getOpenAction",
            value: function getOpenAction() {
              return this._transport.getOpenAction();
            }
          }, {
            key: "getAttachments",
            value: function getAttachments() {
              return this._transport.getAttachments();
            }
          }, {
            key: "getJavaScript",
            value: function getJavaScript() {
              return this._transport.getJavaScript();
            }
          }, {
            key: "getJSActions",
            value: function getJSActions() {
              return this._transport.getDocJSActions();
            }
          }, {
            key: "getOutline",
            value: function getOutline() {
              return this._transport.getOutline();
            }
          }, {
            key: "getOptionalContentConfig",
            value: function getOptionalContentConfig() {
              return this._transport.getOptionalContentConfig();
            }
          }, {
            key: "getPermissions",
            value: function getPermissions() {
              return this._transport.getPermissions();
            }
          }, {
            key: "getMetadata",
            value: function getMetadata() {
              return this._transport.getMetadata();
            }
          }, {
            key: "getMarkInfo",
            value: function getMarkInfo() {
              return this._transport.getMarkInfo();
            }
          }, {
            key: "getData",
            value: function getData() {
              return this._transport.getData();
            }
          }, {
            key: "getDownloadInfo",
            value: function getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise;
            }
          }, {
            key: "getStats",
            value: function getStats() {
              return this._transport.getStats();
            }
          }, {
            key: "cleanup",
            value: function cleanup() {
              var keepLoadedFonts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
            }
          }, {
            key: "destroy",
            value: function destroy() {
              return this.loadingTask.destroy();
            }
          }, {
            key: "loadingParams",
            get: function get() {
              return this._transport.loadingParams;
            }
          }, {
            key: "loadingTask",
            get: function get() {
              return this._transport.loadingTask;
            }
          }, {
            key: "saveDocument",
            value: function saveDocument() {
              if (this._transport.annotationStorage.size <= 0) {
                (0, _display_utils.deprecated)("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
              }

              return this._transport.saveDocument();
            }
          }, {
            key: "getFieldObjects",
            value: function getFieldObjects() {
              return this._transport.getFieldObjects();
            }
          }, {
            key: "hasJSActions",
            value: function hasJSActions() {
              return this._transport.hasJSActions();
            }
          }, {
            key: "getCalculationOrderIds",
            value: function getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds();
            }
          }]);

          return PDFDocumentProxy;
        }();

        exports.PDFDocumentProxy = PDFDocumentProxy;

        var PDFPageProxy = /*#__PURE__*/function () {
          function PDFPageProxy(pageIndex, pageInfo, transport, ownerDocument) {
            var pdfBug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

            _classCallCheck(this, PDFPageProxy);

            this._pageIndex = pageIndex;
            this._pageInfo = pageInfo;
            this._ownerDocument = ownerDocument;
            this._transport = transport;
            this._stats = pdfBug ? new _display_utils.StatTimer() : null;
            this._pdfBug = pdfBug;
            this.commonObjs = transport.commonObjs;
            this.objs = new PDFObjects();
            this.cleanupAfterRender = false;
            this.pendingCleanup = false;
            this._intentStates = new Map();
            this._annotationPromises = new Map();
            this.destroyed = false;
          }

          _createClass(PDFPageProxy, [{
            key: "pageNumber",
            get: function get() {
              return this._pageIndex + 1;
            }
          }, {
            key: "rotate",
            get: function get() {
              return this._pageInfo.rotate;
            }
          }, {
            key: "ref",
            get: function get() {
              return this._pageInfo.ref;
            }
          }, {
            key: "userUnit",
            get: function get() {
              return this._pageInfo.userUnit;
            }
          }, {
            key: "view",
            get: function get() {
              return this._pageInfo.view;
            }
          }, {
            key: "getViewport",
            value: function getViewport() {
              var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  scale = _ref13.scale,
                  _ref13$rotation = _ref13.rotation,
                  rotation = _ref13$rotation === void 0 ? this.rotate : _ref13$rotation,
                  _ref13$offsetX = _ref13.offsetX,
                  offsetX = _ref13$offsetX === void 0 ? 0 : _ref13$offsetX,
                  _ref13$offsetY = _ref13.offsetY,
                  offsetY = _ref13$offsetY === void 0 ? 0 : _ref13$offsetY,
                  _ref13$dontFlip = _ref13.dontFlip,
                  dontFlip = _ref13$dontFlip === void 0 ? false : _ref13$dontFlip;

              return new _display_utils.PageViewport({
                viewBox: this.view,
                scale: scale,
                rotation: rotation,
                offsetX: offsetX,
                offsetY: offsetY,
                dontFlip: dontFlip
              });
            }
          }, {
            key: "getAnnotations",
            value: function getAnnotations() {
              var _ref14 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  _ref14$intent = _ref14.intent,
                  intent = _ref14$intent === void 0 ? "display" : _ref14$intent;

              var intentArgs = this._transport.getRenderingIntent(intent);

              var promise = this._annotationPromises.get(intentArgs.cacheKey);

              if (!promise) {
                promise = this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);

                this._annotationPromises.set(intentArgs.cacheKey, promise);

                promise = promise.then(function (annotations) {
                  var _iterator8 = _createForOfIteratorHelper(annotations),
                      _step8;

                  try {
                    var _loop = function _loop() {
                      var annotation = _step8.value;

                      if (annotation.titleObj !== undefined) {
                        Object.defineProperty(annotation, "title", {
                          get: function get() {
                            (0, _display_utils.deprecated)("`title`-property on annotation, please use `titleObj` instead.");
                            return annotation.titleObj.str;
                          }
                        });
                      }

                      if (annotation.contentsObj !== undefined) {
                        Object.defineProperty(annotation, "contents", {
                          get: function get() {
                            (0, _display_utils.deprecated)("`contents`-property on annotation, please use `contentsObj` instead.");
                            return annotation.contentsObj.str;
                          }
                        });
                      }
                    };

                    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                      _loop();
                    }
                  } catch (err) {
                    _iterator8.e(err);
                  } finally {
                    _iterator8.f();
                  }

                  return annotations;
                });
              }

              return promise;
            }
          }, {
            key: "getJSActions",
            value: function getJSActions() {
              return this._jsActionsPromise || (this._jsActionsPromise = this._transport.getPageJSActions(this._pageIndex));
            }
          }, {
            key: "getXfa",
            value: function () {
              var _getXfa = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
                var _this$_transport$_htm;

                return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                  while (1) {
                    switch (_context5.prev = _context5.next) {
                      case 0:
                        return _context5.abrupt("return", ((_this$_transport$_htm = this._transport._htmlForXfa) === null || _this$_transport$_htm === void 0 ? void 0 : _this$_transport$_htm.children[this._pageIndex]) || null);

                      case 1:
                      case "end":
                        return _context5.stop();
                    }
                  }
                }, _callee5, this);
              }));

              function getXfa() {
                return _getXfa.apply(this, arguments);
              }

              return getXfa;
            }()
          }, {
            key: "render",
            value: function render(_ref15) {
              var _arguments$,
                  _arguments$2,
                  _this10 = this,
                  _intentState;

              var canvasContext = _ref15.canvasContext,
                  viewport = _ref15.viewport,
                  _ref15$intent = _ref15.intent,
                  intent = _ref15$intent === void 0 ? "display" : _ref15$intent,
                  _ref15$annotationMode = _ref15.annotationMode,
                  annotationMode = _ref15$annotationMode === void 0 ? _util.AnnotationMode.ENABLE : _ref15$annotationMode,
                  _ref15$transform = _ref15.transform,
                  transform = _ref15$transform === void 0 ? null : _ref15$transform,
                  _ref15$imageLayer = _ref15.imageLayer,
                  imageLayer = _ref15$imageLayer === void 0 ? null : _ref15$imageLayer,
                  _ref15$canvasFactory = _ref15.canvasFactory,
                  canvasFactory = _ref15$canvasFactory === void 0 ? null : _ref15$canvasFactory,
                  _ref15$background = _ref15.background,
                  background = _ref15$background === void 0 ? null : _ref15$background,
                  _ref15$optionalConten = _ref15.optionalContentConfigPromise,
                  optionalContentConfigPromise = _ref15$optionalConten === void 0 ? null : _ref15$optionalConten;

              if (((_arguments$ = arguments[0]) === null || _arguments$ === void 0 ? void 0 : _arguments$.renderInteractiveForms) !== undefined) {
                (0, _display_utils.deprecated)("render no longer accepts the `renderInteractiveForms`-option, " + "please use the `annotationMode`-option instead.");

                if (arguments[0].renderInteractiveForms === true && annotationMode === _util.AnnotationMode.ENABLE) {
                  annotationMode = _util.AnnotationMode.ENABLE_FORMS;
                }
              }

              if (((_arguments$2 = arguments[0]) === null || _arguments$2 === void 0 ? void 0 : _arguments$2.includeAnnotationStorage) !== undefined) {
                (0, _display_utils.deprecated)("render no longer accepts the `includeAnnotationStorage`-option, " + "please use the `annotationMode`-option instead.");

                if (arguments[0].includeAnnotationStorage === true && annotationMode === _util.AnnotationMode.ENABLE) {
                  annotationMode = _util.AnnotationMode.ENABLE_STORAGE;
                }
              }

              if (this._stats) {
                this._stats.time("Overall");
              }

              var intentArgs = this._transport.getRenderingIntent(intent, annotationMode);

              this.pendingCleanup = false;

              if (!optionalContentConfigPromise) {
                optionalContentConfigPromise = this._transport.getOptionalContentConfig();
              }

              var intentState = this._intentStates.get(intentArgs.cacheKey);

              if (!intentState) {
                intentState = Object.create(null);

                this._intentStates.set(intentArgs.cacheKey, intentState);
              }

              if (intentState.streamReaderCancelTimeout) {
                clearTimeout(intentState.streamReaderCancelTimeout);
                intentState.streamReaderCancelTimeout = null;
              }

              var canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({
                ownerDocument: this._ownerDocument
              });
              var intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);

              if (!intentState.displayReadyCapability) {
                intentState.displayReadyCapability = (0, _util.createPromiseCapability)();
                intentState.operatorList = {
                  fnArray: [],
                  argsArray: [],
                  lastChunk: false
                };

                if (this._stats) {
                  this._stats.time("Page Request");
                }

                this._pumpOperatorList(intentArgs);
              }

              var complete = function complete(error) {
                intentState.renderTasks["delete"](internalRenderTask);

                if (_this10.cleanupAfterRender || intentPrint) {
                  _this10.pendingCleanup = true;
                }

                _this10._tryCleanup();

                if (error) {
                  internalRenderTask.capability.reject(error);

                  _this10._abortOperatorList({
                    intentState: intentState,
                    reason: error instanceof Error ? error : new Error(error)
                  });
                } else {
                  internalRenderTask.capability.resolve();
                }

                if (_this10._stats) {
                  _this10._stats.timeEnd("Rendering");

                  _this10._stats.timeEnd("Overall");
                }
              };

              var internalRenderTask = new InternalRenderTask({
                callback: complete,
                params: {
                  canvasContext: canvasContext,
                  viewport: viewport,
                  transform: transform,
                  imageLayer: imageLayer,
                  background: background
                },
                objs: this.objs,
                commonObjs: this.commonObjs,
                operatorList: intentState.operatorList,
                pageIndex: this._pageIndex,
                canvasFactory: canvasFactoryInstance,
                useRequestAnimationFrame: !intentPrint,
                pdfBug: this._pdfBug
              });
              ((_intentState = intentState).renderTasks || (_intentState.renderTasks = new Set())).add(internalRenderTask);
              var renderTask = internalRenderTask.task;
              Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(function (_ref16) {
                var _ref17 = _slicedToArray(_ref16, 2),
                    transparency = _ref17[0],
                    optionalContentConfig = _ref17[1];

                if (_this10.pendingCleanup) {
                  complete();
                  return;
                }

                if (_this10._stats) {
                  _this10._stats.time("Rendering");
                }

                internalRenderTask.initializeGraphics({
                  transparency: transparency,
                  optionalContentConfig: optionalContentConfig
                });
                internalRenderTask.operatorListChanged();
              })["catch"](complete);
              return renderTask;
            }
          }, {
            key: "getOperatorList",
            value: function getOperatorList() {
              var _ref18 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  _ref18$intent = _ref18.intent,
                  intent = _ref18$intent === void 0 ? "display" : _ref18$intent,
                  _ref18$annotationMode = _ref18.annotationMode,
                  annotationMode = _ref18$annotationMode === void 0 ? _util.AnnotationMode.ENABLE : _ref18$annotationMode;

              function operatorListChanged() {
                if (intentState.operatorList.lastChunk) {
                  intentState.opListReadCapability.resolve(intentState.operatorList);
                  intentState.renderTasks["delete"](opListTask);
                }
              }

              var intentArgs = this._transport.getRenderingIntent(intent, annotationMode, true);

              var intentState = this._intentStates.get(intentArgs.cacheKey);

              if (!intentState) {
                intentState = Object.create(null);

                this._intentStates.set(intentArgs.cacheKey, intentState);
              }

              var opListTask;

              if (!intentState.opListReadCapability) {
                var _intentState2;

                opListTask = Object.create(null);
                opListTask.operatorListChanged = operatorListChanged;
                intentState.opListReadCapability = (0, _util.createPromiseCapability)();
                ((_intentState2 = intentState).renderTasks || (_intentState2.renderTasks = new Set())).add(opListTask);
                intentState.operatorList = {
                  fnArray: [],
                  argsArray: [],
                  lastChunk: false
                };

                if (this._stats) {
                  this._stats.time("Page Request");
                }

                this._pumpOperatorList(intentArgs);
              }

              return intentState.opListReadCapability.promise;
            }
          }, {
            key: "streamTextContent",
            value: function streamTextContent() {
              var _ref19 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  _ref19$normalizeWhite = _ref19.normalizeWhitespace,
                  normalizeWhitespace = _ref19$normalizeWhite === void 0 ? false : _ref19$normalizeWhite,
                  _ref19$disableCombine = _ref19.disableCombineTextItems,
                  disableCombineTextItems = _ref19$disableCombine === void 0 ? false : _ref19$disableCombine,
                  _ref19$includeMarkedC = _ref19.includeMarkedContent,
                  includeMarkedContent = _ref19$includeMarkedC === void 0 ? false : _ref19$includeMarkedC;

              var TEXT_CONTENT_CHUNK_SIZE = 100;
              return this._transport.messageHandler.sendWithStream("GetTextContent", {
                pageIndex: this._pageIndex,
                normalizeWhitespace: normalizeWhitespace === true,
                combineTextItems: disableCombineTextItems !== true,
                includeMarkedContent: includeMarkedContent === true
              }, {
                highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
                size: function size(textContent) {
                  return textContent.items.length;
                }
              });
            }
          }, {
            key: "getTextContent",
            value: function getTextContent() {
              var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

              if (this._transport._htmlForXfa) {
                return this.getXfa().then(function (xfa) {
                  return _xfa_text.XfaText.textContent(xfa);
                });
              }

              var readableStream = this.streamTextContent(params);
              return new Promise(function (resolve, reject) {
                function pump() {
                  reader.read().then(function (_ref20) {
                    var _textContent$items;

                    var value = _ref20.value,
                        done = _ref20.done;

                    if (done) {
                      resolve(textContent);
                      return;
                    }

                    Object.assign(textContent.styles, value.styles);

                    (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));

                    pump();
                  }, reject);
                }

                var reader = readableStream.getReader();
                var textContent = {
                  items: [],
                  styles: Object.create(null)
                };
                pump();
              });
            }
          }, {
            key: "getStructTree",
            value: function getStructTree() {
              return this._structTreePromise || (this._structTreePromise = this._transport.getStructTree(this._pageIndex));
            }
          }, {
            key: "_destroy",
            value: function _destroy() {
              this.destroyed = true;
              this._transport.pageCache[this._pageIndex] = null;
              var waitOn = [];

              var _iterator9 = _createForOfIteratorHelper(this._intentStates.values()),
                  _step9;

              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                  var intentState = _step9.value;

                  this._abortOperatorList({
                    intentState: intentState,
                    reason: new Error("Page was destroyed."),
                    force: true
                  });

                  if (intentState.opListReadCapability) {
                    continue;
                  }

                  var _iterator10 = _createForOfIteratorHelper(intentState.renderTasks),
                      _step10;

                  try {
                    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                      var internalRenderTask = _step10.value;
                      waitOn.push(internalRenderTask.completed);
                      internalRenderTask.cancel();
                    }
                  } catch (err) {
                    _iterator10.e(err);
                  } finally {
                    _iterator10.f();
                  }
                }
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }

              this.objs.clear();

              this._annotationPromises.clear();

              this._jsActionsPromise = null;
              this._structTreePromise = null;
              this.pendingCleanup = false;
              return Promise.all(waitOn);
            }
          }, {
            key: "cleanup",
            value: function cleanup() {
              var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              this.pendingCleanup = true;
              return this._tryCleanup(resetStats);
            }
          }, {
            key: "_tryCleanup",
            value: function _tryCleanup() {
              var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

              if (!this.pendingCleanup) {
                return false;
              }

              var _iterator11 = _createForOfIteratorHelper(this._intentStates.values()),
                  _step11;

              try {
                for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                  var _step11$value = _step11.value,
                      renderTasks = _step11$value.renderTasks,
                      operatorList = _step11$value.operatorList;

                  if (renderTasks.size > 0 || !operatorList.lastChunk) {
                    return false;
                  }
                }
              } catch (err) {
                _iterator11.e(err);
              } finally {
                _iterator11.f();
              }

              this._intentStates.clear();

              this.objs.clear();

              this._annotationPromises.clear();

              this._jsActionsPromise = null;
              this._structTreePromise = null;

              if (resetStats && this._stats) {
                this._stats = new _display_utils.StatTimer();
              }

              this.pendingCleanup = false;
              return true;
            }
          }, {
            key: "_startRenderPage",
            value: function _startRenderPage(transparency, cacheKey) {
              var intentState = this._intentStates.get(cacheKey);

              if (!intentState) {
                return;
              }

              if (this._stats) {
                this._stats.timeEnd("Page Request");
              }

              if (intentState.displayReadyCapability) {
                intentState.displayReadyCapability.resolve(transparency);
              }
            }
          }, {
            key: "_renderPageChunk",
            value: function _renderPageChunk(operatorListChunk, intentState) {
              for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {
                intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
                intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
              }

              intentState.operatorList.lastChunk = operatorListChunk.lastChunk;

              var _iterator12 = _createForOfIteratorHelper(intentState.renderTasks),
                  _step12;

              try {
                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                  var internalRenderTask = _step12.value;
                  internalRenderTask.operatorListChanged();
                }
              } catch (err) {
                _iterator12.e(err);
              } finally {
                _iterator12.f();
              }

              if (operatorListChunk.lastChunk) {
                this._tryCleanup();
              }
            }
          }, {
            key: "_pumpOperatorList",
            value: function _pumpOperatorList(_ref21) {
              var _this11 = this;

              var renderingIntent = _ref21.renderingIntent,
                  cacheKey = _ref21.cacheKey;

              var readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                pageIndex: this._pageIndex,
                intent: renderingIntent,
                cacheKey: cacheKey,
                annotationStorage: renderingIntent & _util.RenderingIntentFlag.ANNOTATIONS_STORAGE ? this._transport.annotationStorage.serializable : null
              });

              var reader = readableStream.getReader();

              var intentState = this._intentStates.get(cacheKey);

              intentState.streamReader = reader;

              var pump = function pump() {
                reader.read().then(function (_ref22) {
                  var value = _ref22.value,
                      done = _ref22.done;

                  if (done) {
                    intentState.streamReader = null;
                    return;
                  }

                  if (_this11._transport.destroyed) {
                    return;
                  }

                  _this11._renderPageChunk(value, intentState);

                  pump();
                }, function (reason) {
                  intentState.streamReader = null;

                  if (_this11._transport.destroyed) {
                    return;
                  }

                  if (intentState.operatorList) {
                    intentState.operatorList.lastChunk = true;

                    var _iterator13 = _createForOfIteratorHelper(intentState.renderTasks),
                        _step13;

                    try {
                      for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                        var internalRenderTask = _step13.value;
                        internalRenderTask.operatorListChanged();
                      }
                    } catch (err) {
                      _iterator13.e(err);
                    } finally {
                      _iterator13.f();
                    }

                    _this11._tryCleanup();
                  }

                  if (intentState.displayReadyCapability) {
                    intentState.displayReadyCapability.reject(reason);
                  } else if (intentState.opListReadCapability) {
                    intentState.opListReadCapability.reject(reason);
                  } else {
                    throw reason;
                  }
                });
              };

              pump();
            }
          }, {
            key: "_abortOperatorList",
            value: function _abortOperatorList(_ref23) {
              var _this12 = this;

              var intentState = _ref23.intentState,
                  reason = _ref23.reason,
                  _ref23$force = _ref23.force,
                  force = _ref23$force === void 0 ? false : _ref23$force;

              if (!intentState.streamReader) {
                return;
              }

              if (!force) {
                if (intentState.renderTasks.size > 0) {
                  return;
                }

                if (reason instanceof _display_utils.RenderingCancelledException) {
                  intentState.streamReaderCancelTimeout = setTimeout(function () {
                    _this12._abortOperatorList({
                      intentState: intentState,
                      reason: reason,
                      force: true
                    });

                    intentState.streamReaderCancelTimeout = null;
                  }, RENDERING_CANCELLED_TIMEOUT);
                  return;
                }
              }

              intentState.streamReader.cancel(new _util.AbortException(reason.message))["catch"](function () {});
              intentState.streamReader = null;

              if (this._transport.destroyed) {
                return;
              }

              var _iterator14 = _createForOfIteratorHelper(this._intentStates),
                  _step14;

              try {
                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                  var _step14$value = _slicedToArray(_step14.value, 2),
                      curCacheKey = _step14$value[0],
                      curIntentState = _step14$value[1];

                  if (curIntentState === intentState) {
                    this._intentStates["delete"](curCacheKey);

                    break;
                  }
                }
              } catch (err) {
                _iterator14.e(err);
              } finally {
                _iterator14.f();
              }

              this.cleanup();
            }
          }, {
            key: "stats",
            get: function get() {
              return this._stats;
            }
          }]);

          return PDFPageProxy;
        }();

        exports.PDFPageProxy = PDFPageProxy;

        var LoopbackPort = /*#__PURE__*/function () {
          function LoopbackPort() {
            _classCallCheck(this, LoopbackPort);

            this._listeners = [];
            this._deferred = Promise.resolve(undefined);
          }

          _createClass(LoopbackPort, [{
            key: "postMessage",
            value: function postMessage(obj, transfers) {
              var _this13 = this;

              function cloneValue(value) {
                if (typeof value === "function" || _typeof(value) === "symbol" || value instanceof URL) {
                  throw new Error("LoopbackPort.postMessage - cannot clone: ".concat(value === null || value === void 0 ? void 0 : value.toString()));
                }

                if (_typeof(value) !== "object" || value === null) {
                  return value;
                }

                if (cloned.has(value)) {
                  return cloned.get(value);
                }

                var buffer, result;

                if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {
                  if (transfers !== null && transfers !== void 0 && transfers.includes(buffer)) {
                    result = new value.constructor(buffer, value.byteOffset, value.byteLength);
                  } else {
                    result = new value.constructor(value);
                  }

                  cloned.set(value, result);
                  return result;
                }

                if (value instanceof Map) {
                  result = new Map();
                  cloned.set(value, result);

                  var _iterator15 = _createForOfIteratorHelper(value),
                      _step15;

                  try {
                    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                      var _step15$value = _slicedToArray(_step15.value, 2),
                          key = _step15$value[0],
                          val = _step15$value[1];

                      result.set(key, cloneValue(val));
                    }
                  } catch (err) {
                    _iterator15.e(err);
                  } finally {
                    _iterator15.f();
                  }

                  return result;
                }

                if (value instanceof Set) {
                  result = new Set();
                  cloned.set(value, result);

                  var _iterator16 = _createForOfIteratorHelper(value),
                      _step16;

                  try {
                    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                      var _val = _step16.value;
                      result.add(cloneValue(_val));
                    }
                  } catch (err) {
                    _iterator16.e(err);
                  } finally {
                    _iterator16.f();
                  }

                  return result;
                }

                result = Array.isArray(value) ? [] : Object.create(null);
                cloned.set(value, result);

                for (var i in value) {
                  var _value$hasOwnProperty;

                  var desc = void 0,
                      p = value;

                  while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {
                    p = Object.getPrototypeOf(p);
                  }

                  if (typeof desc.value === "undefined") {
                    continue;
                  }

                  if (typeof desc.value === "function" && !((_value$hasOwnProperty = value.hasOwnProperty) !== null && _value$hasOwnProperty !== void 0 && _value$hasOwnProperty.call(value, i))) {
                    continue;
                  }

                  result[i] = cloneValue(desc.value);
                }

                return result;
              }

              var cloned = new WeakMap();
              var event = {
                data: cloneValue(obj)
              };

              this._deferred.then(function () {
                var _iterator17 = _createForOfIteratorHelper(_this13._listeners),
                    _step17;

                try {
                  for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                    var listener = _step17.value;
                    listener.call(_this13, event);
                  }
                } catch (err) {
                  _iterator17.e(err);
                } finally {
                  _iterator17.f();
                }
              });
            }
          }, {
            key: "addEventListener",
            value: function addEventListener(name, listener) {
              this._listeners.push(listener);
            }
          }, {
            key: "removeEventListener",
            value: function removeEventListener(name, listener) {
              var i = this._listeners.indexOf(listener);

              this._listeners.splice(i, 1);
            }
          }, {
            key: "terminate",
            value: function terminate() {
              this._listeners.length = 0;
            }
          }]);

          return LoopbackPort;
        }();

        exports.LoopbackPort = LoopbackPort;
        var PDFWorkerUtil = {
          isWorkerDisabled: false,
          fallbackWorkerSrc: null,
          fakeWorkerId: 0
        };
        {
          if (_is_node.isNodeJS && "function" === "function") {
            PDFWorkerUtil.isWorkerDisabled = true;
            PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
          } else if ((typeof document === "undefined" ? "undefined" : _typeof(document)) === "object") {
            var _document, _document$currentScri;

            var pdfjsFilePath = (_document = document) === null || _document === void 0 ? void 0 : (_document$currentScri = _document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src;

            if (pdfjsFilePath) {
              PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2");
            }
          }

          PDFWorkerUtil.createCDNWrapper = function (url) {
            var wrapper = "importScripts(\"".concat(url, "\");");
            return URL.createObjectURL(new Blob([wrapper]));
          };
        }

        var PDFWorker = /*#__PURE__*/function () {
          function PDFWorker() {
            var _ref24 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                _ref24$name = _ref24.name,
                name = _ref24$name === void 0 ? null : _ref24$name,
                _ref24$port = _ref24.port,
                port = _ref24$port === void 0 ? null : _ref24$port,
                _ref24$verbosity = _ref24.verbosity,
                verbosity = _ref24$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref24$verbosity;

            _classCallCheck(this, PDFWorker);

            if (port && PDFWorker._workerPorts.has(port)) {
              throw new Error("Cannot use more than one PDFWorker per port.");
            }

            this.name = name;
            this.destroyed = false;
            this.postMessageTransfers = true;
            this.verbosity = verbosity;
            this._readyCapability = (0, _util.createPromiseCapability)();
            this._port = null;
            this._webWorker = null;
            this._messageHandler = null;

            if (port) {
              PDFWorker._workerPorts.set(port, this);

              this._initializeFromPort(port);

              return;
            }

            this._initialize();
          }

          _createClass(PDFWorker, [{
            key: "promise",
            get: function get() {
              return this._readyCapability.promise;
            }
          }, {
            key: "port",
            get: function get() {
              return this._port;
            }
          }, {
            key: "messageHandler",
            get: function get() {
              return this._messageHandler;
            }
          }, {
            key: "_initializeFromPort",
            value: function _initializeFromPort(port) {
              this._port = port;
              this._messageHandler = new _message_handler.MessageHandler("main", "worker", port);

              this._messageHandler.on("ready", function () {});

              this._readyCapability.resolve();
            }
          }, {
            key: "_initialize",
            value: function _initialize() {
              var _this14 = this;

              if (typeof Worker !== "undefined" && !PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {
                var workerSrc = PDFWorker.workerSrc;

                try {
                  if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {
                    workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);
                  }

                  var worker = new Worker(workerSrc);
                  var messageHandler = new _message_handler.MessageHandler("main", "worker", worker);

                  var terminateEarly = function terminateEarly() {
                    worker.removeEventListener("error", onWorkerError);
                    messageHandler.destroy();
                    worker.terminate();

                    if (_this14.destroyed) {
                      _this14._readyCapability.reject(new Error("Worker was destroyed"));
                    } else {
                      _this14._setupFakeWorker();
                    }
                  };

                  var onWorkerError = function onWorkerError() {
                    if (!_this14._webWorker) {
                      terminateEarly();
                    }
                  };

                  worker.addEventListener("error", onWorkerError);
                  messageHandler.on("test", function (data) {
                    worker.removeEventListener("error", onWorkerError);

                    if (_this14.destroyed) {
                      terminateEarly();
                      return;
                    }

                    if (data) {
                      _this14._messageHandler = messageHandler;
                      _this14._port = worker;
                      _this14._webWorker = worker;

                      if (!data.supportTransfers) {
                        _this14.postMessageTransfers = false;
                      }

                      _this14._readyCapability.resolve();

                      messageHandler.send("configure", {
                        verbosity: _this14.verbosity
                      });
                    } else {
                      _this14._setupFakeWorker();

                      messageHandler.destroy();
                      worker.terminate();
                    }
                  });
                  messageHandler.on("ready", function (data) {
                    worker.removeEventListener("error", onWorkerError);

                    if (_this14.destroyed) {
                      terminateEarly();
                      return;
                    }

                    try {
                      sendTest();
                    } catch (e) {
                      _this14._setupFakeWorker();
                    }
                  });

                  var sendTest = function sendTest() {
                    var testObj = new Uint8Array([_this14.postMessageTransfers ? 255 : 0]);

                    try {
                      messageHandler.send("test", testObj, [testObj.buffer]);
                    } catch (ex) {
                      (0, _util.warn)("Cannot use postMessage transfers.");
                      testObj[0] = 0;
                      messageHandler.send("test", testObj);
                    }
                  };

                  sendTest();
                  return;
                } catch (e) {
                  (0, _util.info)("The worker has been disabled.");
                }
              }

              this._setupFakeWorker();
            }
          }, {
            key: "_setupFakeWorker",
            value: function _setupFakeWorker() {
              var _this15 = this;

              if (!PDFWorkerUtil.isWorkerDisabled) {
                (0, _util.warn)("Setting up fake worker.");
                PDFWorkerUtil.isWorkerDisabled = true;
              }

              PDFWorker._setupFakeWorkerGlobal.then(function (WorkerMessageHandler) {
                if (_this15.destroyed) {
                  _this15._readyCapability.reject(new Error("Worker was destroyed"));

                  return;
                }

                var port = new LoopbackPort();
                _this15._port = port;
                var id = "fake".concat(PDFWorkerUtil.fakeWorkerId++);
                var workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port);
                WorkerMessageHandler.setup(workerHandler, port);
                var messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port);
                _this15._messageHandler = messageHandler;

                _this15._readyCapability.resolve();

                messageHandler.send("configure", {
                  verbosity: _this15.verbosity
                });
              })["catch"](function (reason) {
                _this15._readyCapability.reject(new Error("Setting up fake worker failed: \"".concat(reason.message, "\".")));
              });
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.destroyed = true;

              if (this._webWorker) {
                this._webWorker.terminate();

                this._webWorker = null;
              }

              PDFWorker._workerPorts["delete"](this._port);

              this._port = null;

              if (this._messageHandler) {
                this._messageHandler.destroy();

                this._messageHandler = null;
              }
            }
          }], [{
            key: "_workerPorts",
            get: function get() {
              return (0, _util.shadow)(this, "_workerPorts", new WeakMap());
            }
          }, {
            key: "fromPort",
            value: function fromPort(params) {
              if (!(params !== null && params !== void 0 && params.port)) {
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              }

              if (this._workerPorts.has(params.port)) {
                return this._workerPorts.get(params.port);
              }

              return new PDFWorker(params);
            }
          }, {
            key: "workerSrc",
            get: function get() {
              if (_worker_options.GlobalWorkerOptions.workerSrc) {
                return _worker_options.GlobalWorkerOptions.workerSrc;
              }

              if (PDFWorkerUtil.fallbackWorkerSrc !== null) {
                if (!_is_node.isNodeJS) {
                  (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.');
                }

                return PDFWorkerUtil.fallbackWorkerSrc;
              }

              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }
          }, {
            key: "_mainThreadWorkerMessageHandler",
            get: function get() {
              try {
                var _globalThis$pdfjsWork;

                return ((_globalThis$pdfjsWork = globalThis.pdfjsWorker) === null || _globalThis$pdfjsWork === void 0 ? void 0 : _globalThis$pdfjsWork.WorkerMessageHandler) || null;
              } catch (ex) {
                return null;
              }
            }
          }, {
            key: "_setupFakeWorkerGlobal",
            get: function get() {
              var _this16 = this;

              var loader = /*#__PURE__*/function () {
                var _ref25 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
                  var mainWorkerMessageHandler, worker;
                  return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                    while (1) {
                      switch (_context6.prev = _context6.next) {
                        case 0:
                          mainWorkerMessageHandler = _this16._mainThreadWorkerMessageHandler;

                          if (!mainWorkerMessageHandler) {
                            _context6.next = 3;
                            break;
                          }

                          return _context6.abrupt("return", mainWorkerMessageHandler);

                        case 3:
                          if (!(_is_node.isNodeJS && "function" === "function")) {
                            _context6.next = 6;
                            break;
                          }

                          worker = eval("require")(_this16.workerSrc);
                          return _context6.abrupt("return", worker.WorkerMessageHandler);

                        case 6:
                          _context6.next = 8;
                          return (0, _display_utils.loadScript)(_this16.workerSrc);

                        case 8:
                          return _context6.abrupt("return", window.pdfjsWorker.WorkerMessageHandler);

                        case 9:
                        case "end":
                          return _context6.stop();
                      }
                    }
                  }, _callee6);
                }));

                return function loader() {
                  return _ref25.apply(this, arguments);
                };
              }();

              return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
            }
          }]);

          return PDFWorker;
        }();

        exports.PDFWorker = PDFWorker;
        {
          PDFWorker.getWorkerSrc = function () {
            (0, _display_utils.deprecated)("`PDFWorker.getWorkerSrc()`, please use `PDFWorker.workerSrc` instead.");
            return this.workerSrc;
          };
        }

        var WorkerTransport = /*#__PURE__*/function () {
          function WorkerTransport(messageHandler, loadingTask, networkStream, params) {
            _classCallCheck(this, WorkerTransport);

            this.messageHandler = messageHandler;
            this.loadingTask = loadingTask;
            this.commonObjs = new PDFObjects();
            this.fontLoader = new _font_loader.FontLoader({
              docId: loadingTask.docId,
              onUnsupportedFeature: this._onUnsupportedFeature.bind(this),
              ownerDocument: params.ownerDocument,
              styleElement: params.styleElement
            });
            this._params = params;

            if (!params.useWorkerFetch) {
              this.CMapReaderFactory = new params.CMapReaderFactory({
                baseUrl: params.cMapUrl,
                isCompressed: params.cMapPacked
              });
              this.StandardFontDataFactory = new params.StandardFontDataFactory({
                baseUrl: params.standardFontDataUrl
              });
            }

            this.destroyed = false;
            this.destroyCapability = null;
            this._passwordCapability = null;
            this._networkStream = networkStream;
            this._fullReader = null;
            this._lastProgress = null;
            this.pageCache = [];
            this.pagePromises = [];
            this.downloadInfoCapability = (0, _util.createPromiseCapability)();
            this.setupMessageHandler();
          }

          _createClass(WorkerTransport, [{
            key: "annotationStorage",
            get: function get() {
              return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
            }
          }, {
            key: "getRenderingIntent",
            value: function getRenderingIntent(intent) {
              var annotationMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _util.AnnotationMode.ENABLE;
              var isOpList = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
              var renderingIntent = _util.RenderingIntentFlag.DISPLAY;
              var lastModified = "";

              switch (intent) {
                case "any":
                  renderingIntent = _util.RenderingIntentFlag.ANY;
                  break;

                case "display":
                  break;

                case "print":
                  renderingIntent = _util.RenderingIntentFlag.PRINT;
                  break;

                default:
                  (0, _util.warn)("getRenderingIntent - invalid intent: ".concat(intent));
              }

              switch (annotationMode) {
                case _util.AnnotationMode.DISABLE:
                  renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                  break;

                case _util.AnnotationMode.ENABLE:
                  break;

                case _util.AnnotationMode.ENABLE_FORMS:
                  renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                  break;

                case _util.AnnotationMode.ENABLE_STORAGE:
                  renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;
                  lastModified = this.annotationStorage.lastModified;
                  break;

                default:
                  (0, _util.warn)("getRenderingIntent - invalid annotationMode: ".concat(annotationMode));
              }

              if (isOpList) {
                renderingIntent += _util.RenderingIntentFlag.OPLIST;
              }

              return {
                renderingIntent: renderingIntent,
                cacheKey: "".concat(renderingIntent, "_").concat(lastModified)
              };
            }
          }, {
            key: "destroy",
            value: function destroy() {
              var _this17 = this;

              if (this.destroyCapability) {
                return this.destroyCapability.promise;
              }

              this.destroyed = true;
              this.destroyCapability = (0, _util.createPromiseCapability)();

              if (this._passwordCapability) {
                this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback"));
              }

              var waitOn = [];

              var _iterator18 = _createForOfIteratorHelper(this.pageCache),
                  _step18;

              try {
                for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                  var page = _step18.value;

                  if (page) {
                    waitOn.push(page._destroy());
                  }
                }
              } catch (err) {
                _iterator18.e(err);
              } finally {
                _iterator18.f();
              }

              this.pageCache.length = 0;
              this.pagePromises.length = 0;

              if (this.hasOwnProperty("annotationStorage")) {
                this.annotationStorage.resetModified();
              }

              var terminated = this.messageHandler.sendWithPromise("Terminate", null);
              waitOn.push(terminated);
              Promise.all(waitOn).then(function () {
                _this17.commonObjs.clear();

                _this17.fontLoader.clear();

                _this17._getFieldObjectsPromise = null;
                _this17._hasJSActionsPromise = null;

                if (_this17._networkStream) {
                  _this17._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated."));
                }

                if (_this17.messageHandler) {
                  _this17.messageHandler.destroy();

                  _this17.messageHandler = null;
                }

                _this17.destroyCapability.resolve();
              }, this.destroyCapability.reject);
              return this.destroyCapability.promise;
            }
          }, {
            key: "setupMessageHandler",
            value: function setupMessageHandler() {
              var _this18 = this;

              var messageHandler = this.messageHandler,
                  loadingTask = this.loadingTask;
              messageHandler.on("GetReader", function (data, sink) {
                (0, _util.assert)(_this18._networkStream, "GetReader - no `IPDFStream` instance available.");
                _this18._fullReader = _this18._networkStream.getFullReader();

                _this18._fullReader.onProgress = function (evt) {
                  _this18._lastProgress = {
                    loaded: evt.loaded,
                    total: evt.total
                  };
                };

                sink.onPull = function () {
                  _this18._fullReader.read().then(function (_ref26) {
                    var value = _ref26.value,
                        done = _ref26.done;

                    if (done) {
                      sink.close();
                      return;
                    }

                    (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer.");
                    sink.enqueue(new Uint8Array(value), 1, [value]);
                  })["catch"](function (reason) {
                    sink.error(reason);
                  });
                };

                sink.onCancel = function (reason) {
                  _this18._fullReader.cancel(reason);

                  sink.ready["catch"](function (readyReason) {
                    if (_this18.destroyed) {
                      return;
                    }

                    throw readyReason;
                  });
                };
              });
              messageHandler.on("ReaderHeadersReady", function (data) {
                var headersCapability = (0, _util.createPromiseCapability)();
                var fullReader = _this18._fullReader;
                fullReader.headersReady.then(function () {
                  if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {
                    if (_this18._lastProgress && loadingTask.onProgress) {
                      loadingTask.onProgress(_this18._lastProgress);
                    }

                    fullReader.onProgress = function (evt) {
                      if (loadingTask.onProgress) {
                        loadingTask.onProgress({
                          loaded: evt.loaded,
                          total: evt.total
                        });
                      }
                    };
                  }

                  headersCapability.resolve({
                    isStreamingSupported: fullReader.isStreamingSupported,
                    isRangeSupported: fullReader.isRangeSupported,
                    contentLength: fullReader.contentLength
                  });
                }, headersCapability.reject);
                return headersCapability.promise;
              });
              messageHandler.on("GetRangeReader", function (data, sink) {
                (0, _util.assert)(_this18._networkStream, "GetRangeReader - no `IPDFStream` instance available.");

                var rangeReader = _this18._networkStream.getRangeReader(data.begin, data.end);

                if (!rangeReader) {
                  sink.close();
                  return;
                }

                sink.onPull = function () {
                  rangeReader.read().then(function (_ref27) {
                    var value = _ref27.value,
                        done = _ref27.done;

                    if (done) {
                      sink.close();
                      return;
                    }

                    (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer.");
                    sink.enqueue(new Uint8Array(value), 1, [value]);
                  })["catch"](function (reason) {
                    sink.error(reason);
                  });
                };

                sink.onCancel = function (reason) {
                  rangeReader.cancel(reason);
                  sink.ready["catch"](function (readyReason) {
                    if (_this18.destroyed) {
                      return;
                    }

                    throw readyReason;
                  });
                };
              });
              messageHandler.on("GetDoc", function (_ref28) {
                var pdfInfo = _ref28.pdfInfo;
                _this18._numPages = pdfInfo.numPages;
                _this18._htmlForXfa = pdfInfo.htmlForXfa;
                delete pdfInfo.htmlForXfa;

                loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this18));
              });
              messageHandler.on("DocException", function (ex) {
                var reason;

                switch (ex.name) {
                  case "PasswordException":
                    reason = new _util.PasswordException(ex.message, ex.code);
                    break;

                  case "InvalidPDFException":
                    reason = new _util.InvalidPDFException(ex.message);
                    break;

                  case "MissingPDFException":
                    reason = new _util.MissingPDFException(ex.message);
                    break;

                  case "UnexpectedResponseException":
                    reason = new _util.UnexpectedResponseException(ex.message, ex.status);
                    break;

                  case "UnknownErrorException":
                    reason = new _util.UnknownErrorException(ex.message, ex.details);
                    break;

                  default:
                    (0, _util.unreachable)("DocException - expected a valid Error.");
                }

                loadingTask._capability.reject(reason);
              });
              messageHandler.on("PasswordRequest", function (exception) {
                _this18._passwordCapability = (0, _util.createPromiseCapability)();

                if (loadingTask.onPassword) {
                  var updatePassword = function updatePassword(password) {
                    _this18._passwordCapability.resolve({
                      password: password
                    });
                  };

                  try {
                    loadingTask.onPassword(updatePassword, exception.code);
                  } catch (ex) {
                    _this18._passwordCapability.reject(ex);
                  }
                } else {
                  _this18._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));
                }

                return _this18._passwordCapability.promise;
              });
              messageHandler.on("DataLoaded", function (data) {
                if (loadingTask.onProgress) {
                  loadingTask.onProgress({
                    loaded: data.length,
                    total: data.length
                  });
                }

                _this18.downloadInfoCapability.resolve(data);
              });
              messageHandler.on("StartRenderPage", function (data) {
                if (_this18.destroyed) {
                  return;
                }

                var page = _this18.pageCache[data.pageIndex];

                page._startRenderPage(data.transparency, data.cacheKey);
              });
              messageHandler.on("commonobj", function (data) {
                var _globalThis$FontInspe;

                if (_this18.destroyed) {
                  return;
                }

                var _data = _slicedToArray(data, 3),
                    id = _data[0],
                    type = _data[1],
                    exportedData = _data[2];

                if (_this18.commonObjs.has(id)) {
                  return;
                }

                switch (type) {
                  case "Font":
                    var params = _this18._params;

                    if ("error" in exportedData) {
                      var exportedError = exportedData.error;
                      (0, _util.warn)("Error during font loading: ".concat(exportedError));

                      _this18.commonObjs.resolve(id, exportedError);

                      break;
                    }

                    var fontRegistry = null;

                    if (params.pdfBug && (_globalThis$FontInspe = globalThis.FontInspector) !== null && _globalThis$FontInspe !== void 0 && _globalThis$FontInspe.enabled) {
                      fontRegistry = {
                        registerFont: function registerFont(font, url) {
                          globalThis.FontInspector.fontAdded(font, url);
                        }
                      };
                    }

                    var font = new _font_loader.FontFaceObject(exportedData, {
                      isEvalSupported: params.isEvalSupported,
                      disableFontFace: params.disableFontFace,
                      ignoreErrors: params.ignoreErrors,
                      onUnsupportedFeature: _this18._onUnsupportedFeature.bind(_this18),
                      fontRegistry: fontRegistry
                    });

                    _this18.fontLoader.bind(font)["catch"](function (reason) {
                      return messageHandler.sendWithPromise("FontFallback", {
                        id: id
                      });
                    })["finally"](function () {
                      if (!params.fontExtraProperties && font.data) {
                        font.data = null;
                      }

                      _this18.commonObjs.resolve(id, font);
                    });

                    break;

                  case "FontPath":
                  case "Image":
                    _this18.commonObjs.resolve(id, exportedData);

                    break;

                  default:
                    throw new Error("Got unknown common object type ".concat(type));
                }
              });
              messageHandler.on("obj", function (data) {
                var _imageData$data;

                if (_this18.destroyed) {
                  return undefined;
                }

                var _data2 = _slicedToArray(data, 4),
                    id = _data2[0],
                    pageIndex = _data2[1],
                    type = _data2[2],
                    imageData = _data2[3];

                var pageProxy = _this18.pageCache[pageIndex];

                if (pageProxy.objs.has(id)) {
                  return undefined;
                }

                switch (type) {
                  case "Image":
                    pageProxy.objs.resolve(id, imageData);
                    var MAX_IMAGE_SIZE_TO_STORE = 8000000;

                    if ((imageData === null || imageData === void 0 ? void 0 : (_imageData$data = imageData.data) === null || _imageData$data === void 0 ? void 0 : _imageData$data.length) > MAX_IMAGE_SIZE_TO_STORE) {
                      pageProxy.cleanupAfterRender = true;
                    }

                    break;

                  case "Pattern":
                    pageProxy.objs.resolve(id, imageData);
                    break;

                  default:
                    throw new Error("Got unknown object type ".concat(type));
                }

                return undefined;
              });
              messageHandler.on("DocProgress", function (data) {
                if (_this18.destroyed) {
                  return;
                }

                if (loadingTask.onProgress) {
                  loadingTask.onProgress({
                    loaded: data.loaded,
                    total: data.total
                  });
                }
              });
              messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this));
              messageHandler.on("FetchBuiltInCMap", function (data) {
                if (_this18.destroyed) {
                  return Promise.reject(new Error("Worker was destroyed."));
                }

                if (!_this18.CMapReaderFactory) {
                  return Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."));
                }

                return _this18.CMapReaderFactory.fetch(data);
              });
              messageHandler.on("FetchStandardFontData", function (data) {
                if (_this18.destroyed) {
                  return Promise.reject(new Error("Worker was destroyed."));
                }

                if (!_this18.StandardFontDataFactory) {
                  return Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."));
                }

                return _this18.StandardFontDataFactory.fetch(data);
              });
            }
          }, {
            key: "_onUnsupportedFeature",
            value: function _onUnsupportedFeature(_ref29) {
              var featureId = _ref29.featureId;

              if (this.destroyed) {
                return;
              }

              if (this.loadingTask.onUnsupportedFeature) {
                this.loadingTask.onUnsupportedFeature(featureId);
              }
            }
          }, {
            key: "getData",
            value: function getData() {
              return this.messageHandler.sendWithPromise("GetData", null);
            }
          }, {
            key: "getPage",
            value: function getPage(pageNumber) {
              var _this19 = this;

              if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
                return Promise.reject(new Error("Invalid page request"));
              }

              var pageIndex = pageNumber - 1;

              if (pageIndex in this.pagePromises) {
                return this.pagePromises[pageIndex];
              }

              var promise = this.messageHandler.sendWithPromise("GetPage", {
                pageIndex: pageIndex
              }).then(function (pageInfo) {
                if (_this19.destroyed) {
                  throw new Error("Transport destroyed");
                }

                var page = new PDFPageProxy(pageIndex, pageInfo, _this19, _this19._params.ownerDocument, _this19._params.pdfBug);
                _this19.pageCache[pageIndex] = page;
                return page;
              });
              this.pagePromises[pageIndex] = promise;
              return promise;
            }
          }, {
            key: "getPageIndex",
            value: function getPageIndex(ref) {
              return this.messageHandler.sendWithPromise("GetPageIndex", {
                ref: ref
              });
            }
          }, {
            key: "getAnnotations",
            value: function getAnnotations(pageIndex, intent) {
              return this.messageHandler.sendWithPromise("GetAnnotations", {
                pageIndex: pageIndex,
                intent: intent
              });
            }
          }, {
            key: "saveDocument",
            value: function saveDocument() {
              var _this$_fullReader$fil,
                  _this$_fullReader,
                  _this20 = this;

              return this.messageHandler.sendWithPromise("SaveDocument", {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: this.annotationStorage.serializable,
                filename: (_this$_fullReader$fil = (_this$_fullReader = this._fullReader) === null || _this$_fullReader === void 0 ? void 0 : _this$_fullReader.filename) !== null && _this$_fullReader$fil !== void 0 ? _this$_fullReader$fil : null
              })["finally"](function () {
                _this20.annotationStorage.resetModified();
              });
            }
          }, {
            key: "getFieldObjects",
            value: function getFieldObjects() {
              return this._getFieldObjectsPromise || (this._getFieldObjectsPromise = this.messageHandler.sendWithPromise("GetFieldObjects", null));
            }
          }, {
            key: "hasJSActions",
            value: function hasJSActions() {
              return this._hasJSActionsPromise || (this._hasJSActionsPromise = this.messageHandler.sendWithPromise("HasJSActions", null));
            }
          }, {
            key: "getCalculationOrderIds",
            value: function getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
            }
          }, {
            key: "getDestinations",
            value: function getDestinations() {
              return this.messageHandler.sendWithPromise("GetDestinations", null);
            }
          }, {
            key: "getDestination",
            value: function getDestination(id) {
              if (typeof id !== "string") {
                return Promise.reject(new Error("Invalid destination request."));
              }

              return this.messageHandler.sendWithPromise("GetDestination", {
                id: id
              });
            }
          }, {
            key: "getPageLabels",
            value: function getPageLabels() {
              return this.messageHandler.sendWithPromise("GetPageLabels", null);
            }
          }, {
            key: "getPageLayout",
            value: function getPageLayout() {
              return this.messageHandler.sendWithPromise("GetPageLayout", null);
            }
          }, {
            key: "getPageMode",
            value: function getPageMode() {
              return this.messageHandler.sendWithPromise("GetPageMode", null);
            }
          }, {
            key: "getViewerPreferences",
            value: function getViewerPreferences() {
              return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
            }
          }, {
            key: "getOpenAction",
            value: function getOpenAction() {
              return this.messageHandler.sendWithPromise("GetOpenAction", null);
            }
          }, {
            key: "getAttachments",
            value: function getAttachments() {
              return this.messageHandler.sendWithPromise("GetAttachments", null);
            }
          }, {
            key: "getJavaScript",
            value: function getJavaScript() {
              return this.messageHandler.sendWithPromise("GetJavaScript", null);
            }
          }, {
            key: "getDocJSActions",
            value: function getDocJSActions() {
              return this.messageHandler.sendWithPromise("GetDocJSActions", null);
            }
          }, {
            key: "getPageJSActions",
            value: function getPageJSActions(pageIndex) {
              return this.messageHandler.sendWithPromise("GetPageJSActions", {
                pageIndex: pageIndex
              });
            }
          }, {
            key: "getStructTree",
            value: function getStructTree(pageIndex) {
              return this.messageHandler.sendWithPromise("GetStructTree", {
                pageIndex: pageIndex
              });
            }
          }, {
            key: "getOutline",
            value: function getOutline() {
              return this.messageHandler.sendWithPromise("GetOutline", null);
            }
          }, {
            key: "getOptionalContentConfig",
            value: function getOptionalContentConfig() {
              return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(function (results) {
                return new _optional_content_config.OptionalContentConfig(results);
              });
            }
          }, {
            key: "getPermissions",
            value: function getPermissions() {
              return this.messageHandler.sendWithPromise("GetPermissions", null);
            }
          }, {
            key: "getMetadata",
            value: function getMetadata() {
              var _this21 = this;

              return this.messageHandler.sendWithPromise("GetMetadata", null).then(function (results) {
                var _this21$_fullReader$f, _this21$_fullReader, _this21$_fullReader$c, _this21$_fullReader2;

                return {
                  info: results[0],
                  metadata: results[1] ? new _metadata.Metadata(results[1]) : null,
                  contentDispositionFilename: (_this21$_fullReader$f = (_this21$_fullReader = _this21._fullReader) === null || _this21$_fullReader === void 0 ? void 0 : _this21$_fullReader.filename) !== null && _this21$_fullReader$f !== void 0 ? _this21$_fullReader$f : null,
                  contentLength: (_this21$_fullReader$c = (_this21$_fullReader2 = _this21._fullReader) === null || _this21$_fullReader2 === void 0 ? void 0 : _this21$_fullReader2.contentLength) !== null && _this21$_fullReader$c !== void 0 ? _this21$_fullReader$c : null
                };
              });
            }
          }, {
            key: "getMarkInfo",
            value: function getMarkInfo() {
              return this.messageHandler.sendWithPromise("GetMarkInfo", null);
            }
          }, {
            key: "getStats",
            value: function getStats() {
              return this.messageHandler.sendWithPromise("GetStats", null);
            }
          }, {
            key: "startCleanup",
            value: function () {
              var _startCleanup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
                var keepLoadedFonts,
                    i,
                    ii,
                    page,
                    cleanupSuccessful,
                    _args7 = arguments;
                return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                        keepLoadedFonts = _args7.length > 0 && _args7[0] !== undefined ? _args7[0] : false;
                        _context7.next = 3;
                        return this.messageHandler.sendWithPromise("Cleanup", null);

                      case 3:
                        if (!this.destroyed) {
                          _context7.next = 5;
                          break;
                        }

                        return _context7.abrupt("return");

                      case 5:
                        i = 0, ii = this.pageCache.length;

                      case 6:
                        if (!(i < ii)) {
                          _context7.next = 16;
                          break;
                        }

                        page = this.pageCache[i];

                        if (page) {
                          _context7.next = 10;
                          break;
                        }

                        return _context7.abrupt("continue", 13);

                      case 10:
                        cleanupSuccessful = page.cleanup();

                        if (cleanupSuccessful) {
                          _context7.next = 13;
                          break;
                        }

                        throw new Error("startCleanup: Page ".concat(i + 1, " is currently rendering."));

                      case 13:
                        i++;
                        _context7.next = 6;
                        break;

                      case 16:
                        this.commonObjs.clear();

                        if (!keepLoadedFonts) {
                          this.fontLoader.clear();
                        }

                        this._getFieldObjectsPromise = null;
                        this._hasJSActionsPromise = null;

                      case 20:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7, this);
              }));

              function startCleanup() {
                return _startCleanup.apply(this, arguments);
              }

              return startCleanup;
            }()
          }, {
            key: "loadingParams",
            get: function get() {
              var params = this._params;
              return (0, _util.shadow)(this, "loadingParams", {
                disableAutoFetch: params.disableAutoFetch,
                enableXfa: params.enableXfa
              });
            }
          }]);

          return WorkerTransport;
        }();

        var PDFObjects = /*#__PURE__*/function () {
          function PDFObjects() {
            _classCallCheck(this, PDFObjects);

            this._objs = Object.create(null);
          }

          _createClass(PDFObjects, [{
            key: "_ensureObj",
            value: function _ensureObj(objId) {
              if (this._objs[objId]) {
                return this._objs[objId];
              }

              return this._objs[objId] = {
                capability: (0, _util.createPromiseCapability)(),
                data: null,
                resolved: false
              };
            }
          }, {
            key: "get",
            value: function get(objId) {
              var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

              if (callback) {
                this._ensureObj(objId).capability.promise.then(callback);

                return null;
              }

              var obj = this._objs[objId];

              if (!obj || !obj.resolved) {
                throw new Error("Requesting object that isn't resolved yet ".concat(objId, "."));
              }

              return obj.data;
            }
          }, {
            key: "has",
            value: function has(objId) {
              var obj = this._objs[objId];
              return (obj === null || obj === void 0 ? void 0 : obj.resolved) || false;
            }
          }, {
            key: "resolve",
            value: function resolve(objId, data) {
              var obj = this._ensureObj(objId);

              obj.resolved = true;
              obj.data = data;
              obj.capability.resolve(data);
            }
          }, {
            key: "clear",
            value: function clear() {
              this._objs = Object.create(null);
            }
          }]);

          return PDFObjects;
        }();

        var RenderTask = /*#__PURE__*/function () {
          function RenderTask(internalRenderTask) {
            _classCallCheck(this, RenderTask);

            this._internalRenderTask = internalRenderTask;
            this.onContinue = null;
          }

          _createClass(RenderTask, [{
            key: "promise",
            get: function get() {
              return this._internalRenderTask.capability.promise;
            }
          }, {
            key: "cancel",
            value: function cancel() {
              this._internalRenderTask.cancel();
            }
          }]);

          return RenderTask;
        }();

        exports.RenderTask = RenderTask;

        var InternalRenderTask = /*#__PURE__*/function () {
          function InternalRenderTask(_ref30) {
            var callback = _ref30.callback,
                params = _ref30.params,
                objs = _ref30.objs,
                commonObjs = _ref30.commonObjs,
                operatorList = _ref30.operatorList,
                pageIndex = _ref30.pageIndex,
                canvasFactory = _ref30.canvasFactory,
                _ref30$useRequestAnim = _ref30.useRequestAnimationFrame,
                useRequestAnimationFrame = _ref30$useRequestAnim === void 0 ? false : _ref30$useRequestAnim,
                _ref30$pdfBug = _ref30.pdfBug,
                pdfBug = _ref30$pdfBug === void 0 ? false : _ref30$pdfBug;

            _classCallCheck(this, InternalRenderTask);

            this.callback = callback;
            this.params = params;
            this.objs = objs;
            this.commonObjs = commonObjs;
            this.operatorListIdx = null;
            this.operatorList = operatorList;
            this._pageIndex = pageIndex;
            this.canvasFactory = canvasFactory;
            this._pdfBug = pdfBug;
            this.running = false;
            this.graphicsReadyCallback = null;
            this.graphicsReady = false;
            this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
            this.cancelled = false;
            this.capability = (0, _util.createPromiseCapability)();
            this.task = new RenderTask(this);
            this._cancelBound = this.cancel.bind(this);
            this._continueBound = this._continue.bind(this);
            this._scheduleNextBound = this._scheduleNext.bind(this);
            this._nextBound = this._next.bind(this);
            this._canvas = params.canvasContext.canvas;
          }

          _createClass(InternalRenderTask, [{
            key: "completed",
            get: function get() {
              return this.capability.promise["catch"](function () {});
            }
          }, {
            key: "initializeGraphics",
            value: function initializeGraphics(_ref31) {
              var _globalThis$StepperMa;

              var _ref31$transparency = _ref31.transparency,
                  transparency = _ref31$transparency === void 0 ? false : _ref31$transparency,
                  optionalContentConfig = _ref31.optionalContentConfig;

              if (this.cancelled) {
                return;
              }

              if (this._canvas) {
                if (InternalRenderTask.canvasInUse.has(this._canvas)) {
                  throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
                }

                InternalRenderTask.canvasInUse.add(this._canvas);
              }

              if (this._pdfBug && (_globalThis$StepperMa = globalThis.StepperManager) !== null && _globalThis$StepperMa !== void 0 && _globalThis$StepperMa.enabled) {
                this.stepper = globalThis.StepperManager.create(this._pageIndex);
                this.stepper.init(this.operatorList);
                this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
              }

              var _this$params = this.params,
                  canvasContext = _this$params.canvasContext,
                  viewport = _this$params.viewport,
                  transform = _this$params.transform,
                  imageLayer = _this$params.imageLayer,
                  background = _this$params.background;
              this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, imageLayer, optionalContentConfig);
              this.gfx.beginDrawing({
                transform: transform,
                viewport: viewport,
                transparency: transparency,
                background: background
              });
              this.operatorListIdx = 0;
              this.graphicsReady = true;

              if (this.graphicsReadyCallback) {
                this.graphicsReadyCallback();
              }
            }
          }, {
            key: "cancel",
            value: function cancel() {
              var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
              this.running = false;
              this.cancelled = true;

              if (this.gfx) {
                this.gfx.endDrawing();
              }

              if (this._canvas) {
                InternalRenderTask.canvasInUse["delete"](this._canvas);
              }

              this.callback(error || new _display_utils.RenderingCancelledException("Rendering cancelled, page ".concat(this._pageIndex + 1), "canvas"));
            }
          }, {
            key: "operatorListChanged",
            value: function operatorListChanged() {
              if (!this.graphicsReady) {
                if (!this.graphicsReadyCallback) {
                  this.graphicsReadyCallback = this._continueBound;
                }

                return;
              }

              if (this.stepper) {
                this.stepper.updateOperatorList(this.operatorList);
              }

              if (this.running) {
                return;
              }

              this._continue();
            }
          }, {
            key: "_continue",
            value: function _continue() {
              this.running = true;

              if (this.cancelled) {
                return;
              }

              if (this.task.onContinue) {
                this.task.onContinue(this._scheduleNextBound);
              } else {
                this._scheduleNext();
              }
            }
          }, {
            key: "_scheduleNext",
            value: function _scheduleNext() {
              var _this22 = this;

              if (this._useRequestAnimationFrame) {
                window.requestAnimationFrame(function () {
                  _this22._nextBound()["catch"](_this22._cancelBound);
                });
              } else {
                Promise.resolve().then(this._nextBound)["catch"](this._cancelBound);
              }
            }
          }, {
            key: "_next",
            value: function () {
              var _next2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
                return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                  while (1) {
                    switch (_context8.prev = _context8.next) {
                      case 0:
                        if (!this.cancelled) {
                          _context8.next = 2;
                          break;
                        }

                        return _context8.abrupt("return");

                      case 2:
                        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);

                        if (this.operatorListIdx === this.operatorList.argsArray.length) {
                          this.running = false;

                          if (this.operatorList.lastChunk) {
                            this.gfx.endDrawing();

                            if (this._canvas) {
                              InternalRenderTask.canvasInUse["delete"](this._canvas);
                            }

                            this.callback();
                          }
                        }

                      case 4:
                      case "end":
                        return _context8.stop();
                    }
                  }
                }, _callee8, this);
              }));

              function _next() {
                return _next2.apply(this, arguments);
              }

              return _next;
            }()
          }], [{
            key: "canvasInUse",
            get: function get() {
              return (0, _util.shadow)(this, "canvasInUse", new WeakSet());
            }
          }]);

          return InternalRenderTask;
        }();

        var version = '2.11.338';
        exports.version = version;
        var build = 'dedff3c98';
        exports.build = build;
        /***/
      },
      /* 7 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.FontLoader = exports.FontFaceObject = void 0;

        var _util = __w_pdfjs_require__(2);

        var BaseFontLoader = /*#__PURE__*/function () {
          function BaseFontLoader(_ref32) {
            var docId = _ref32.docId,
                onUnsupportedFeature = _ref32.onUnsupportedFeature,
                _ref32$ownerDocument = _ref32.ownerDocument,
                ownerDocument = _ref32$ownerDocument === void 0 ? globalThis.document : _ref32$ownerDocument,
                _ref32$styleElement = _ref32.styleElement,
                styleElement = _ref32$styleElement === void 0 ? null : _ref32$styleElement;

            _classCallCheck(this, BaseFontLoader);

            if (this.constructor === BaseFontLoader) {
              (0, _util.unreachable)("Cannot initialize BaseFontLoader.");
            }

            this.docId = docId;
            this._onUnsupportedFeature = onUnsupportedFeature;
            this._document = ownerDocument;
            this.nativeFontFaces = [];
            this.styleElement = null;
          }

          _createClass(BaseFontLoader, [{
            key: "addNativeFontFace",
            value: function addNativeFontFace(nativeFontFace) {
              this.nativeFontFaces.push(nativeFontFace);

              this._document.fonts.add(nativeFontFace);
            }
          }, {
            key: "insertRule",
            value: function insertRule(rule) {
              var styleElement = this.styleElement;

              if (!styleElement) {
                styleElement = this.styleElement = this._document.createElement("style");
                styleElement.id = "PDFJS_FONT_STYLE_TAG_".concat(this.docId);

                this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement);
              }

              var styleSheet = styleElement.sheet;
              styleSheet.insertRule(rule, styleSheet.cssRules.length);
            }
          }, {
            key: "clear",
            value: function clear() {
              var _iterator19 = _createForOfIteratorHelper(this.nativeFontFaces),
                  _step19;

              try {
                for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
                  var nativeFontFace = _step19.value;

                  this._document.fonts["delete"](nativeFontFace);
                }
              } catch (err) {
                _iterator19.e(err);
              } finally {
                _iterator19.f();
              }

              this.nativeFontFaces.length = 0;

              if (this.styleElement) {
                this.styleElement.remove();
                this.styleElement = null;
              }
            }
          }, {
            key: "bind",
            value: function () {
              var _bind = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(font) {
                var _this23 = this;

                var nativeFontFace, rule;
                return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                  while (1) {
                    switch (_context10.prev = _context10.next) {
                      case 0:
                        if (!(font.attached || font.missingFile)) {
                          _context10.next = 2;
                          break;
                        }

                        return _context10.abrupt("return");

                      case 2:
                        font.attached = true;

                        if (!this.isFontLoadingAPISupported) {
                          _context10.next = 19;
                          break;
                        }

                        nativeFontFace = font.createNativeFontFace();

                        if (!nativeFontFace) {
                          _context10.next = 18;
                          break;
                        }

                        this.addNativeFontFace(nativeFontFace);
                        _context10.prev = 7;
                        _context10.next = 10;
                        return nativeFontFace.loaded;

                      case 10:
                        _context10.next = 18;
                        break;

                      case 12:
                        _context10.prev = 12;
                        _context10.t0 = _context10["catch"](7);

                        this._onUnsupportedFeature({
                          featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative
                        });

                        (0, _util.warn)("Failed to load font '".concat(nativeFontFace.family, "': '").concat(_context10.t0, "'."));
                        font.disableFontFace = true;
                        throw _context10.t0;

                      case 18:
                        return _context10.abrupt("return");

                      case 19:
                        rule = font.createFontFaceRule();

                        if (!rule) {
                          _context10.next = 26;
                          break;
                        }

                        this.insertRule(rule);

                        if (!this.isSyncFontLoadingSupported) {
                          _context10.next = 24;
                          break;
                        }

                        return _context10.abrupt("return");

                      case 24:
                        _context10.next = 26;
                        return new Promise(function (resolve) {
                          var request = _this23._queueLoadingCallback(resolve);

                          _this23._prepareFontLoadEvent([rule], [font], request);
                        });

                      case 26:
                      case "end":
                        return _context10.stop();
                    }
                  }
                }, _callee10, this, [[7, 12]]);
              }));

              function bind(_x8) {
                return _bind.apply(this, arguments);
              }

              return bind;
            }()
          }, {
            key: "_queueLoadingCallback",
            value: function _queueLoadingCallback(callback) {
              (0, _util.unreachable)("Abstract method `_queueLoadingCallback`.");
            }
          }, {
            key: "isFontLoadingAPISupported",
            get: function get() {
              var _this$_document;

              var hasFonts = !!((_this$_document = this._document) !== null && _this$_document !== void 0 && _this$_document.fonts);
              return (0, _util.shadow)(this, "isFontLoadingAPISupported", hasFonts);
            }
          }, {
            key: "isSyncFontLoadingSupported",
            get: function get() {
              (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`.");
            }
          }, {
            key: "_loadTestFont",
            get: function get() {
              (0, _util.unreachable)("Abstract method `_loadTestFont`.");
            }
          }, {
            key: "_prepareFontLoadEvent",
            value: function _prepareFontLoadEvent(rules, fontsToLoad, request) {
              (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`.");
            }
          }]);

          return BaseFontLoader;
        }();

        var FontLoader;
        exports.FontLoader = FontLoader;
        {
          exports.FontLoader = FontLoader = /*#__PURE__*/function (_BaseFontLoader) {
            _inherits(GenericFontLoader, _BaseFontLoader);

            var _super13 = _createSuper(GenericFontLoader);

            function GenericFontLoader(params) {
              var _this24;

              _classCallCheck(this, GenericFontLoader);

              _this24 = _super13.call(this, params);
              _this24.loadingContext = {
                requests: [],
                nextRequestId: 0
              };
              _this24.loadTestFontId = 0;
              return _this24;
            }

            _createClass(GenericFontLoader, [{
              key: "isSyncFontLoadingSupported",
              get: function get() {
                var supported = false;

                if (typeof navigator === "undefined") {
                  supported = true;
                } else {
                  var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent);

                  if ((m === null || m === void 0 ? void 0 : m[1]) >= 14) {
                    supported = true;
                  }
                }

                return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported);
              }
            }, {
              key: "_queueLoadingCallback",
              value: function _queueLoadingCallback(callback) {
                function completeRequest() {
                  (0, _util.assert)(!request.done, "completeRequest() cannot be called twice.");
                  request.done = true;

                  while (context.requests.length > 0 && context.requests[0].done) {
                    var otherRequest = context.requests.shift();
                    setTimeout(otherRequest.callback, 0);
                  }
                }

                var context = this.loadingContext;
                var request = {
                  id: "pdfjs-font-loading-".concat(context.nextRequestId++),
                  done: false,
                  complete: completeRequest,
                  callback: callback
                };
                context.requests.push(request);
                return request;
              }
            }, {
              key: "_loadTestFont",
              get: function get() {
                var getLoadTestFont = function getLoadTestFont() {
                  return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
                };

                return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont());
              }
            }, {
              key: "_prepareFontLoadEvent",
              value: function _prepareFontLoadEvent(rules, fonts, request) {
                var _this25 = this;

                function int32(data, offset) {
                  return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
                }

                function spliceString(s, offset, remove, insert) {
                  var chunk1 = s.substring(0, offset);
                  var chunk2 = s.substring(offset + remove);
                  return chunk1 + insert + chunk2;
                }

                var i, ii;

                var canvas = this._document.createElement("canvas");

                canvas.width = 1;
                canvas.height = 1;
                var ctx = canvas.getContext("2d");
                var called = 0;

                function isFontReady(name, callback) {
                  called++;

                  if (called > 30) {
                    (0, _util.warn)("Load test font never loaded.");
                    callback();
                    return;
                  }

                  ctx.font = "30px " + name;
                  ctx.fillText(".", 0, 20);
                  var imageData = ctx.getImageData(0, 0, 1, 1);

                  if (imageData.data[3] > 0) {
                    callback();
                    return;
                  }

                  setTimeout(isFontReady.bind(null, name, callback));
                }

                var loadTestFontId = "lt".concat(Date.now()).concat(this.loadTestFontId++);
                var data = this._loadTestFont;
                var COMMENT_OFFSET = 976;
                data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
                var CFF_CHECKSUM_OFFSET = 16;
                var XXXX_VALUE = 0x58585858;
                var checksum = int32(data, CFF_CHECKSUM_OFFSET);

                for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
                  checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
                }

                if (i < loadTestFontId.length) {
                  checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
                }

                data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));
                var url = "url(data:font/opentype;base64,".concat(btoa(data), ");");
                var rule = "@font-face {font-family:\"".concat(loadTestFontId, "\";src:").concat(url, "}");
                this.insertRule(rule);
                var names = [];

                var _iterator20 = _createForOfIteratorHelper(fonts),
                    _step20;

                try {
                  for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                    var font = _step20.value;
                    names.push(font.loadedName);
                  }
                } catch (err) {
                  _iterator20.e(err);
                } finally {
                  _iterator20.f();
                }

                names.push(loadTestFontId);

                var div = this._document.createElement("div");

                div.style.visibility = "hidden";
                div.style.width = div.style.height = "10px";
                div.style.position = "absolute";
                div.style.top = div.style.left = "0px";

                for (var _i4 = 0, _names = names; _i4 < _names.length; _i4++) {
                  var name = _names[_i4];

                  var span = this._document.createElement("span");

                  span.textContent = "Hi";
                  span.style.fontFamily = name;
                  div.appendChild(span);
                }

                this._document.body.appendChild(div);

                isFontReady(loadTestFontId, function () {
                  _this25._document.body.removeChild(div);

                  request.complete();
                });
              }
            }]);

            return GenericFontLoader;
          }(BaseFontLoader);
        }

        var FontFaceObject = /*#__PURE__*/function () {
          function FontFaceObject(translatedData, _ref33) {
            var _ref33$isEvalSupporte = _ref33.isEvalSupported,
                isEvalSupported = _ref33$isEvalSupporte === void 0 ? true : _ref33$isEvalSupporte,
                _ref33$disableFontFac = _ref33.disableFontFace,
                disableFontFace = _ref33$disableFontFac === void 0 ? false : _ref33$disableFontFac,
                _ref33$ignoreErrors = _ref33.ignoreErrors,
                ignoreErrors = _ref33$ignoreErrors === void 0 ? false : _ref33$ignoreErrors,
                onUnsupportedFeature = _ref33.onUnsupportedFeature,
                _ref33$fontRegistry = _ref33.fontRegistry,
                fontRegistry = _ref33$fontRegistry === void 0 ? null : _ref33$fontRegistry;

            _classCallCheck(this, FontFaceObject);

            this.compiledGlyphs = Object.create(null);

            for (var i in translatedData) {
              this[i] = translatedData[i];
            }

            this.isEvalSupported = isEvalSupported !== false;
            this.disableFontFace = disableFontFace === true;
            this.ignoreErrors = ignoreErrors === true;
            this._onUnsupportedFeature = onUnsupportedFeature;
            this.fontRegistry = fontRegistry;
          }

          _createClass(FontFaceObject, [{
            key: "createNativeFontFace",
            value: function createNativeFontFace() {
              if (!this.data || this.disableFontFace) {
                return null;
              }

              var nativeFontFace;

              if (!this.cssFontInfo) {
                nativeFontFace = new FontFace(this.loadedName, this.data, {});
              } else {
                var css = {
                  weight: this.cssFontInfo.fontWeight
                };

                if (this.cssFontInfo.italicAngle) {
                  css.style = "oblique ".concat(this.cssFontInfo.italicAngle, "deg");
                }

                nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
              }

              if (this.fontRegistry) {
                this.fontRegistry.registerFont(this);
              }

              return nativeFontFace;
            }
          }, {
            key: "createFontFaceRule",
            value: function createFontFaceRule() {
              if (!this.data || this.disableFontFace) {
                return null;
              }

              var data = (0, _util.bytesToString)(this.data);
              var url = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(data), ");");
              var rule;

              if (!this.cssFontInfo) {
                rule = "@font-face {font-family:\"".concat(this.loadedName, "\";src:").concat(url, "}");
              } else {
                var css = "font-weight: ".concat(this.cssFontInfo.fontWeight, ";");

                if (this.cssFontInfo.italicAngle) {
                  css += "font-style: oblique ".concat(this.cssFontInfo.italicAngle, "deg;");
                }

                rule = "@font-face {font-family:\"".concat(this.cssFontInfo.fontFamily, "\";").concat(css, "src:").concat(url, "}");
              }

              if (this.fontRegistry) {
                this.fontRegistry.registerFont(this, url);
              }

              return rule;
            }
          }, {
            key: "getPathGenerator",
            value: function getPathGenerator(objs, character) {
              if (this.compiledGlyphs[character] !== undefined) {
                return this.compiledGlyphs[character];
              }

              var cmds;

              try {
                cmds = objs.get(this.loadedName + "_path_" + character);
              } catch (ex) {
                if (!this.ignoreErrors) {
                  throw ex;
                }

                this._onUnsupportedFeature({
                  featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath
                });

                (0, _util.warn)("getPathGenerator - ignoring character: \"".concat(ex, "\"."));
                return this.compiledGlyphs[character] = function (c, size) {};
              }

              if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {
                var jsBuf = [];

                var _iterator21 = _createForOfIteratorHelper(cmds),
                    _step21;

                try {
                  for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {
                    var current = _step21.value;
                    var args = current.args !== undefined ? current.args.join(",") : "";
                    jsBuf.push("c.", current.cmd, "(", args, ");\n");
                  }
                } catch (err) {
                  _iterator21.e(err);
                } finally {
                  _iterator21.f();
                }

                return this.compiledGlyphs[character] = new Function("c", "size", jsBuf.join(""));
              }

              return this.compiledGlyphs[character] = function (c, size) {
                var _iterator22 = _createForOfIteratorHelper(cmds),
                    _step22;

                try {
                  for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {
                    var _current = _step22.value;

                    if (_current.cmd === "scale") {
                      _current.args = [size, -size];
                    }

                    c[_current.cmd].apply(c, _current.args);
                  }
                } catch (err) {
                  _iterator22.e(err);
                } finally {
                  _iterator22.f();
                }
              };
            }
          }]);

          return FontFaceObject;
        }();

        exports.FontFaceObject = FontFaceObject;
        /***/
      },
      /* 8 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.NodeStandardFontDataFactory = exports.NodeCMapReaderFactory = exports.NodeCanvasFactory = void 0;

        var _base_factory = __w_pdfjs_require__(5);

        var _is_node = __w_pdfjs_require__(4);

        var _util = __w_pdfjs_require__(2);

        var NodeCanvasFactory = /*#__PURE__*/_createClass(function NodeCanvasFactory() {
          _classCallCheck(this, NodeCanvasFactory);

          (0, _util.unreachable)("Not implemented: NodeCanvasFactory");
        });

        exports.NodeCanvasFactory = NodeCanvasFactory;

        var NodeCMapReaderFactory = /*#__PURE__*/_createClass(function NodeCMapReaderFactory() {
          _classCallCheck(this, NodeCMapReaderFactory);

          (0, _util.unreachable)("Not implemented: NodeCMapReaderFactory");
        });

        exports.NodeCMapReaderFactory = NodeCMapReaderFactory;

        var NodeStandardFontDataFactory = /*#__PURE__*/_createClass(function NodeStandardFontDataFactory() {
          _classCallCheck(this, NodeStandardFontDataFactory);

          (0, _util.unreachable)("Not implemented: NodeStandardFontDataFactory");
        });

        exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;

        if (_is_node.isNodeJS) {
          var fetchData = function fetchData(url) {
            return new Promise(function (resolve, reject) {
              var fs = __webpack_require__(17);

              fs.readFile(url, function (error, data) {
                if (error || !data) {
                  reject(new Error(error));
                  return;
                }

                resolve(new Uint8Array(data));
              });
            });
          };

          exports.NodeCanvasFactory = NodeCanvasFactory = /*#__PURE__*/function (_base_factory$BaseCan2) {
            _inherits(NodeCanvasFactory, _base_factory$BaseCan2);

            var _super14 = _createSuper(NodeCanvasFactory);

            function NodeCanvasFactory() {
              _classCallCheck(this, NodeCanvasFactory);

              return _super14.apply(this, arguments);
            }

            _createClass(NodeCanvasFactory, [{
              key: "_createCanvas",
              value: function _createCanvas(width, height) {
                var Canvas = __webpack_require__(18);

                return Canvas.createCanvas(width, height);
              }
            }]);

            return NodeCanvasFactory;
          }(_base_factory.BaseCanvasFactory);

          exports.NodeCMapReaderFactory = NodeCMapReaderFactory = /*#__PURE__*/function (_base_factory$BaseCMa2) {
            _inherits(NodeCMapReaderFactory, _base_factory$BaseCMa2);

            var _super15 = _createSuper(NodeCMapReaderFactory);

            function NodeCMapReaderFactory() {
              _classCallCheck(this, NodeCMapReaderFactory);

              return _super15.apply(this, arguments);
            }

            _createClass(NodeCMapReaderFactory, [{
              key: "_fetchData",
              value: function _fetchData(url, compressionType) {
                return fetchData(url).then(function (data) {
                  return {
                    cMapData: data,
                    compressionType: compressionType
                  };
                });
              }
            }]);

            return NodeCMapReaderFactory;
          }(_base_factory.BaseCMapReaderFactory);

          exports.NodeStandardFontDataFactory = NodeStandardFontDataFactory = /*#__PURE__*/function (_base_factory$BaseSta2) {
            _inherits(NodeStandardFontDataFactory, _base_factory$BaseSta2);

            var _super16 = _createSuper(NodeStandardFontDataFactory);

            function NodeStandardFontDataFactory() {
              _classCallCheck(this, NodeStandardFontDataFactory);

              return _super16.apply(this, arguments);
            }

            _createClass(NodeStandardFontDataFactory, [{
              key: "_fetchData",
              value: function _fetchData(url) {
                return fetchData(url);
              }
            }]);

            return NodeStandardFontDataFactory;
          }(_base_factory.BaseStandardFontDataFactory);
        }
        /***/

      },
      /* 9 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.AnnotationStorage = void 0;

        var _util = __w_pdfjs_require__(2);

        var AnnotationStorage = /*#__PURE__*/function () {
          function AnnotationStorage() {
            _classCallCheck(this, AnnotationStorage);

            this._storage = new Map();
            this._timeStamp = Date.now();
            this._modified = false;
            this.onSetModified = null;
            this.onResetModified = null;
          }

          _createClass(AnnotationStorage, [{
            key: "getValue",
            value: function getValue(key, defaultValue) {
              var value = this._storage.get(key);

              if (value === undefined) {
                return defaultValue;
              }

              return Object.assign(defaultValue, value);
            }
          }, {
            key: "setValue",
            value: function setValue(key, value) {
              var obj = this._storage.get(key);

              var modified = false;

              if (obj !== undefined) {
                for (var _i5 = 0, _Object$entries = Object.entries(value); _i5 < _Object$entries.length; _i5++) {
                  var _Object$entries$_i = _slicedToArray(_Object$entries[_i5], 2),
                      entry = _Object$entries$_i[0],
                      val = _Object$entries$_i[1];

                  if (obj[entry] !== val) {
                    modified = true;
                    obj[entry] = val;
                  }
                }
              } else {
                modified = true;

                this._storage.set(key, value);
              }

              if (modified) {
                this._timeStamp = Date.now();

                this._setModified();
              }
            }
          }, {
            key: "getAll",
            value: function getAll() {
              return this._storage.size > 0 ? (0, _util.objectFromMap)(this._storage) : null;
            }
          }, {
            key: "size",
            get: function get() {
              return this._storage.size;
            }
          }, {
            key: "_setModified",
            value: function _setModified() {
              if (!this._modified) {
                this._modified = true;

                if (typeof this.onSetModified === "function") {
                  this.onSetModified();
                }
              }
            }
          }, {
            key: "resetModified",
            value: function resetModified() {
              if (this._modified) {
                this._modified = false;

                if (typeof this.onResetModified === "function") {
                  this.onResetModified();
                }
              }
            }
          }, {
            key: "serializable",
            get: function get() {
              return this._storage.size > 0 ? this._storage : null;
            }
          }, {
            key: "lastModified",
            get: function get() {
              return this._timeStamp.toString();
            }
          }]);

          return AnnotationStorage;
        }();

        exports.AnnotationStorage = AnnotationStorage;
        /***/
      },
      /* 10 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.CanvasGraphics = void 0;

        var _util = __w_pdfjs_require__(2);

        var _pattern_helper = __w_pdfjs_require__(11);

        var _display_utils = __w_pdfjs_require__(1);

        var MIN_FONT_SIZE = 16;
        var MAX_FONT_SIZE = 100;
        var MAX_GROUP_SIZE = 4096;
        var MAX_CACHED_CANVAS_PATTERNS = 2;
        var EXECUTION_TIME = 15;
        var EXECUTION_STEPS = 10;
        var COMPILE_TYPE3_GLYPHS = true;
        var MAX_SIZE_TO_COMPILE = 1000;
        var FULL_CHUNK_HEIGHT = 16;
        var LINEWIDTH_SCALE_FACTOR = 1.000001;

        function addContextCurrentTransform(ctx) {
          if (ctx.mozCurrentTransform) {
            return;
          }

          ctx._originalSave = ctx.save;
          ctx._originalRestore = ctx.restore;
          ctx._originalRotate = ctx.rotate;
          ctx._originalScale = ctx.scale;
          ctx._originalTranslate = ctx.translate;
          ctx._originalTransform = ctx.transform;
          ctx._originalSetTransform = ctx.setTransform;
          ctx._originalResetTransform = ctx.resetTransform;
          ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];
          ctx._transformStack = [];

          try {
            var desc = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(ctx), "lineWidth");
            ctx._setLineWidth = desc.set;
            ctx._getLineWidth = desc.get;
            Object.defineProperty(ctx, "lineWidth", {
              set: function setLineWidth(width) {
                this._setLineWidth(width * LINEWIDTH_SCALE_FACTOR);
              },
              get: function getLineWidth() {
                return this._getLineWidth();
              }
            });
          } catch (_) {}

          Object.defineProperty(ctx, "mozCurrentTransform", {
            get: function getCurrentTransform() {
              return this._transformMatrix;
            }
          });
          Object.defineProperty(ctx, "mozCurrentTransformInverse", {
            get: function getCurrentTransformInverse() {
              var _this$_transformMatri = _slicedToArray(this._transformMatrix, 6),
                  a = _this$_transformMatri[0],
                  b = _this$_transformMatri[1],
                  c = _this$_transformMatri[2],
                  d = _this$_transformMatri[3],
                  e = _this$_transformMatri[4],
                  f = _this$_transformMatri[5];

              var ad_bc = a * d - b * c;
              var bc_ad = b * c - a * d;
              return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];
            }
          });

          ctx.save = function ctxSave() {
            var old = this._transformMatrix;

            this._transformStack.push(old);

            this._transformMatrix = old.slice(0, 6);

            this._originalSave();
          };

          ctx.restore = function ctxRestore() {
            var prev = this._transformStack.pop();

            if (prev) {
              this._transformMatrix = prev;

              this._originalRestore();
            }
          };

          ctx.translate = function ctxTranslate(x, y) {
            var m = this._transformMatrix;
            m[4] = m[0] * x + m[2] * y + m[4];
            m[5] = m[1] * x + m[3] * y + m[5];

            this._originalTranslate(x, y);
          };

          ctx.scale = function ctxScale(x, y) {
            var m = this._transformMatrix;
            m[0] *= x;
            m[1] *= x;
            m[2] *= y;
            m[3] *= y;

            this._originalScale(x, y);
          };

          ctx.transform = function ctxTransform(a, b, c, d, e, f) {
            var m = this._transformMatrix;
            this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];

            ctx._originalTransform(a, b, c, d, e, f);
          };

          ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {
            this._transformMatrix = [a, b, c, d, e, f];

            ctx._originalSetTransform(a, b, c, d, e, f);
          };

          ctx.resetTransform = function ctxResetTransform() {
            this._transformMatrix = [1, 0, 0, 1, 0, 0];

            ctx._originalResetTransform();
          };

          ctx.rotate = function ctxRotate(angle) {
            var cosValue = Math.cos(angle);
            var sinValue = Math.sin(angle);
            var m = this._transformMatrix;
            this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];

            this._originalRotate(angle);
          };
        }

        var CachedCanvases = /*#__PURE__*/function () {
          function CachedCanvases(canvasFactory) {
            _classCallCheck(this, CachedCanvases);

            this.canvasFactory = canvasFactory;
            this.cache = Object.create(null);
          }

          _createClass(CachedCanvases, [{
            key: "getCanvas",
            value: function getCanvas(id, width, height, trackTransform) {
              var canvasEntry;

              if (this.cache[id] !== undefined) {
                canvasEntry = this.cache[id];
                this.canvasFactory.reset(canvasEntry, width, height);
                canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);
              } else {
                canvasEntry = this.canvasFactory.create(width, height);
                this.cache[id] = canvasEntry;
              }

              if (trackTransform) {
                addContextCurrentTransform(canvasEntry.context);
              }

              return canvasEntry;
            }
          }, {
            key: "clear",
            value: function clear() {
              for (var id in this.cache) {
                var canvasEntry = this.cache[id];
                this.canvasFactory.destroy(canvasEntry);
                delete this.cache[id];
              }
            }
          }]);

          return CachedCanvases;
        }();

        var LRUCache = /*#__PURE__*/function () {
          function LRUCache() {
            var maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

            _classCallCheck(this, LRUCache);

            this._cache = new Map();
            this._maxSize = maxSize;
          }

          _createClass(LRUCache, [{
            key: "has",
            value: function has(key) {
              return this._cache.has(key);
            }
          }, {
            key: "get",
            value: function get(key) {
              if (this._cache.has(key)) {
                var value = this._cache.get(key);

                this._cache["delete"](key);

                this._cache.set(key, value);
              }

              return this._cache.get(key);
            }
          }, {
            key: "set",
            value: function set(key, value) {
              if (this._maxSize <= 0) {
                return;
              }

              if (this._cache.size + 1 > this._maxSize) {
                this._cache["delete"](this._cache.keys().next().value);
              }

              this._cache.set(key, value);
            }
          }, {
            key: "clear",
            value: function clear() {
              this._cache.clear();
            }
          }]);

          return LRUCache;
        }();

        function compileType3Glyph(imgData) {
          var POINT_TO_PROCESS_LIMIT = 1000;
          var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);
          var width = imgData.width,
              height = imgData.height,
              width1 = width + 1;
          var i, ii, j, j0;
          var points = new Uint8Array(width1 * (height + 1));
          var lineSize = width + 7 & ~7,
              data0 = imgData.data;
          var data = new Uint8Array(lineSize * height);
          var pos = 0;

          for (i = 0, ii = data0.length; i < ii; i++) {
            var elem = data0[i];
            var mask = 128;

            while (mask > 0) {
              data[pos++] = elem & mask ? 0 : 255;
              mask >>= 1;
            }
          }

          var count = 0;
          pos = 0;

          if (data[pos] !== 0) {
            points[0] = 1;
            ++count;
          }

          for (j = 1; j < width; j++) {
            if (data[pos] !== data[pos + 1]) {
              points[j] = data[pos] ? 2 : 1;
              ++count;
            }

            pos++;
          }

          if (data[pos] !== 0) {
            points[j] = 2;
            ++count;
          }

          for (i = 1; i < height; i++) {
            pos = i * lineSize;
            j0 = i * width1;

            if (data[pos - lineSize] !== data[pos]) {
              points[j0] = data[pos] ? 1 : 8;
              ++count;
            }

            var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);

            for (j = 1; j < width; j++) {
              sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);

              if (POINT_TYPES[sum]) {
                points[j0 + j] = POINT_TYPES[sum];
                ++count;
              }

              pos++;
            }

            if (data[pos - lineSize] !== data[pos]) {
              points[j0 + j] = data[pos] ? 2 : 4;
              ++count;
            }

            if (count > POINT_TO_PROCESS_LIMIT) {
              return null;
            }
          }

          pos = lineSize * (height - 1);
          j0 = i * width1;

          if (data[pos] !== 0) {
            points[j0] = 8;
            ++count;
          }

          for (j = 1; j < width; j++) {
            if (data[pos] !== data[pos + 1]) {
              points[j0 + j] = data[pos] ? 4 : 8;
              ++count;
            }

            pos++;
          }

          if (data[pos] !== 0) {
            points[j0 + j] = 4;
            ++count;
          }

          if (count > POINT_TO_PROCESS_LIMIT) {
            return null;
          }

          var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);
          var outlines = [];

          for (i = 0; count && i <= height; i++) {
            var p = i * width1;
            var end = p + width;

            while (p < end && !points[p]) {
              p++;
            }

            if (p === end) {
              continue;
            }

            var coords = [p % width1, i];
            var p0 = p;
            var type = points[p];

            do {
              var step = steps[type];

              do {
                p += step;
              } while (!points[p]);

              var pp = points[p];

              if (pp !== 5 && pp !== 10) {
                type = pp;
                points[p] = 0;
              } else {
                type = pp & 0x33 * type >> 4;
                points[p] &= type >> 2 | type << 2;
              }

              coords.push(p % width1, p / width1 | 0);

              if (!points[p]) {
                --count;
              }
            } while (p0 !== p);

            outlines.push(coords);
            --i;
          }

          var drawOutline = function drawOutline(c) {
            c.save();
            c.scale(1 / width, -1 / height);
            c.translate(0, -height);
            c.beginPath();

            for (var k = 0, kk = outlines.length; k < kk; k++) {
              var o = outlines[k];
              c.moveTo(o[0], o[1]);

              for (var l = 2, ll = o.length; l < ll; l += 2) {
                c.lineTo(o[l], o[l + 1]);
              }
            }

            c.fill();
            c.beginPath();
            c.restore();
          };

          return drawOutline;
        }

        var CanvasExtraState = /*#__PURE__*/function () {
          function CanvasExtraState() {
            _classCallCheck(this, CanvasExtraState);

            this.alphaIsShape = false;
            this.fontSize = 0;
            this.fontSizeScale = 1;
            this.textMatrix = _util.IDENTITY_MATRIX;
            this.textMatrixScale = 1;
            this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
            this.leading = 0;
            this.x = 0;
            this.y = 0;
            this.lineX = 0;
            this.lineY = 0;
            this.charSpacing = 0;
            this.wordSpacing = 0;
            this.textHScale = 1;
            this.textRenderingMode = _util.TextRenderingMode.FILL;
            this.textRise = 0;
            this.fillColor = "#000000";
            this.strokeColor = "#000000";
            this.patternFill = false;
            this.fillAlpha = 1;
            this.strokeAlpha = 1;
            this.lineWidth = 1;
            this.activeSMask = null;
            this.resumeSMaskCtx = null;
            this.transferMaps = null;
          }

          _createClass(CanvasExtraState, [{
            key: "clone",
            value: function clone() {
              return Object.create(this);
            }
          }, {
            key: "setCurrentPoint",
            value: function setCurrentPoint(x, y) {
              this.x = x;
              this.y = y;
            }
          }]);

          return CanvasExtraState;
        }();

        function putBinaryImageData(ctx, imgData) {
          var transferMaps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (typeof ImageData !== "undefined" && imgData instanceof ImageData) {
            ctx.putImageData(imgData, 0, 0);
            return;
          }

          var height = imgData.height,
              width = imgData.width;
          var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
          var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
          var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
          var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
          var srcPos = 0,
              destPos;
          var src = imgData.data;
          var dest = chunkImgData.data;
          var i, j, thisChunkHeight, elemsInThisChunk;
          var transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;

          if (transferMaps) {
            switch (transferMaps.length) {
              case 1:
                transferMapRed = transferMaps[0];
                transferMapGreen = transferMaps[0];
                transferMapBlue = transferMaps[0];
                transferMapGray = transferMaps[0];
                break;

              case 4:
                transferMapRed = transferMaps[0];
                transferMapGreen = transferMaps[1];
                transferMapBlue = transferMaps[2];
                transferMapGray = transferMaps[3];
                break;
            }
          }

          if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {
            var srcLength = src.byteLength;
            var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
            var dest32DataLength = dest32.length;
            var fullSrcDiff = width + 7 >> 3;
            var white = 0xffffffff;
            var black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;

            if (transferMapGray) {
              if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {
                var _ref34 = [black, white];
                white = _ref34[0];
                black = _ref34[1];
              }
            }

            for (i = 0; i < totalChunks; i++) {
              thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
              destPos = 0;

              for (j = 0; j < thisChunkHeight; j++) {
                var srcDiff = srcLength - srcPos;
                var k = 0;
                var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                var kEndUnrolled = kEnd & ~7;
                var mask = 0;
                var srcByte = 0;

                for (; k < kEndUnrolled; k += 8) {
                  srcByte = src[srcPos++];
                  dest32[destPos++] = srcByte & 128 ? white : black;
                  dest32[destPos++] = srcByte & 64 ? white : black;
                  dest32[destPos++] = srcByte & 32 ? white : black;
                  dest32[destPos++] = srcByte & 16 ? white : black;
                  dest32[destPos++] = srcByte & 8 ? white : black;
                  dest32[destPos++] = srcByte & 4 ? white : black;
                  dest32[destPos++] = srcByte & 2 ? white : black;
                  dest32[destPos++] = srcByte & 1 ? white : black;
                }

                for (; k < kEnd; k++) {
                  if (mask === 0) {
                    srcByte = src[srcPos++];
                    mask = 128;
                  }

                  dest32[destPos++] = srcByte & mask ? white : black;
                  mask >>= 1;
                }
              }

              while (destPos < dest32DataLength) {
                dest32[destPos++] = 0;
              }

              ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
            }
          } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {
            var hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);
            j = 0;
            elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;

            for (i = 0; i < fullChunks; i++) {
              dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
              srcPos += elemsInThisChunk;

              if (hasTransferMaps) {
                for (var _k = 0; _k < elemsInThisChunk; _k += 4) {
                  if (transferMapRed) {
                    dest[_k + 0] = transferMapRed[dest[_k + 0]];
                  }

                  if (transferMapGreen) {
                    dest[_k + 1] = transferMapGreen[dest[_k + 1]];
                  }

                  if (transferMapBlue) {
                    dest[_k + 2] = transferMapBlue[dest[_k + 2]];
                  }
                }
              }

              ctx.putImageData(chunkImgData, 0, j);
              j += FULL_CHUNK_HEIGHT;
            }

            if (i < totalChunks) {
              elemsInThisChunk = width * partialChunkHeight * 4;
              dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));

              if (hasTransferMaps) {
                for (var _k2 = 0; _k2 < elemsInThisChunk; _k2 += 4) {
                  if (transferMapRed) {
                    dest[_k2 + 0] = transferMapRed[dest[_k2 + 0]];
                  }

                  if (transferMapGreen) {
                    dest[_k2 + 1] = transferMapGreen[dest[_k2 + 1]];
                  }

                  if (transferMapBlue) {
                    dest[_k2 + 2] = transferMapBlue[dest[_k2 + 2]];
                  }
                }
              }

              ctx.putImageData(chunkImgData, 0, j);
            }
          } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {
            var _hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);

            thisChunkHeight = FULL_CHUNK_HEIGHT;
            elemsInThisChunk = width * thisChunkHeight;

            for (i = 0; i < totalChunks; i++) {
              if (i >= fullChunks) {
                thisChunkHeight = partialChunkHeight;
                elemsInThisChunk = width * thisChunkHeight;
              }

              destPos = 0;

              for (j = elemsInThisChunk; j--;) {
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = 255;
              }

              if (_hasTransferMaps) {
                for (var _k3 = 0; _k3 < destPos; _k3 += 4) {
                  if (transferMapRed) {
                    dest[_k3 + 0] = transferMapRed[dest[_k3 + 0]];
                  }

                  if (transferMapGreen) {
                    dest[_k3 + 1] = transferMapGreen[dest[_k3 + 1]];
                  }

                  if (transferMapBlue) {
                    dest[_k3 + 2] = transferMapBlue[dest[_k3 + 2]];
                  }
                }
              }

              ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
            }
          } else {
            throw new Error("bad image kind: ".concat(imgData.kind));
          }
        }

        function putBinaryImageMask(ctx, imgData) {
          var height = imgData.height,
              width = imgData.width;
          var partialChunkHeight = height % FULL_CHUNK_HEIGHT;
          var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
          var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
          var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
          var srcPos = 0;
          var src = imgData.data;
          var dest = chunkImgData.data;

          for (var i = 0; i < totalChunks; i++) {
            var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
            var destPos = 3;

            for (var j = 0; j < thisChunkHeight; j++) {
              var elem = void 0,
                  mask = 0;

              for (var k = 0; k < width; k++) {
                if (!mask) {
                  elem = src[srcPos++];
                  mask = 128;
                }

                dest[destPos] = elem & mask ? 0 : 255;
                destPos += 4;
                mask >>= 1;
              }
            }

            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
          }
        }

        function copyCtxState(sourceCtx, destCtx) {
          var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"];

          for (var i = 0, ii = properties.length; i < ii; i++) {
            var property = properties[i];

            if (sourceCtx[property] !== undefined) {
              destCtx[property] = sourceCtx[property];
            }
          }

          if (sourceCtx.setLineDash !== undefined) {
            destCtx.setLineDash(sourceCtx.getLineDash());
            destCtx.lineDashOffset = sourceCtx.lineDashOffset;
          }
        }

        function resetCtxToDefault(ctx) {
          ctx.strokeStyle = "#000000";
          ctx.fillStyle = "#000000";
          ctx.fillRule = "nonzero";
          ctx.globalAlpha = 1;
          ctx.lineWidth = 1;
          ctx.lineCap = "butt";
          ctx.lineJoin = "miter";
          ctx.miterLimit = 10;
          ctx.globalCompositeOperation = "source-over";
          ctx.font = "10px sans-serif";

          if (ctx.setLineDash !== undefined) {
            ctx.setLineDash([]);
            ctx.lineDashOffset = 0;
          }
        }

        function composeSMaskBackdrop(bytes, r0, g0, b0) {
          var length = bytes.length;

          for (var i = 3; i < length; i += 4) {
            var alpha = bytes[i];

            if (alpha === 0) {
              bytes[i - 3] = r0;
              bytes[i - 2] = g0;
              bytes[i - 1] = b0;
            } else if (alpha < 255) {
              var alpha_ = 255 - alpha;
              bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;
              bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;
              bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;
            }
          }
        }

        function composeSMaskAlpha(maskData, layerData, transferMap) {
          var length = maskData.length;
          var scale = 1 / 255;

          for (var i = 3; i < length; i += 4) {
            var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];
            layerData[i] = layerData[i] * alpha * scale | 0;
          }
        }

        function composeSMaskLuminosity(maskData, layerData, transferMap) {
          var length = maskData.length;

          for (var i = 3; i < length; i += 4) {
            var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;
            layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;
          }
        }

        function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {
          var hasBackdrop = !!backdrop;
          var r0 = hasBackdrop ? backdrop[0] : 0;
          var g0 = hasBackdrop ? backdrop[1] : 0;
          var b0 = hasBackdrop ? backdrop[2] : 0;
          var composeFn;

          if (subtype === "Luminosity") {
            composeFn = composeSMaskLuminosity;
          } else {
            composeFn = composeSMaskAlpha;
          }

          var PIXELS_TO_PROCESS = 1048576;
          var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));

          for (var row = 0; row < height; row += chunkSize) {
            var chunkHeight = Math.min(chunkSize, height - row);
            var maskData = maskCtx.getImageData(0, row, width, chunkHeight);
            var layerData = layerCtx.getImageData(0, row, width, chunkHeight);

            if (hasBackdrop) {
              composeSMaskBackdrop(maskData.data, r0, g0, b0);
            }

            composeFn(maskData.data, layerData.data, transferMap);
            maskCtx.putImageData(layerData, 0, row);
          }
        }

        function composeSMask(ctx, smask, layerCtx) {
          var mask = smask.canvas;
          var maskCtx = smask.context;
          ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);
          genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, smask.backdrop, smask.transferMap);
          ctx.drawImage(mask, 0, 0);
        }

        function getImageSmoothingEnabled(transform, interpolate) {
          var scale = _util.Util.singularValueDecompose2dScale(transform);

          scale[0] = Math.fround(scale[0]);
          scale[1] = Math.fround(scale[1]);
          var actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);

          if (interpolate !== undefined) {
            return interpolate;
          } else if (scale[0] <= actualScale || scale[1] <= actualScale) {
            return true;
          }

          return false;
        }

        var LINE_CAP_STYLES = ["butt", "round", "square"];
        var LINE_JOIN_STYLES = ["miter", "round", "bevel"];
        var NORMAL_CLIP = {};
        var EO_CLIP = {};

        var CanvasGraphics = /*#__PURE__*/function () {
          function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, imageLayer, optionalContentConfig) {
            _classCallCheck(this, CanvasGraphics);

            this.ctx = canvasCtx;
            this.current = new CanvasExtraState();
            this.stateStack = [];
            this.pendingClip = null;
            this.pendingEOFill = false;
            this.res = null;
            this.xobjs = null;
            this.commonObjs = commonObjs;
            this.objs = objs;
            this.canvasFactory = canvasFactory;
            this.imageLayer = imageLayer;
            this.groupStack = [];
            this.processingType3 = null;
            this.baseTransform = null;
            this.baseTransformStack = [];
            this.groupLevel = 0;
            this.smaskStack = [];
            this.smaskCounter = 0;
            this.tempSMask = null;
            this.contentVisible = true;
            this.markedContentStack = [];
            this.optionalContentConfig = optionalContentConfig;
            this.cachedCanvases = new CachedCanvases(this.canvasFactory);
            this.cachedCanvasPatterns = new LRUCache(MAX_CACHED_CANVAS_PATTERNS);
            this.cachedPatterns = new Map();

            if (canvasCtx) {
              addContextCurrentTransform(canvasCtx);
            }

            this._cachedGetSinglePixelWidth = null;
          }

          _createClass(CanvasGraphics, [{
            key: "beginDrawing",
            value: function beginDrawing(_ref35) {
              var transform = _ref35.transform,
                  viewport = _ref35.viewport,
                  _ref35$transparency = _ref35.transparency,
                  transparency = _ref35$transparency === void 0 ? false : _ref35$transparency,
                  _ref35$background = _ref35.background,
                  background = _ref35$background === void 0 ? null : _ref35$background;
              var width = this.ctx.canvas.width;
              var height = this.ctx.canvas.height;
              this.ctx.save();
              this.ctx.fillStyle = background || "rgb(255, 255, 255)";
              this.ctx.fillRect(0, 0, width, height);
              this.ctx.restore();

              if (transparency) {
                var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true);
                this.compositeCtx = this.ctx;
                this.transparentCanvas = transparentCanvas.canvas;
                this.ctx = transparentCanvas.context;
                this.ctx.save();
                this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);
              }

              this.ctx.save();
              resetCtxToDefault(this.ctx);

              if (transform) {
                this.ctx.transform.apply(this.ctx, transform);
              }

              this.ctx.transform.apply(this.ctx, viewport.transform);
              this.baseTransform = this.ctx.mozCurrentTransform.slice();
              this._combinedScaleFactor = Math.hypot(this.baseTransform[0], this.baseTransform[2]);

              if (this.imageLayer) {
                this.imageLayer.beginLayout();
              }
            }
          }, {
            key: "executeOperatorList",
            value: function executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {
              var argsArray = operatorList.argsArray;
              var fnArray = operatorList.fnArray;
              var i = executionStartIdx || 0;
              var argsArrayLen = argsArray.length;

              if (argsArrayLen === i) {
                return i;
              }

              var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
              var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
              var steps = 0;
              var commonObjs = this.commonObjs;
              var objs = this.objs;
              var fnId;

              while (true) {
                if (stepper !== undefined && i === stepper.nextBreakPoint) {
                  stepper.breakIt(i, continueCallback);
                  return i;
                }

                fnId = fnArray[i];

                if (fnId !== _util.OPS.dependency) {
                  this[fnId].apply(this, argsArray[i]);
                } else {
                  var _iterator23 = _createForOfIteratorHelper(argsArray[i]),
                      _step23;

                  try {
                    for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {
                      var depObjId = _step23.value;
                      var objsPool = depObjId.startsWith("g_") ? commonObjs : objs;

                      if (!objsPool.has(depObjId)) {
                        objsPool.get(depObjId, continueCallback);
                        return i;
                      }
                    }
                  } catch (err) {
                    _iterator23.e(err);
                  } finally {
                    _iterator23.f();
                  }
                }

                i++;

                if (i === argsArrayLen) {
                  return i;
                }

                if (chunkOperations && ++steps > EXECUTION_STEPS) {
                  if (Date.now() > endTime) {
                    continueCallback();
                    return i;
                  }

                  steps = 0;
                }
              }
            }
          }, {
            key: "endDrawing",
            value: function endDrawing() {
              while (this.stateStack.length || this.current.activeSMask !== null) {
                this.restore();
              }

              this.ctx.restore();

              if (this.transparentCanvas) {
                this.ctx = this.compositeCtx;
                this.ctx.save();
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.drawImage(this.transparentCanvas, 0, 0);
                this.ctx.restore();
                this.transparentCanvas = null;
              }

              this.cachedCanvases.clear();
              this.cachedCanvasPatterns.clear();
              this.cachedPatterns.clear();

              if (this.imageLayer) {
                this.imageLayer.endLayout();
              }
            }
          }, {
            key: "_scaleImage",
            value: function _scaleImage(img, inverseTransform) {
              var width = img.width;
              var height = img.height;
              var widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
              var heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
              var paintWidth = width,
                  paintHeight = height;
              var tmpCanvasId = "prescale1";
              var tmpCanvas, tmpCtx;

              while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
                var newWidth = paintWidth,
                    newHeight = paintHeight;

                if (widthScale > 2 && paintWidth > 1) {
                  newWidth = Math.ceil(paintWidth / 2);
                  widthScale /= paintWidth / newWidth;
                }

                if (heightScale > 2 && paintHeight > 1) {
                  newHeight = Math.ceil(paintHeight / 2);
                  heightScale /= paintHeight / newHeight;
                }

                tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
                tmpCtx = tmpCanvas.context;
                tmpCtx.clearRect(0, 0, newWidth, newHeight);
                tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
                img = tmpCanvas.canvas;
                paintWidth = newWidth;
                paintHeight = newHeight;
                tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
              }

              return {
                img: img,
                paintWidth: paintWidth,
                paintHeight: paintHeight
              };
            }
          }, {
            key: "_createMaskCanvas",
            value: function _createMaskCanvas(img) {
              var ctx = this.ctx;
              var width = img.width,
                  height = img.height;
              var fillColor = this.current.fillColor;
              var isPatternFill = this.current.patternFill;
              var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
              var maskCtx = maskCanvas.context;
              putBinaryImageMask(maskCtx, img);
              var objToCanvas = ctx.mozCurrentTransform;

              var maskToCanvas = _util.Util.transform(objToCanvas, [1 / width, 0, 0, -1 / height, 0, 0]);

              maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);

              var cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);

              var cord2 = _util.Util.applyTransform([width, height], maskToCanvas);

              var rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);

              var drawnWidth = Math.ceil(rect[2] - rect[0]);
              var drawnHeight = Math.ceil(rect[3] - rect[1]);
              var fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight, true);
              var fillCtx = fillCanvas.context;
              var offsetX = Math.min(cord1[0], cord2[0]);
              var offsetY = Math.min(cord1[1], cord2[1]);
              fillCtx.translate(-offsetX, -offsetY);
              fillCtx.transform.apply(fillCtx, maskToCanvas);

              var scaled = this._scaleImage(maskCanvas.canvas, fillCtx.mozCurrentTransformInverse);

              fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(fillCtx.mozCurrentTransform, img.interpolate);
              fillCtx.drawImage(scaled.img, 0, 0, scaled.img.width, scaled.img.height, 0, 0, width, height);
              fillCtx.globalCompositeOperation = "source-in";

              var inverse = _util.Util.transform(fillCtx.mozCurrentTransformInverse, [1, 0, 0, 1, -offsetX, -offsetY]);

              fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, false) : fillColor;
              fillCtx.fillRect(0, 0, width, height);
              return {
                canvas: fillCanvas.canvas,
                offsetX: Math.round(offsetX),
                offsetY: Math.round(offsetY)
              };
            }
          }, {
            key: "setLineWidth",
            value: function setLineWidth(width) {
              this.current.lineWidth = width;
              this.ctx.lineWidth = width;
            }
          }, {
            key: "setLineCap",
            value: function setLineCap(style) {
              this.ctx.lineCap = LINE_CAP_STYLES[style];
            }
          }, {
            key: "setLineJoin",
            value: function setLineJoin(style) {
              this.ctx.lineJoin = LINE_JOIN_STYLES[style];
            }
          }, {
            key: "setMiterLimit",
            value: function setMiterLimit(limit) {
              this.ctx.miterLimit = limit;
            }
          }, {
            key: "setDash",
            value: function setDash(dashArray, dashPhase) {
              var ctx = this.ctx;

              if (ctx.setLineDash !== undefined) {
                ctx.setLineDash(dashArray);
                ctx.lineDashOffset = dashPhase;
              }
            }
          }, {
            key: "setRenderingIntent",
            value: function setRenderingIntent(intent) {}
          }, {
            key: "setFlatness",
            value: function setFlatness(flatness) {}
          }, {
            key: "setGState",
            value: function setGState(states) {
              for (var i = 0, ii = states.length; i < ii; i++) {
                var state = states[i];
                var key = state[0];
                var value = state[1];

                switch (key) {
                  case "LW":
                    this.setLineWidth(value);
                    break;

                  case "LC":
                    this.setLineCap(value);
                    break;

                  case "LJ":
                    this.setLineJoin(value);
                    break;

                  case "ML":
                    this.setMiterLimit(value);
                    break;

                  case "D":
                    this.setDash(value[0], value[1]);
                    break;

                  case "RI":
                    this.setRenderingIntent(value);
                    break;

                  case "FL":
                    this.setFlatness(value);
                    break;

                  case "Font":
                    this.setFont(value[0], value[1]);
                    break;

                  case "CA":
                    this.current.strokeAlpha = state[1];
                    break;

                  case "ca":
                    this.current.fillAlpha = state[1];
                    this.ctx.globalAlpha = state[1];
                    break;

                  case "BM":
                    this.ctx.globalCompositeOperation = value;
                    break;

                  case "SMask":
                    if (this.current.activeSMask) {
                      if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {
                        this.suspendSMaskGroup();
                      } else {
                        this.endSMaskGroup();
                      }
                    }

                    this.current.activeSMask = value ? this.tempSMask : null;

                    if (this.current.activeSMask) {
                      this.beginSMaskGroup();
                    }

                    this.tempSMask = null;
                    break;

                  case "TR":
                    this.current.transferMaps = value;
                }
              }
            }
          }, {
            key: "beginSMaskGroup",
            value: function beginSMaskGroup() {
              var activeSMask = this.current.activeSMask;
              var drawnWidth = activeSMask.canvas.width;
              var drawnHeight = activeSMask.canvas.height;
              var cacheId = "smaskGroupAt" + this.groupLevel;
              var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
              var currentCtx = this.ctx;
              var currentTransform = currentCtx.mozCurrentTransform;
              this.ctx.save();
              var groupCtx = scratchCanvas.context;
              groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);
              groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);
              groupCtx.transform.apply(groupCtx, currentTransform);
              activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;
              copyCtxState(currentCtx, groupCtx);
              this.ctx = groupCtx;
              this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
              this.groupStack.push(currentCtx);
              this.groupLevel++;
            }
          }, {
            key: "suspendSMaskGroup",
            value: function suspendSMaskGroup() {
              var groupCtx = this.ctx;
              this.groupLevel--;
              this.ctx = this.groupStack.pop();
              composeSMask(this.ctx, this.current.activeSMask, groupCtx);
              this.ctx.restore();
              this.ctx.save();
              copyCtxState(groupCtx, this.ctx);
              this.current.resumeSMaskCtx = groupCtx;

              var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

              this.ctx.transform.apply(this.ctx, deltaTransform);
              groupCtx.save();
              groupCtx.setTransform(1, 0, 0, 1, 0, 0);
              groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);
              groupCtx.restore();
            }
          }, {
            key: "resumeSMaskGroup",
            value: function resumeSMaskGroup() {
              var groupCtx = this.current.resumeSMaskCtx;
              var currentCtx = this.ctx;
              this.ctx = groupCtx;
              this.groupStack.push(currentCtx);
              this.groupLevel++;
            }
          }, {
            key: "endSMaskGroup",
            value: function endSMaskGroup() {
              var groupCtx = this.ctx;
              this.groupLevel--;
              this.ctx = this.groupStack.pop();
              composeSMask(this.ctx, this.current.activeSMask, groupCtx);
              this.ctx.restore();
              copyCtxState(groupCtx, this.ctx);

              var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);

              this.ctx.transform.apply(this.ctx, deltaTransform);
            }
          }, {
            key: "save",
            value: function save() {
              this.ctx.save();
              var old = this.current;
              this.stateStack.push(old);
              this.current = old.clone();
              this.current.resumeSMaskCtx = null;
            }
          }, {
            key: "restore",
            value: function restore() {
              if (this.current.resumeSMaskCtx) {
                this.resumeSMaskGroup();
              }

              if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {
                this.endSMaskGroup();
              }

              if (this.stateStack.length !== 0) {
                this.current = this.stateStack.pop();
                this.ctx.restore();
                this.pendingClip = null;
                this._cachedGetSinglePixelWidth = null;
              } else {
                this.current.activeSMask = null;
              }
            }
          }, {
            key: "transform",
            value: function transform(a, b, c, d, e, f) {
              this.ctx.transform(a, b, c, d, e, f);
              this._cachedGetSinglePixelWidth = null;
            }
          }, {
            key: "constructPath",
            value: function constructPath(ops, args) {
              var ctx = this.ctx;
              var current = this.current;
              var x = current.x,
                  y = current.y;

              for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {
                switch (ops[i] | 0) {
                  case _util.OPS.rectangle:
                    x = args[j++];
                    y = args[j++];
                    var width = args[j++];
                    var height = args[j++];
                    var xw = x + width;
                    var yh = y + height;
                    ctx.moveTo(x, y);

                    if (width === 0 || height === 0) {
                      ctx.lineTo(xw, yh);
                    } else {
                      ctx.lineTo(xw, y);
                      ctx.lineTo(xw, yh);
                      ctx.lineTo(x, yh);
                    }

                    ctx.closePath();
                    break;

                  case _util.OPS.moveTo:
                    x = args[j++];
                    y = args[j++];
                    ctx.moveTo(x, y);
                    break;

                  case _util.OPS.lineTo:
                    x = args[j++];
                    y = args[j++];
                    ctx.lineTo(x, y);
                    break;

                  case _util.OPS.curveTo:
                    x = args[j + 4];
                    y = args[j + 5];
                    ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);
                    j += 6;
                    break;

                  case _util.OPS.curveTo2:
                    ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);
                    x = args[j + 2];
                    y = args[j + 3];
                    j += 4;
                    break;

                  case _util.OPS.curveTo3:
                    x = args[j + 2];
                    y = args[j + 3];
                    ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);
                    j += 4;
                    break;

                  case _util.OPS.closePath:
                    ctx.closePath();
                    break;
                }
              }

              current.setCurrentPoint(x, y);
            }
          }, {
            key: "closePath",
            value: function closePath() {
              this.ctx.closePath();
            }
          }, {
            key: "stroke",
            value: function stroke(consumePath) {
              consumePath = typeof consumePath !== "undefined" ? consumePath : true;
              var ctx = this.ctx;
              var strokeColor = this.current.strokeColor;
              ctx.globalAlpha = this.current.strokeAlpha;

              if (this.contentVisible) {
                if (_typeof(strokeColor) === "object" && strokeColor !== null && strokeColor !== void 0 && strokeColor.getPattern) {
                  var lineWidth = this.getSinglePixelWidth();
                  ctx.save();
                  ctx.strokeStyle = strokeColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse);
                  ctx.lineWidth = Math.max(lineWidth, this.current.lineWidth);
                  ctx.stroke();
                  ctx.restore();
                } else {
                  var _lineWidth = this.getSinglePixelWidth();

                  if (_lineWidth < 0 && -_lineWidth >= this.current.lineWidth) {
                    ctx.save();
                    ctx.resetTransform();
                    ctx.lineWidth = Math.round(this._combinedScaleFactor);
                    ctx.stroke();
                    ctx.restore();
                  } else {
                    ctx.lineWidth = Math.max(_lineWidth, this.current.lineWidth);
                    ctx.stroke();
                  }
                }
              }

              if (consumePath) {
                this.consumePath();
              }

              ctx.globalAlpha = this.current.fillAlpha;
            }
          }, {
            key: "closeStroke",
            value: function closeStroke() {
              this.closePath();
              this.stroke();
            }
          }, {
            key: "fill",
            value: function fill(consumePath) {
              consumePath = typeof consumePath !== "undefined" ? consumePath : true;
              var ctx = this.ctx;
              var fillColor = this.current.fillColor;
              var isPatternFill = this.current.patternFill;
              var needRestore = false;

              if (isPatternFill) {
                ctx.save();
                ctx.fillStyle = fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse);
                needRestore = true;
              }

              if (this.contentVisible) {
                if (this.pendingEOFill) {
                  ctx.fill("evenodd");
                  this.pendingEOFill = false;
                } else {
                  ctx.fill();
                }
              }

              if (needRestore) {
                ctx.restore();
              }

              if (consumePath) {
                this.consumePath();
              }
            }
          }, {
            key: "eoFill",
            value: function eoFill() {
              this.pendingEOFill = true;
              this.fill();
            }
          }, {
            key: "fillStroke",
            value: function fillStroke() {
              this.fill(false);
              this.stroke(false);
              this.consumePath();
            }
          }, {
            key: "eoFillStroke",
            value: function eoFillStroke() {
              this.pendingEOFill = true;
              this.fillStroke();
            }
          }, {
            key: "closeFillStroke",
            value: function closeFillStroke() {
              this.closePath();
              this.fillStroke();
            }
          }, {
            key: "closeEOFillStroke",
            value: function closeEOFillStroke() {
              this.pendingEOFill = true;
              this.closePath();
              this.fillStroke();
            }
          }, {
            key: "endPath",
            value: function endPath() {
              this.consumePath();
            }
          }, {
            key: "clip",
            value: function clip() {
              this.pendingClip = NORMAL_CLIP;
            }
          }, {
            key: "eoClip",
            value: function eoClip() {
              this.pendingClip = EO_CLIP;
            }
          }, {
            key: "beginText",
            value: function beginText() {
              this.current.textMatrix = _util.IDENTITY_MATRIX;
              this.current.textMatrixScale = 1;
              this.current.x = this.current.lineX = 0;
              this.current.y = this.current.lineY = 0;
            }
          }, {
            key: "endText",
            value: function endText() {
              var paths = this.pendingTextPaths;
              var ctx = this.ctx;

              if (paths === undefined) {
                ctx.beginPath();
                return;
              }

              ctx.save();
              ctx.beginPath();

              for (var i = 0; i < paths.length; i++) {
                var path = paths[i];
                ctx.setTransform.apply(ctx, path.transform);
                ctx.translate(path.x, path.y);
                path.addToPath(ctx, path.fontSize);
              }

              ctx.restore();
              ctx.clip();
              ctx.beginPath();
              delete this.pendingTextPaths;
            }
          }, {
            key: "setCharSpacing",
            value: function setCharSpacing(spacing) {
              this.current.charSpacing = spacing;
            }
          }, {
            key: "setWordSpacing",
            value: function setWordSpacing(spacing) {
              this.current.wordSpacing = spacing;
            }
          }, {
            key: "setHScale",
            value: function setHScale(scale) {
              this.current.textHScale = scale / 100;
            }
          }, {
            key: "setLeading",
            value: function setLeading(leading) {
              this.current.leading = -leading;
            }
          }, {
            key: "setFont",
            value: function setFont(fontRefName, size) {
              var fontObj = this.commonObjs.get(fontRefName);
              var current = this.current;

              if (!fontObj) {
                throw new Error("Can't find font for ".concat(fontRefName));
              }

              current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;

              if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
                (0, _util.warn)("Invalid font matrix for font " + fontRefName);
              }

              if (size < 0) {
                size = -size;
                current.fontDirection = -1;
              } else {
                current.fontDirection = 1;
              }

              this.current.font = fontObj;
              this.current.fontSize = size;

              if (fontObj.isType3Font) {
                return;
              }

              var name = fontObj.loadedName || "sans-serif";
              var bold = "normal";

              if (fontObj.black) {
                bold = "900";
              } else if (fontObj.bold) {
                bold = "bold";
              }

              var italic = fontObj.italic ? "italic" : "normal";
              var typeface = "\"".concat(name, "\", ").concat(fontObj.fallbackName);
              var browserFontSize = size;

              if (size < MIN_FONT_SIZE) {
                browserFontSize = MIN_FONT_SIZE;
              } else if (size > MAX_FONT_SIZE) {
                browserFontSize = MAX_FONT_SIZE;
              }

              this.current.fontSizeScale = size / browserFontSize;
              this.ctx.font = "".concat(italic, " ").concat(bold, " ").concat(browserFontSize, "px ").concat(typeface);
            }
          }, {
            key: "setTextRenderingMode",
            value: function setTextRenderingMode(mode) {
              this.current.textRenderingMode = mode;
            }
          }, {
            key: "setTextRise",
            value: function setTextRise(rise) {
              this.current.textRise = rise;
            }
          }, {
            key: "moveText",
            value: function moveText(x, y) {
              this.current.x = this.current.lineX += x;
              this.current.y = this.current.lineY += y;
            }
          }, {
            key: "setLeadingMoveText",
            value: function setLeadingMoveText(x, y) {
              this.setLeading(-y);
              this.moveText(x, y);
            }
          }, {
            key: "setTextMatrix",
            value: function setTextMatrix(a, b, c, d, e, f) {
              this.current.textMatrix = [a, b, c, d, e, f];
              this.current.textMatrixScale = Math.hypot(a, b);
              this.current.x = this.current.lineX = 0;
              this.current.y = this.current.lineY = 0;
            }
          }, {
            key: "nextLine",
            value: function nextLine() {
              this.moveText(0, this.current.leading);
            }
          }, {
            key: "paintChar",
            value: function paintChar(character, x, y, patternTransform, resetLineWidthToOne) {
              var ctx = this.ctx;
              var current = this.current;
              var font = current.font;
              var textRenderingMode = current.textRenderingMode;
              var fontSize = current.fontSize / current.fontSizeScale;
              var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;
              var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);
              var patternFill = current.patternFill && !font.missingFile;
              var addToPath;

              if (font.disableFontFace || isAddToPathSet || patternFill) {
                addToPath = font.getPathGenerator(this.commonObjs, character);
              }

              if (font.disableFontFace || patternFill) {
                ctx.save();
                ctx.translate(x, y);
                ctx.beginPath();
                addToPath(ctx, fontSize);

                if (patternTransform) {
                  ctx.setTransform.apply(ctx, patternTransform);
                }

                if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                  ctx.fill();
                }

                if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                  if (resetLineWidthToOne) {
                    ctx.resetTransform();
                    ctx.lineWidth = Math.round(this._combinedScaleFactor);
                  }

                  ctx.stroke();
                }

                ctx.restore();
              } else {
                if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                  ctx.fillText(character, x, y);
                }

                if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                  if (resetLineWidthToOne) {
                    ctx.save();
                    ctx.moveTo(x, y);
                    ctx.resetTransform();
                    ctx.lineWidth = Math.round(this._combinedScaleFactor);
                    ctx.strokeText(character, 0, 0);
                    ctx.restore();
                  } else {
                    ctx.strokeText(character, x, y);
                  }
                }
              }

              if (isAddToPathSet) {
                var paths = this.pendingTextPaths || (this.pendingTextPaths = []);
                paths.push({
                  transform: ctx.mozCurrentTransform,
                  x: x,
                  y: y,
                  fontSize: fontSize,
                  addToPath: addToPath
                });
              }
            }
          }, {
            key: "isFontSubpixelAAEnabled",
            get: function get() {
              var _this$cachedCanvases$ = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10),
                  ctx = _this$cachedCanvases$.context;

              ctx.scale(1.5, 1);
              ctx.fillText("I", 0, 10);
              var data = ctx.getImageData(0, 0, 10, 10).data;
              var enabled = false;

              for (var i = 3; i < data.length; i += 4) {
                if (data[i] > 0 && data[i] < 255) {
                  enabled = true;
                  break;
                }
              }

              return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled);
            }
          }, {
            key: "showText",
            value: function showText(glyphs) {
              var current = this.current;
              var font = current.font;

              if (font.isType3Font) {
                return this.showType3Text(glyphs);
              }

              var fontSize = current.fontSize;

              if (fontSize === 0) {
                return undefined;
              }

              var ctx = this.ctx;
              var fontSizeScale = current.fontSizeScale;
              var charSpacing = current.charSpacing;
              var wordSpacing = current.wordSpacing;
              var fontDirection = current.fontDirection;
              var textHScale = current.textHScale * fontDirection;
              var glyphsLength = glyphs.length;
              var vertical = font.vertical;
              var spacingDir = vertical ? 1 : -1;
              var defaultVMetrics = font.defaultVMetrics;
              var widthAdvanceScale = fontSize * current.fontMatrix[0];
              var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
              ctx.save();
              var patternTransform;

              if (current.patternFill) {
                ctx.save();
                var pattern = current.fillColor.getPattern(ctx, this, ctx.mozCurrentTransformInverse);
                patternTransform = ctx.mozCurrentTransform;
                ctx.restore();
                ctx.fillStyle = pattern;
              }

              ctx.transform.apply(ctx, current.textMatrix);
              ctx.translate(current.x, current.y + current.textRise);

              if (fontDirection > 0) {
                ctx.scale(textHScale, -1);
              } else {
                ctx.scale(textHScale, 1);
              }

              var lineWidth = current.lineWidth;
              var resetLineWidthToOne = false;
              var scale = current.textMatrixScale;

              if (scale === 0 || lineWidth === 0) {
                var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

                if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                  this._cachedGetSinglePixelWidth = null;
                  lineWidth = this.getSinglePixelWidth();
                  resetLineWidthToOne = lineWidth < 0;
                }
              } else {
                lineWidth /= scale;
              }

              if (fontSizeScale !== 1.0) {
                ctx.scale(fontSizeScale, fontSizeScale);
                lineWidth /= fontSizeScale;
              }

              ctx.lineWidth = lineWidth;
              var x = 0,
                  i;

              for (i = 0; i < glyphsLength; ++i) {
                var glyph = glyphs[i];

                if ((0, _util.isNum)(glyph)) {
                  x += spacingDir * glyph * fontSize / 1000;
                  continue;
                }

                var restoreNeeded = false;
                var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                var character = glyph.fontChar;
                var accent = glyph.accent;
                var scaledX = void 0,
                    scaledY = void 0;
                var width = glyph.width;

                if (vertical) {
                  var vmetric = glyph.vmetric || defaultVMetrics;
                  var vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                  var vy = vmetric[2] * widthAdvanceScale;
                  width = vmetric ? -vmetric[0] : width;
                  scaledX = vx / fontSizeScale;
                  scaledY = (x + vy) / fontSizeScale;
                } else {
                  scaledX = x / fontSizeScale;
                  scaledY = 0;
                }

                if (font.remeasure && width > 0) {
                  var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;

                  if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                    var characterScaleX = width / measuredWidth;
                    restoreNeeded = true;
                    ctx.save();
                    ctx.scale(characterScaleX, 1);
                    scaledX /= characterScaleX;
                  } else if (width !== measuredWidth) {
                    scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
                  }
                }

                if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                  if (simpleFillText && !accent) {
                    ctx.fillText(character, scaledX, scaledY);
                  } else {
                    this.paintChar(character, scaledX, scaledY, patternTransform, resetLineWidthToOne);

                    if (accent) {
                      var scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                      var scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                      this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform, resetLineWidthToOne);
                    }
                  }
                }

                var charWidth = void 0;

                if (vertical) {
                  charWidth = width * widthAdvanceScale - spacing * fontDirection;
                } else {
                  charWidth = width * widthAdvanceScale + spacing * fontDirection;
                }

                x += charWidth;

                if (restoreNeeded) {
                  ctx.restore();
                }
              }

              if (vertical) {
                current.y -= x;
              } else {
                current.x += x * textHScale;
              }

              ctx.restore();
              return undefined;
            }
          }, {
            key: "showType3Text",
            value: function showType3Text(glyphs) {
              var ctx = this.ctx;
              var current = this.current;
              var font = current.font;
              var fontSize = current.fontSize;
              var fontDirection = current.fontDirection;
              var spacingDir = font.vertical ? 1 : -1;
              var charSpacing = current.charSpacing;
              var wordSpacing = current.wordSpacing;
              var textHScale = current.textHScale * fontDirection;
              var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;
              var glyphsLength = glyphs.length;
              var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;
              var i, glyph, width, spacingLength;

              if (isTextInvisible || fontSize === 0) {
                return;
              }

              this._cachedGetSinglePixelWidth = null;
              ctx.save();
              ctx.transform.apply(ctx, current.textMatrix);
              ctx.translate(current.x, current.y);
              ctx.scale(textHScale, fontDirection);

              for (i = 0; i < glyphsLength; ++i) {
                glyph = glyphs[i];

                if ((0, _util.isNum)(glyph)) {
                  spacingLength = spacingDir * glyph * fontSize / 1000;
                  this.ctx.translate(spacingLength, 0);
                  current.x += spacingLength * textHScale;
                  continue;
                }

                var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                var operatorList = font.charProcOperatorList[glyph.operatorListId];

                if (!operatorList) {
                  (0, _util.warn)("Type3 character \"".concat(glyph.operatorListId, "\" is not available."));
                  continue;
                }

                if (this.contentVisible) {
                  this.processingType3 = glyph;
                  this.save();
                  ctx.scale(fontSize, fontSize);
                  ctx.transform.apply(ctx, fontMatrix);
                  this.executeOperatorList(operatorList);
                  this.restore();
                }

                var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);

                width = transformed[0] * fontSize + spacing;
                ctx.translate(width, 0);
                current.x += width * textHScale;
              }

              ctx.restore();
              this.processingType3 = null;
            }
          }, {
            key: "setCharWidth",
            value: function setCharWidth(xWidth, yWidth) {}
          }, {
            key: "setCharWidthAndBounds",
            value: function setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {
              this.ctx.rect(llx, lly, urx - llx, ury - lly);
              this.clip();
              this.endPath();
            }
          }, {
            key: "getColorN_Pattern",
            value: function getColorN_Pattern(IR) {
              var _this26 = this;

              var pattern;

              if (IR[0] === "TilingPattern") {
                var color = IR[1];
                var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();
                var canvasGraphicsFactory = {
                  createCanvasGraphics: function createCanvasGraphics(ctx) {
                    return new CanvasGraphics(ctx, _this26.commonObjs, _this26.objs, _this26.canvasFactory);
                  }
                };
                pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);
              } else {
                pattern = this._getPattern(IR[1], IR[2]);
              }

              return pattern;
            }
          }, {
            key: "setStrokeColorN",
            value: function setStrokeColorN() {
              this.current.strokeColor = this.getColorN_Pattern(arguments);
            }
          }, {
            key: "setFillColorN",
            value: function setFillColorN() {
              this.current.fillColor = this.getColorN_Pattern(arguments);
              this.current.patternFill = true;
            }
          }, {
            key: "setStrokeRGBColor",
            value: function setStrokeRGBColor(r, g, b) {
              var color = _util.Util.makeHexColor(r, g, b);

              this.ctx.strokeStyle = color;
              this.current.strokeColor = color;
            }
          }, {
            key: "setFillRGBColor",
            value: function setFillRGBColor(r, g, b) {
              var color = _util.Util.makeHexColor(r, g, b);

              this.ctx.fillStyle = color;
              this.current.fillColor = color;
              this.current.patternFill = false;
            }
          }, {
            key: "_getPattern",
            value: function _getPattern(objId) {
              var matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              var pattern;

              if (this.cachedPatterns.has(objId)) {
                pattern = this.cachedPatterns.get(objId);
              } else {
                pattern = (0, _pattern_helper.getShadingPattern)(this.objs.get(objId), this.cachedCanvasPatterns);
                this.cachedPatterns.set(objId, pattern);
              }

              if (matrix) {
                pattern.matrix = matrix;
              }

              return pattern;
            }
          }, {
            key: "shadingFill",
            value: function shadingFill(objId) {
              if (!this.contentVisible) {
                return;
              }

              var ctx = this.ctx;
              this.save();

              var pattern = this._getPattern(objId);

              ctx.fillStyle = pattern.getPattern(ctx, this, ctx.mozCurrentTransformInverse, true);
              var inv = ctx.mozCurrentTransformInverse;

              if (inv) {
                var canvas = ctx.canvas;
                var width = canvas.width;
                var height = canvas.height;

                var bl = _util.Util.applyTransform([0, 0], inv);

                var br = _util.Util.applyTransform([0, height], inv);

                var ul = _util.Util.applyTransform([width, 0], inv);

                var ur = _util.Util.applyTransform([width, height], inv);

                var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
              } else {
                this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
              }

              this.restore();
            }
          }, {
            key: "beginInlineImage",
            value: function beginInlineImage() {
              (0, _util.unreachable)("Should not call beginInlineImage");
            }
          }, {
            key: "beginImageData",
            value: function beginImageData() {
              (0, _util.unreachable)("Should not call beginImageData");
            }
          }, {
            key: "paintFormXObjectBegin",
            value: function paintFormXObjectBegin(matrix, bbox) {
              if (!this.contentVisible) {
                return;
              }

              this.save();
              this.baseTransformStack.push(this.baseTransform);

              if (Array.isArray(matrix) && matrix.length === 6) {
                this.transform.apply(this, matrix);
              }

              this.baseTransform = this.ctx.mozCurrentTransform;

              if (bbox) {
                var width = bbox[2] - bbox[0];
                var height = bbox[3] - bbox[1];
                this.ctx.rect(bbox[0], bbox[1], width, height);
                this.clip();
                this.endPath();
              }
            }
          }, {
            key: "paintFormXObjectEnd",
            value: function paintFormXObjectEnd() {
              if (!this.contentVisible) {
                return;
              }

              this.restore();
              this.baseTransform = this.baseTransformStack.pop();
            }
          }, {
            key: "beginGroup",
            value: function beginGroup(group) {
              if (!this.contentVisible) {
                return;
              }

              this.save();
              var currentCtx = this.ctx;

              if (!group.isolated) {
                (0, _util.info)("TODO: Support non-isolated groups.");
              }

              if (group.knockout) {
                (0, _util.warn)("Knockout groups not supported.");
              }

              var currentTransform = currentCtx.mozCurrentTransform;

              if (group.matrix) {
                currentCtx.transform.apply(currentCtx, group.matrix);
              }

              if (!group.bbox) {
                throw new Error("Bounding box is required.");
              }

              var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);

              var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
              bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
              var offsetX = Math.floor(bounds[0]);
              var offsetY = Math.floor(bounds[1]);
              var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
              var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
              var scaleX = 1,
                  scaleY = 1;

              if (drawnWidth > MAX_GROUP_SIZE) {
                scaleX = drawnWidth / MAX_GROUP_SIZE;
                drawnWidth = MAX_GROUP_SIZE;
              }

              if (drawnHeight > MAX_GROUP_SIZE) {
                scaleY = drawnHeight / MAX_GROUP_SIZE;
                drawnHeight = MAX_GROUP_SIZE;
              }

              var cacheId = "groupAt" + this.groupLevel;

              if (group.smask) {
                cacheId += "_smask_" + this.smaskCounter++ % 2;
              }

              var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);
              var groupCtx = scratchCanvas.context;
              groupCtx.scale(1 / scaleX, 1 / scaleY);
              groupCtx.translate(-offsetX, -offsetY);
              groupCtx.transform.apply(groupCtx, currentTransform);

              if (group.smask) {
                this.smaskStack.push({
                  canvas: scratchCanvas.canvas,
                  context: groupCtx,
                  offsetX: offsetX,
                  offsetY: offsetY,
                  scaleX: scaleX,
                  scaleY: scaleY,
                  subtype: group.smask.subtype,
                  backdrop: group.smask.backdrop,
                  transferMap: group.smask.transferMap || null,
                  startTransformInverse: null
                });
              } else {
                currentCtx.setTransform(1, 0, 0, 1, 0, 0);
                currentCtx.translate(offsetX, offsetY);
                currentCtx.scale(scaleX, scaleY);
              }

              copyCtxState(currentCtx, groupCtx);
              this.ctx = groupCtx;
              this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
              this.groupStack.push(currentCtx);
              this.groupLevel++;
              this.current.activeSMask = null;
            }
          }, {
            key: "endGroup",
            value: function endGroup(group) {
              if (!this.contentVisible) {
                return;
              }

              this.groupLevel--;
              var groupCtx = this.ctx;
              this.ctx = this.groupStack.pop();
              this.ctx.imageSmoothingEnabled = false;

              if (group.smask) {
                this.tempSMask = this.smaskStack.pop();
              } else {
                this.ctx.drawImage(groupCtx.canvas, 0, 0);
              }

              this.restore();
            }
          }, {
            key: "beginAnnotations",
            value: function beginAnnotations() {
              this.save();

              if (this.baseTransform) {
                this.ctx.setTransform.apply(this.ctx, this.baseTransform);
              }
            }
          }, {
            key: "endAnnotations",
            value: function endAnnotations() {
              this.restore();
            }
          }, {
            key: "beginAnnotation",
            value: function beginAnnotation(id, rect, transform, matrix) {
              this.save();
              resetCtxToDefault(this.ctx);
              this.current = new CanvasExtraState();

              if (Array.isArray(rect) && rect.length === 4) {
                var width = rect[2] - rect[0];
                var height = rect[3] - rect[1];
                this.ctx.rect(rect[0], rect[1], width, height);
                this.clip();
                this.endPath();
              }

              this.transform.apply(this, transform);
              this.transform.apply(this, matrix);
            }
          }, {
            key: "endAnnotation",
            value: function endAnnotation() {
              this.restore();
            }
          }, {
            key: "paintImageMaskXObject",
            value: function paintImageMaskXObject(img) {
              if (!this.contentVisible) {
                return;
              }

              var ctx = this.ctx;
              var width = img.width,
                  height = img.height;
              var glyph = this.processingType3;

              if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {
                if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {
                  glyph.compiled = compileType3Glyph({
                    data: img.data,
                    width: width,
                    height: height
                  });
                } else {
                  glyph.compiled = null;
                }
              }

              if (glyph !== null && glyph !== void 0 && glyph.compiled) {
                glyph.compiled(ctx);
                return;
              }

              var mask = this._createMaskCanvas(img);

              var maskCanvas = mask.canvas;
              ctx.save();
              ctx.setTransform(1, 0, 0, 1, 0, 0);
              ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
              ctx.restore();
            }
          }, {
            key: "paintImageMaskXObjectRepeat",
            value: function paintImageMaskXObjectRepeat(imgData, scaleX) {
              var skewX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              var skewY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var scaleY = arguments.length > 4 ? arguments[4] : undefined;
              var positions = arguments.length > 5 ? arguments[5] : undefined;

              if (!this.contentVisible) {
                return;
              }

              var ctx = this.ctx;
              ctx.save();
              var currentTransform = ctx.mozCurrentTransform;
              ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);

              var mask = this._createMaskCanvas(imgData);

              ctx.setTransform(1, 0, 0, 1, 0, 0);

              for (var i = 0, ii = positions.length; i < ii; i += 2) {
                var trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);

                var _util$Util$applyTrans = _util.Util.applyTransform([0, 0], trans),
                    _util$Util$applyTrans2 = _slicedToArray(_util$Util$applyTrans, 2),
                    x = _util$Util$applyTrans2[0],
                    y = _util$Util$applyTrans2[1];

                ctx.drawImage(mask.canvas, x, y);
              }

              ctx.restore();
            }
          }, {
            key: "paintImageMaskXObjectGroup",
            value: function paintImageMaskXObjectGroup(images) {
              if (!this.contentVisible) {
                return;
              }

              var ctx = this.ctx;
              var fillColor = this.current.fillColor;
              var isPatternFill = this.current.patternFill;

              for (var i = 0, ii = images.length; i < ii; i++) {
                var image = images[i];
                var width = image.width,
                    height = image.height;
                var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
                var maskCtx = maskCanvas.context;
                maskCtx.save();
                putBinaryImageMask(maskCtx, image);
                maskCtx.globalCompositeOperation = "source-in";
                maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, ctx.mozCurrentTransformInverse, false) : fillColor;
                maskCtx.fillRect(0, 0, width, height);
                maskCtx.restore();
                ctx.save();
                ctx.transform.apply(ctx, image.transform);
                ctx.scale(1, -1);
                ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
                ctx.restore();
              }
            }
          }, {
            key: "paintImageXObject",
            value: function paintImageXObject(objId) {
              if (!this.contentVisible) {
                return;
              }

              var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

              if (!imgData) {
                (0, _util.warn)("Dependent image isn't ready yet");
                return;
              }

              this.paintInlineImageXObject(imgData);
            }
          }, {
            key: "paintImageXObjectRepeat",
            value: function paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {
              if (!this.contentVisible) {
                return;
              }

              var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

              if (!imgData) {
                (0, _util.warn)("Dependent image isn't ready yet");
                return;
              }

              var width = imgData.width;
              var height = imgData.height;
              var map = [];

              for (var i = 0, ii = positions.length; i < ii; i += 2) {
                map.push({
                  transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                  x: 0,
                  y: 0,
                  w: width,
                  h: height
                });
              }

              this.paintInlineImageXObjectGroup(imgData, map);
            }
          }, {
            key: "paintInlineImageXObject",
            value: function paintInlineImageXObject(imgData) {
              if (!this.contentVisible) {
                return;
              }

              var width = imgData.width;
              var height = imgData.height;
              var ctx = this.ctx;
              this.save();
              ctx.scale(1 / width, -1 / height);
              var imgToPaint;

              if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
                imgToPaint = imgData;
              } else {
                var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
                var tmpCtx = tmpCanvas.context;
                putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);
                imgToPaint = tmpCanvas.canvas;
              }

              var scaled = this._scaleImage(imgToPaint, ctx.mozCurrentTransformInverse);

              ctx.imageSmoothingEnabled = getImageSmoothingEnabled(ctx.mozCurrentTransform, imgData.interpolate);
              ctx.drawImage(scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);

              if (this.imageLayer) {
                var position = this.getCanvasPosition(0, -height);
                this.imageLayer.appendImage({
                  imgData: imgData,
                  left: position[0],
                  top: position[1],
                  width: width / ctx.mozCurrentTransformInverse[0],
                  height: height / ctx.mozCurrentTransformInverse[3]
                });
              }

              this.restore();
            }
          }, {
            key: "paintInlineImageXObjectGroup",
            value: function paintInlineImageXObjectGroup(imgData, map) {
              if (!this.contentVisible) {
                return;
              }

              var ctx = this.ctx;
              var w = imgData.width;
              var h = imgData.height;
              var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
              var tmpCtx = tmpCanvas.context;
              putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);

              for (var i = 0, ii = map.length; i < ii; i++) {
                var entry = map[i];
                ctx.save();
                ctx.transform.apply(ctx, entry.transform);
                ctx.scale(1, -1);
                ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);

                if (this.imageLayer) {
                  var position = this.getCanvasPosition(entry.x, entry.y);
                  this.imageLayer.appendImage({
                    imgData: imgData,
                    left: position[0],
                    top: position[1],
                    width: w,
                    height: h
                  });
                }

                ctx.restore();
              }
            }
          }, {
            key: "paintSolidColorImageMask",
            value: function paintSolidColorImageMask() {
              if (!this.contentVisible) {
                return;
              }

              this.ctx.fillRect(0, 0, 1, 1);
            }
          }, {
            key: "markPoint",
            value: function markPoint(tag) {}
          }, {
            key: "markPointProps",
            value: function markPointProps(tag, properties) {}
          }, {
            key: "beginMarkedContent",
            value: function beginMarkedContent(tag) {
              this.markedContentStack.push({
                visible: true
              });
            }
          }, {
            key: "beginMarkedContentProps",
            value: function beginMarkedContentProps(tag, properties) {
              if (tag === "OC") {
                this.markedContentStack.push({
                  visible: this.optionalContentConfig.isVisible(properties)
                });
              } else {
                this.markedContentStack.push({
                  visible: true
                });
              }

              this.contentVisible = this.isContentVisible();
            }
          }, {
            key: "endMarkedContent",
            value: function endMarkedContent() {
              this.markedContentStack.pop();
              this.contentVisible = this.isContentVisible();
            }
          }, {
            key: "beginCompat",
            value: function beginCompat() {}
          }, {
            key: "endCompat",
            value: function endCompat() {}
          }, {
            key: "consumePath",
            value: function consumePath() {
              var ctx = this.ctx;

              if (this.pendingClip) {
                if (this.pendingClip === EO_CLIP) {
                  ctx.clip("evenodd");
                } else {
                  ctx.clip();
                }

                this.pendingClip = null;
              }

              ctx.beginPath();
            }
          }, {
            key: "getSinglePixelWidth",
            value: function getSinglePixelWidth() {
              if (this._cachedGetSinglePixelWidth === null) {
                var m = this.ctx.mozCurrentTransform;
                var absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                var sqNorm1 = Math.pow(m[0], 2) + Math.pow(m[2], 2);
                var sqNorm2 = Math.pow(m[1], 2) + Math.pow(m[3], 2);
                var pixelHeight = Math.sqrt(Math.max(sqNorm1, sqNorm2)) / absDet;

                if (sqNorm1 !== sqNorm2 && this._combinedScaleFactor * pixelHeight > 1) {
                  this._cachedGetSinglePixelWidth = -(this._combinedScaleFactor * pixelHeight);
                } else if (absDet > Number.EPSILON) {
                  this._cachedGetSinglePixelWidth = pixelHeight;
                } else {
                  this._cachedGetSinglePixelWidth = 1;
                }
              }

              return this._cachedGetSinglePixelWidth;
            }
          }, {
            key: "getCanvasPosition",
            value: function getCanvasPosition(x, y) {
              var transform = this.ctx.mozCurrentTransform;
              return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];
            }
          }, {
            key: "isContentVisible",
            value: function isContentVisible() {
              for (var i = this.markedContentStack.length - 1; i >= 0; i--) {
                if (!this.markedContentStack[i].visible) {
                  return false;
                }
              }

              return true;
            }
          }]);

          return CanvasGraphics;
        }();

        exports.CanvasGraphics = CanvasGraphics;

        for (var op in _util.OPS) {
          if (CanvasGraphics.prototype[op] !== undefined) {
            CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];
          }
        }
        /***/

      },
      /* 11 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.getShadingPattern = getShadingPattern;
        exports.TilingPattern = void 0;

        var _util = __w_pdfjs_require__(2);

        function applyBoundingBox(ctx, bbox) {
          if (!bbox || typeof Path2D === "undefined") {
            return;
          }

          var width = bbox[2] - bbox[0];
          var height = bbox[3] - bbox[1];
          var region = new Path2D();
          region.rect(bbox[0], bbox[1], width, height);
          ctx.clip(region);
        }

        var BaseShadingPattern = /*#__PURE__*/function () {
          function BaseShadingPattern() {
            _classCallCheck(this, BaseShadingPattern);

            if (this.constructor === BaseShadingPattern) {
              (0, _util.unreachable)("Cannot initialize BaseShadingPattern.");
            }
          }

          _createClass(BaseShadingPattern, [{
            key: "getPattern",
            value: function getPattern() {
              (0, _util.unreachable)("Abstract method `getPattern` called.");
            }
          }]);

          return BaseShadingPattern;
        }();

        var RadialAxialShadingPattern = /*#__PURE__*/function (_BaseShadingPattern) {
          _inherits(RadialAxialShadingPattern, _BaseShadingPattern);

          var _super17 = _createSuper(RadialAxialShadingPattern);

          function RadialAxialShadingPattern(IR, cachedCanvasPatterns) {
            var _this27;

            _classCallCheck(this, RadialAxialShadingPattern);

            _this27 = _super17.call(this);
            _this27._type = IR[1];
            _this27._bbox = IR[2];
            _this27._colorStops = IR[3];
            _this27._p0 = IR[4];
            _this27._p1 = IR[5];
            _this27._r0 = IR[6];
            _this27._r1 = IR[7];
            _this27.matrix = null;
            _this27.cachedCanvasPatterns = cachedCanvasPatterns;
            return _this27;
          }

          _createClass(RadialAxialShadingPattern, [{
            key: "_createGradient",
            value: function _createGradient(ctx) {
              var grad;

              if (this._type === "axial") {
                grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
              } else if (this._type === "radial") {
                grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
              }

              var _iterator24 = _createForOfIteratorHelper(this._colorStops),
                  _step24;

              try {
                for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {
                  var colorStop = _step24.value;
                  grad.addColorStop(colorStop[0], colorStop[1]);
                }
              } catch (err) {
                _iterator24.e(err);
              } finally {
                _iterator24.f();
              }

              return grad;
            }
          }, {
            key: "getPattern",
            value: function getPattern(ctx, owner, inverse) {
              var shadingFill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
              var pattern;

              if (!shadingFill) {
                if (this.cachedCanvasPatterns.has(this)) {
                  pattern = this.cachedCanvasPatterns.get(this);
                } else {
                  var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", owner.ctx.canvas.width, owner.ctx.canvas.height, true);
                  var tmpCtx = tmpCanvas.context;
                  tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                  tmpCtx.beginPath();
                  tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
                  tmpCtx.setTransform.apply(tmpCtx, owner.baseTransform);

                  if (this.matrix) {
                    tmpCtx.transform.apply(tmpCtx, this.matrix);
                  }

                  applyBoundingBox(tmpCtx, this._bbox);
                  tmpCtx.fillStyle = this._createGradient(tmpCtx);
                  tmpCtx.fill();
                  pattern = ctx.createPattern(tmpCanvas.canvas, "repeat");
                  this.cachedCanvasPatterns.set(this, pattern);
                }
              } else {
                applyBoundingBox(ctx, this._bbox);
                pattern = this._createGradient(ctx);
              }

              if (!shadingFill) {
                var domMatrix = new DOMMatrix(inverse);

                try {
                  pattern.setTransform(domMatrix);
                } catch (ex) {
                  (0, _util.warn)("RadialAxialShadingPattern.getPattern: \"".concat(ex === null || ex === void 0 ? void 0 : ex.message, "\"."));
                }
              }

              return pattern;
            }
          }]);

          return RadialAxialShadingPattern;
        }(BaseShadingPattern);

        function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
          var coords = context.coords,
              colors = context.colors;
          var bytes = data.data,
              rowSize = data.width * 4;
          var tmp;

          if (coords[p1 + 1] > coords[p2 + 1]) {
            tmp = p1;
            p1 = p2;
            p2 = tmp;
            tmp = c1;
            c1 = c2;
            c2 = tmp;
          }

          if (coords[p2 + 1] > coords[p3 + 1]) {
            tmp = p2;
            p2 = p3;
            p3 = tmp;
            tmp = c2;
            c2 = c3;
            c3 = tmp;
          }

          if (coords[p1 + 1] > coords[p2 + 1]) {
            tmp = p1;
            p1 = p2;
            p2 = tmp;
            tmp = c1;
            c1 = c2;
            c2 = tmp;
          }

          var x1 = (coords[p1] + context.offsetX) * context.scaleX;
          var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
          var x2 = (coords[p2] + context.offsetX) * context.scaleX;
          var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
          var x3 = (coords[p3] + context.offsetX) * context.scaleX;
          var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;

          if (y1 >= y3) {
            return;
          }

          var c1r = colors[c1],
              c1g = colors[c1 + 1],
              c1b = colors[c1 + 2];
          var c2r = colors[c2],
              c2g = colors[c2 + 1],
              c2b = colors[c2 + 2];
          var c3r = colors[c3],
              c3g = colors[c3 + 1],
              c3b = colors[c3 + 2];
          var minY = Math.round(y1),
              maxY = Math.round(y3);
          var xa, car, cag, cab;
          var xb, cbr, cbg, cbb;

          for (var y = minY; y <= maxY; y++) {
            if (y < y2) {
              var _k4 = void 0;

              if (y < y1) {
                _k4 = 0;
              } else {
                _k4 = (y1 - y) / (y1 - y2);
              }

              xa = x1 - (x1 - x2) * _k4;
              car = c1r - (c1r - c2r) * _k4;
              cag = c1g - (c1g - c2g) * _k4;
              cab = c1b - (c1b - c2b) * _k4;
            } else {
              var _k5 = void 0;

              if (y > y3) {
                _k5 = 1;
              } else if (y2 === y3) {
                _k5 = 0;
              } else {
                _k5 = (y2 - y) / (y2 - y3);
              }

              xa = x2 - (x2 - x3) * _k5;
              car = c2r - (c2r - c3r) * _k5;
              cag = c2g - (c2g - c3g) * _k5;
              cab = c2b - (c2b - c3b) * _k5;
            }

            var k = void 0;

            if (y < y1) {
              k = 0;
            } else if (y > y3) {
              k = 1;
            } else {
              k = (y1 - y) / (y1 - y3);
            }

            xb = x1 - (x1 - x3) * k;
            cbr = c1r - (c1r - c3r) * k;
            cbg = c1g - (c1g - c3g) * k;
            cbb = c1b - (c1b - c3b) * k;
            var x1_ = Math.round(Math.min(xa, xb));
            var x2_ = Math.round(Math.max(xa, xb));
            var j = rowSize * y + x1_ * 4;

            for (var x = x1_; x <= x2_; x++) {
              k = (xa - x) / (xa - xb);

              if (k < 0) {
                k = 0;
              } else if (k > 1) {
                k = 1;
              }

              bytes[j++] = car - (car - cbr) * k | 0;
              bytes[j++] = cag - (cag - cbg) * k | 0;
              bytes[j++] = cab - (cab - cbb) * k | 0;
              bytes[j++] = 255;
            }
          }
        }

        function drawFigure(data, figure, context) {
          var ps = figure.coords;
          var cs = figure.colors;
          var i, ii;

          switch (figure.type) {
            case "lattice":
              var verticesPerRow = figure.verticesPerRow;
              var rows = Math.floor(ps.length / verticesPerRow) - 1;
              var cols = verticesPerRow - 1;

              for (i = 0; i < rows; i++) {
                var q = i * verticesPerRow;

                for (var j = 0; j < cols; j++, q++) {
                  drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                  drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                }
              }

              break;

            case "triangles":
              for (i = 0, ii = ps.length; i < ii; i += 3) {
                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
              }

              break;

            default:
              throw new Error("illegal figure");
          }
        }

        var MeshShadingPattern = /*#__PURE__*/function (_BaseShadingPattern2) {
          _inherits(MeshShadingPattern, _BaseShadingPattern2);

          var _super18 = _createSuper(MeshShadingPattern);

          function MeshShadingPattern(IR) {
            var _this28;

            _classCallCheck(this, MeshShadingPattern);

            _this28 = _super18.call(this);
            _this28._coords = IR[2];
            _this28._colors = IR[3];
            _this28._figures = IR[4];
            _this28._bounds = IR[5];
            _this28._bbox = IR[7];
            _this28._background = IR[8];
            _this28.matrix = null;
            return _this28;
          }

          _createClass(MeshShadingPattern, [{
            key: "_createMeshCanvas",
            value: function _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
              var EXPECTED_SCALE = 1.1;
              var MAX_PATTERN_SIZE = 3000;
              var BORDER_SIZE = 2;
              var offsetX = Math.floor(this._bounds[0]);
              var offsetY = Math.floor(this._bounds[1]);
              var boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
              var boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
              var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
              var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
              var scaleX = boundsWidth / width;
              var scaleY = boundsHeight / height;
              var context = {
                coords: this._coords,
                colors: this._colors,
                offsetX: -offsetX,
                offsetY: -offsetY,
                scaleX: 1 / scaleX,
                scaleY: 1 / scaleY
              };
              var paddedWidth = width + BORDER_SIZE * 2;
              var paddedHeight = height + BORDER_SIZE * 2;
              var tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false);
              var tmpCtx = tmpCanvas.context;
              var data = tmpCtx.createImageData(width, height);

              if (backgroundColor) {
                var bytes = data.data;

                for (var i = 0, ii = bytes.length; i < ii; i += 4) {
                  bytes[i] = backgroundColor[0];
                  bytes[i + 1] = backgroundColor[1];
                  bytes[i + 2] = backgroundColor[2];
                  bytes[i + 3] = 255;
                }
              }

              var _iterator25 = _createForOfIteratorHelper(this._figures),
                  _step25;

              try {
                for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {
                  var figure = _step25.value;
                  drawFigure(data, figure, context);
                }
              } catch (err) {
                _iterator25.e(err);
              } finally {
                _iterator25.f();
              }

              tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
              var canvas = tmpCanvas.canvas;
              return {
                canvas: canvas,
                offsetX: offsetX - BORDER_SIZE * scaleX,
                offsetY: offsetY - BORDER_SIZE * scaleY,
                scaleX: scaleX,
                scaleY: scaleY
              };
            }
          }, {
            key: "getPattern",
            value: function getPattern(ctx, owner, inverse) {
              var shadingFill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
              applyBoundingBox(ctx, this._bbox);
              var scale;

              if (shadingFill) {
                scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);
              } else {
                scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);

                if (this.matrix) {
                  var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

                  scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];
                }
              }

              var temporaryPatternCanvas = this._createMeshCanvas(scale, shadingFill ? null : this._background, owner.cachedCanvases);

              if (!shadingFill) {
                ctx.setTransform.apply(ctx, owner.baseTransform);

                if (this.matrix) {
                  ctx.transform.apply(ctx, this.matrix);
                }
              }

              ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
              ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
              return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
            }
          }]);

          return MeshShadingPattern;
        }(BaseShadingPattern);

        var DummyShadingPattern = /*#__PURE__*/function (_BaseShadingPattern3) {
          _inherits(DummyShadingPattern, _BaseShadingPattern3);

          var _super19 = _createSuper(DummyShadingPattern);

          function DummyShadingPattern() {
            _classCallCheck(this, DummyShadingPattern);

            return _super19.apply(this, arguments);
          }

          _createClass(DummyShadingPattern, [{
            key: "getPattern",
            value: function getPattern() {
              return "hotpink";
            }
          }]);

          return DummyShadingPattern;
        }(BaseShadingPattern);

        function getShadingPattern(IR, cachedCanvasPatterns) {
          switch (IR[0]) {
            case "RadialAxial":
              return new RadialAxialShadingPattern(IR, cachedCanvasPatterns);

            case "Mesh":
              return new MeshShadingPattern(IR);

            case "Dummy":
              return new DummyShadingPattern();
          }

          throw new Error("Unknown IR type: ".concat(IR[0]));
        }

        var PaintType = {
          COLORED: 1,
          UNCOLORED: 2
        };

        var TilingPattern = /*#__PURE__*/function () {
          function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {
            _classCallCheck(this, TilingPattern);

            this.operatorList = IR[2];
            this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];
            this.bbox = IR[4];
            this.xstep = IR[5];
            this.ystep = IR[6];
            this.paintType = IR[7];
            this.tilingType = IR[8];
            this.color = color;
            this.ctx = ctx;
            this.canvasGraphicsFactory = canvasGraphicsFactory;
            this.baseTransform = baseTransform;
          }

          _createClass(TilingPattern, [{
            key: "createPatternCanvas",
            value: function createPatternCanvas(owner) {
              var operatorList = this.operatorList;
              var bbox = this.bbox;
              var xstep = this.xstep;
              var ystep = this.ystep;
              var paintType = this.paintType;
              var tilingType = this.tilingType;
              var color = this.color;
              var canvasGraphicsFactory = this.canvasGraphicsFactory;
              (0, _util.info)("TilingType: " + tilingType);
              var x0 = bbox[0],
                  y0 = bbox[1],
                  x1 = bbox[2],
                  y1 = bbox[3];

              var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);

              var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);

              var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];
              var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);
              var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);
              var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true);
              var tmpCtx = tmpCanvas.context;
              var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);
              graphics.groupLevel = owner.groupLevel;
              this.setFillAndStrokeStyleToContext(graphics, paintType, color);
              var adjustedX0 = x0;
              var adjustedY0 = y0;
              var adjustedX1 = x1;
              var adjustedY1 = y1;

              if (x0 < 0) {
                adjustedX0 = 0;
                adjustedX1 += Math.abs(x0);
              }

              if (y0 < 0) {
                adjustedY0 = 0;
                adjustedY1 += Math.abs(y0);
              }

              tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));
              graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);
              this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);
              graphics.baseTransform = graphics.ctx.mozCurrentTransform.slice();
              graphics.executeOperatorList(operatorList);
              graphics.endDrawing();
              return {
                canvas: tmpCanvas.canvas,
                scaleX: dimx.scale,
                scaleY: dimy.scale,
                offsetX: adjustedX0,
                offsetY: adjustedY0
              };
            }
          }, {
            key: "getSizeAndScale",
            value: function getSizeAndScale(step, realOutputSize, scale) {
              step = Math.abs(step);
              var maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
              var size = Math.ceil(step * scale);

              if (size >= maxSize) {
                size = maxSize;
              } else {
                scale = size / step;
              }

              return {
                scale: scale,
                size: size
              };
            }
          }, {
            key: "clipBbox",
            value: function clipBbox(graphics, x0, y0, x1, y1) {
              var bboxWidth = x1 - x0;
              var bboxHeight = y1 - y0;
              graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
              graphics.clip();
              graphics.endPath();
            }
          }, {
            key: "setFillAndStrokeStyleToContext",
            value: function setFillAndStrokeStyleToContext(graphics, paintType, color) {
              var context = graphics.ctx,
                  current = graphics.current;

              switch (paintType) {
                case PaintType.COLORED:
                  var ctx = this.ctx;
                  context.fillStyle = ctx.fillStyle;
                  context.strokeStyle = ctx.strokeStyle;
                  current.fillColor = ctx.fillStyle;
                  current.strokeColor = ctx.strokeStyle;
                  break;

                case PaintType.UNCOLORED:
                  var cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);

                  context.fillStyle = cssColor;
                  context.strokeStyle = cssColor;
                  current.fillColor = cssColor;
                  current.strokeColor = cssColor;
                  break;

                default:
                  throw new _util.FormatError("Unsupported paint type: ".concat(paintType));
              }
            }
          }, {
            key: "getPattern",
            value: function getPattern(ctx, owner, inverse) {
              var shadingFill = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
              var matrix = inverse;

              if (!shadingFill) {
                matrix = _util.Util.transform(matrix, owner.baseTransform);

                if (this.matrix) {
                  matrix = _util.Util.transform(matrix, this.matrix);
                }
              }

              var temporaryPatternCanvas = this.createPatternCanvas(owner);
              var domMatrix = new DOMMatrix(matrix);
              domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
              domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
              var pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");

              try {
                pattern.setTransform(domMatrix);
              } catch (ex) {
                (0, _util.warn)("TilingPattern.getPattern: \"".concat(ex === null || ex === void 0 ? void 0 : ex.message, "\"."));
              }

              return pattern;
            }
          }], [{
            key: "MAX_PATTERN_SIZE",
            get: function get() {
              return (0, _util.shadow)(this, "MAX_PATTERN_SIZE", 3000);
            }
          }]);

          return TilingPattern;
        }();

        exports.TilingPattern = TilingPattern;
        /***/
      },
      /* 12 */

      /***/
      function (__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.GlobalWorkerOptions = void 0;
        var GlobalWorkerOptions = Object.create(null);
        exports.GlobalWorkerOptions = GlobalWorkerOptions;
        GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;
        GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;
        /***/
      },
      /* 13 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.MessageHandler = void 0;

        var _util = __w_pdfjs_require__(2);

        var CallbackKind = {
          UNKNOWN: 0,
          DATA: 1,
          ERROR: 2
        };
        var StreamKind = {
          UNKNOWN: 0,
          CANCEL: 1,
          CANCEL_COMPLETE: 2,
          CLOSE: 3,
          ENQUEUE: 4,
          ERROR: 5,
          PULL: 6,
          PULL_COMPLETE: 7,
          START_COMPLETE: 8
        };

        function wrapReason(reason) {
          if (!(reason instanceof Error || _typeof(reason) === "object" && reason !== null)) {
            (0, _util.warn)('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
            return reason;
          }

          switch (reason.name) {
            case "AbortException":
              return new _util.AbortException(reason.message);

            case "MissingPDFException":
              return new _util.MissingPDFException(reason.message);

            case "PasswordException":
              return new _util.PasswordException(reason.message, reason.code);

            case "UnexpectedResponseException":
              return new _util.UnexpectedResponseException(reason.message, reason.status);

            case "UnknownErrorException":
              return new _util.UnknownErrorException(reason.message, reason.details);

            default:
              return new _util.UnknownErrorException(reason.message, reason.toString());
          }
        }

        var MessageHandler = /*#__PURE__*/function () {
          function MessageHandler(sourceName, targetName, comObj) {
            var _this29 = this;

            _classCallCheck(this, MessageHandler);

            this.sourceName = sourceName;
            this.targetName = targetName;
            this.comObj = comObj;
            this.callbackId = 1;
            this.streamId = 1;
            this.postMessageTransfers = true;
            this.streamSinks = Object.create(null);
            this.streamControllers = Object.create(null);
            this.callbackCapabilities = Object.create(null);
            this.actionHandler = Object.create(null);

            this._onComObjOnMessage = function (event) {
              var data = event.data;

              if (data.targetName !== _this29.sourceName) {
                return;
              }

              if (data.stream) {
                _this29._processStreamMessage(data);

                return;
              }

              if (data.callback) {
                var callbackId = data.callbackId;
                var capability = _this29.callbackCapabilities[callbackId];

                if (!capability) {
                  throw new Error("Cannot resolve callback ".concat(callbackId));
                }

                delete _this29.callbackCapabilities[callbackId];

                if (data.callback === CallbackKind.DATA) {
                  capability.resolve(data.data);
                } else if (data.callback === CallbackKind.ERROR) {
                  capability.reject(wrapReason(data.reason));
                } else {
                  throw new Error("Unexpected callback case");
                }

                return;
              }

              var action = _this29.actionHandler[data.action];

              if (!action) {
                throw new Error("Unknown action from worker: ".concat(data.action));
              }

              if (data.callbackId) {
                var cbSourceName = _this29.sourceName;
                var cbTargetName = data.sourceName;
                new Promise(function (resolve) {
                  resolve(action(data.data));
                }).then(function (result) {
                  comObj.postMessage({
                    sourceName: cbSourceName,
                    targetName: cbTargetName,
                    callback: CallbackKind.DATA,
                    callbackId: data.callbackId,
                    data: result
                  });
                }, function (reason) {
                  comObj.postMessage({
                    sourceName: cbSourceName,
                    targetName: cbTargetName,
                    callback: CallbackKind.ERROR,
                    callbackId: data.callbackId,
                    reason: wrapReason(reason)
                  });
                });
                return;
              }

              if (data.streamId) {
                _this29._createStreamSink(data);

                return;
              }

              action(data.data);
            };

            comObj.addEventListener("message", this._onComObjOnMessage);
          }

          _createClass(MessageHandler, [{
            key: "on",
            value: function on(actionName, handler) {
              var ah = this.actionHandler;

              if (ah[actionName]) {
                throw new Error("There is already an actionName called \"".concat(actionName, "\""));
              }

              ah[actionName] = handler;
            }
          }, {
            key: "send",
            value: function send(actionName, data, transfers) {
              this._postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: actionName,
                data: data
              }, transfers);
            }
          }, {
            key: "sendWithPromise",
            value: function sendWithPromise(actionName, data, transfers) {
              var callbackId = this.callbackId++;
              var capability = (0, _util.createPromiseCapability)();
              this.callbackCapabilities[callbackId] = capability;

              try {
                this._postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: actionName,
                  callbackId: callbackId,
                  data: data
                }, transfers);
              } catch (ex) {
                capability.reject(ex);
              }

              return capability.promise;
            }
          }, {
            key: "sendWithStream",
            value: function sendWithStream(actionName, data, queueingStrategy, transfers) {
              var _this30 = this;

              var streamId = this.streamId++,
                  sourceName = this.sourceName,
                  targetName = this.targetName,
                  comObj = this.comObj;
              return new ReadableStream({
                start: function start(controller) {
                  var startCapability = (0, _util.createPromiseCapability)();
                  _this30.streamControllers[streamId] = {
                    controller: controller,
                    startCall: startCapability,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: false
                  };

                  _this30._postMessage({
                    sourceName: sourceName,
                    targetName: targetName,
                    action: actionName,
                    streamId: streamId,
                    data: data,
                    desiredSize: controller.desiredSize
                  }, transfers);

                  return startCapability.promise;
                },
                pull: function pull(controller) {
                  var pullCapability = (0, _util.createPromiseCapability)();
                  _this30.streamControllers[streamId].pullCall = pullCapability;
                  comObj.postMessage({
                    sourceName: sourceName,
                    targetName: targetName,
                    stream: StreamKind.PULL,
                    streamId: streamId,
                    desiredSize: controller.desiredSize
                  });
                  return pullCapability.promise;
                },
                cancel: function cancel(reason) {
                  (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason");
                  var cancelCapability = (0, _util.createPromiseCapability)();
                  _this30.streamControllers[streamId].cancelCall = cancelCapability;
                  _this30.streamControllers[streamId].isClosed = true;
                  comObj.postMessage({
                    sourceName: sourceName,
                    targetName: targetName,
                    stream: StreamKind.CANCEL,
                    streamId: streamId,
                    reason: wrapReason(reason)
                  });
                  return cancelCapability.promise;
                }
              }, queueingStrategy);
            }
          }, {
            key: "_createStreamSink",
            value: function _createStreamSink(data) {
              var streamId = data.streamId,
                  sourceName = this.sourceName,
                  targetName = data.sourceName,
                  comObj = this.comObj;
              var self = this,
                  action = this.actionHandler[data.action];
              var streamSink = {
                enqueue: function enqueue(chunk) {
                  var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                  var transfers = arguments.length > 2 ? arguments[2] : undefined;

                  if (this.isCancelled) {
                    return;
                  }

                  var lastDesiredSize = this.desiredSize;
                  this.desiredSize -= size;

                  if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                    this.sinkCapability = (0, _util.createPromiseCapability)();
                    this.ready = this.sinkCapability.promise;
                  }

                  self._postMessage({
                    sourceName: sourceName,
                    targetName: targetName,
                    stream: StreamKind.ENQUEUE,
                    streamId: streamId,
                    chunk: chunk
                  }, transfers);
                },
                close: function close() {
                  if (this.isCancelled) {
                    return;
                  }

                  this.isCancelled = true;
                  comObj.postMessage({
                    sourceName: sourceName,
                    targetName: targetName,
                    stream: StreamKind.CLOSE,
                    streamId: streamId
                  });
                  delete self.streamSinks[streamId];
                },
                error: function error(reason) {
                  (0, _util.assert)(reason instanceof Error, "error must have a valid reason");

                  if (this.isCancelled) {
                    return;
                  }

                  this.isCancelled = true;
                  comObj.postMessage({
                    sourceName: sourceName,
                    targetName: targetName,
                    stream: StreamKind.ERROR,
                    streamId: streamId,
                    reason: wrapReason(reason)
                  });
                },
                sinkCapability: (0, _util.createPromiseCapability)(),
                onPull: null,
                onCancel: null,
                isCancelled: false,
                desiredSize: data.desiredSize,
                ready: null
              };
              streamSink.sinkCapability.resolve();
              streamSink.ready = streamSink.sinkCapability.promise;
              this.streamSinks[streamId] = streamSink;
              new Promise(function (resolve) {
                resolve(action(data.data, streamSink));
              }).then(function () {
                comObj.postMessage({
                  sourceName: sourceName,
                  targetName: targetName,
                  stream: StreamKind.START_COMPLETE,
                  streamId: streamId,
                  success: true
                });
              }, function (reason) {
                comObj.postMessage({
                  sourceName: sourceName,
                  targetName: targetName,
                  stream: StreamKind.START_COMPLETE,
                  streamId: streamId,
                  reason: wrapReason(reason)
                });
              });
            }
          }, {
            key: "_processStreamMessage",
            value: function _processStreamMessage(data) {
              var streamId = data.streamId,
                  sourceName = this.sourceName,
                  targetName = data.sourceName,
                  comObj = this.comObj;
              var streamController = this.streamControllers[streamId],
                  streamSink = this.streamSinks[streamId];

              switch (data.stream) {
                case StreamKind.START_COMPLETE:
                  if (data.success) {
                    streamController.startCall.resolve();
                  } else {
                    streamController.startCall.reject(wrapReason(data.reason));
                  }

                  break;

                case StreamKind.PULL_COMPLETE:
                  if (data.success) {
                    streamController.pullCall.resolve();
                  } else {
                    streamController.pullCall.reject(wrapReason(data.reason));
                  }

                  break;

                case StreamKind.PULL:
                  if (!streamSink) {
                    comObj.postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      stream: StreamKind.PULL_COMPLETE,
                      streamId: streamId,
                      success: true
                    });
                    break;
                  }

                  if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                    streamSink.sinkCapability.resolve();
                  }

                  streamSink.desiredSize = data.desiredSize;
                  new Promise(function (resolve) {
                    resolve(streamSink.onPull && streamSink.onPull());
                  }).then(function () {
                    comObj.postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      stream: StreamKind.PULL_COMPLETE,
                      streamId: streamId,
                      success: true
                    });
                  }, function (reason) {
                    comObj.postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      stream: StreamKind.PULL_COMPLETE,
                      streamId: streamId,
                      reason: wrapReason(reason)
                    });
                  });
                  break;

                case StreamKind.ENQUEUE:
                  (0, _util.assert)(streamController, "enqueue should have stream controller");

                  if (streamController.isClosed) {
                    break;
                  }

                  streamController.controller.enqueue(data.chunk);
                  break;

                case StreamKind.CLOSE:
                  (0, _util.assert)(streamController, "close should have stream controller");

                  if (streamController.isClosed) {
                    break;
                  }

                  streamController.isClosed = true;
                  streamController.controller.close();

                  this._deleteStreamController(streamController, streamId);

                  break;

                case StreamKind.ERROR:
                  (0, _util.assert)(streamController, "error should have stream controller");
                  streamController.controller.error(wrapReason(data.reason));

                  this._deleteStreamController(streamController, streamId);

                  break;

                case StreamKind.CANCEL_COMPLETE:
                  if (data.success) {
                    streamController.cancelCall.resolve();
                  } else {
                    streamController.cancelCall.reject(wrapReason(data.reason));
                  }

                  this._deleteStreamController(streamController, streamId);

                  break;

                case StreamKind.CANCEL:
                  if (!streamSink) {
                    break;
                  }

                  new Promise(function (resolve) {
                    resolve(streamSink.onCancel && streamSink.onCancel(wrapReason(data.reason)));
                  }).then(function () {
                    comObj.postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      stream: StreamKind.CANCEL_COMPLETE,
                      streamId: streamId,
                      success: true
                    });
                  }, function (reason) {
                    comObj.postMessage({
                      sourceName: sourceName,
                      targetName: targetName,
                      stream: StreamKind.CANCEL_COMPLETE,
                      streamId: streamId,
                      reason: wrapReason(reason)
                    });
                  });
                  streamSink.sinkCapability.reject(wrapReason(data.reason));
                  streamSink.isCancelled = true;
                  delete this.streamSinks[streamId];
                  break;

                default:
                  throw new Error("Unexpected stream case");
              }
            }
          }, {
            key: "_deleteStreamController",
            value: function () {
              var _deleteStreamController2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(streamController, streamId) {
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        _context11.next = 2;
                        return Promise.allSettled([streamController.startCall && streamController.startCall.promise, streamController.pullCall && streamController.pullCall.promise, streamController.cancelCall && streamController.cancelCall.promise]);

                      case 2:
                        delete this.streamControllers[streamId];

                      case 3:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _callee11, this);
              }));

              function _deleteStreamController(_x9, _x10) {
                return _deleteStreamController2.apply(this, arguments);
              }

              return _deleteStreamController;
            }()
          }, {
            key: "_postMessage",
            value: function _postMessage(message, transfers) {
              if (transfers && this.postMessageTransfers) {
                this.comObj.postMessage(message, transfers);
              } else {
                this.comObj.postMessage(message);
              }
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }]);

          return MessageHandler;
        }();

        exports.MessageHandler = MessageHandler;
        /***/
      },
      /* 14 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.Metadata = void 0;

        var _util = __w_pdfjs_require__(2);

        var Metadata = /*#__PURE__*/function () {
          function Metadata(_ref36) {
            var parsedData = _ref36.parsedData,
                rawData = _ref36.rawData;

            _classCallCheck(this, Metadata);

            this._metadataMap = parsedData;
            this._data = rawData;
          }

          _createClass(Metadata, [{
            key: "getRaw",
            value: function getRaw() {
              return this._data;
            }
          }, {
            key: "get",
            value: function get(name) {
              var _this$_metadataMap$ge;

              return (_this$_metadataMap$ge = this._metadataMap.get(name)) !== null && _this$_metadataMap$ge !== void 0 ? _this$_metadataMap$ge : null;
            }
          }, {
            key: "getAll",
            value: function getAll() {
              return (0, _util.objectFromMap)(this._metadataMap);
            }
          }, {
            key: "has",
            value: function has(name) {
              return this._metadataMap.has(name);
            }
          }]);

          return Metadata;
        }();

        exports.Metadata = Metadata;
        /***/
      },
      /* 15 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.OptionalContentConfig = void 0;

        var _util = __w_pdfjs_require__(2);

        var OptionalContentGroup = /*#__PURE__*/_createClass(function OptionalContentGroup(name, intent) {
          _classCallCheck(this, OptionalContentGroup);

          this.visible = true;
          this.name = name;
          this.intent = intent;
        });

        var OptionalContentConfig = /*#__PURE__*/function () {
          function OptionalContentConfig(data) {
            _classCallCheck(this, OptionalContentConfig);

            this.name = null;
            this.creator = null;
            this._order = null;
            this._groups = new Map();

            if (data === null) {
              return;
            }

            this.name = data.name;
            this.creator = data.creator;
            this._order = data.order;

            var _iterator26 = _createForOfIteratorHelper(data.groups),
                _step26;

            try {
              for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {
                var _group = _step26.value;

                this._groups.set(_group.id, new OptionalContentGroup(_group.name, _group.intent));
              }
            } catch (err) {
              _iterator26.e(err);
            } finally {
              _iterator26.f();
            }

            if (data.baseState === "OFF") {
              var _iterator27 = _createForOfIteratorHelper(this._groups),
                  _step27;

              try {
                for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {
                  var group = _step27.value;
                  group.visible = false;
                }
              } catch (err) {
                _iterator27.e(err);
              } finally {
                _iterator27.f();
              }
            }

            var _iterator28 = _createForOfIteratorHelper(data.on),
                _step28;

            try {
              for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {
                var on = _step28.value;
                this._groups.get(on).visible = true;
              }
            } catch (err) {
              _iterator28.e(err);
            } finally {
              _iterator28.f();
            }

            var _iterator29 = _createForOfIteratorHelper(data.off),
                _step29;

            try {
              for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {
                var off = _step29.value;
                this._groups.get(off).visible = false;
              }
            } catch (err) {
              _iterator29.e(err);
            } finally {
              _iterator29.f();
            }
          }

          _createClass(OptionalContentConfig, [{
            key: "_evaluateVisibilityExpression",
            value: function _evaluateVisibilityExpression(array) {
              var length = array.length;

              if (length < 2) {
                return true;
              }

              var operator = array[0];

              for (var i = 1; i < length; i++) {
                var element = array[i];
                var state = void 0;

                if (Array.isArray(element)) {
                  state = this._evaluateVisibilityExpression(element);
                } else if (this._groups.has(element)) {
                  state = this._groups.get(element).visible;
                } else {
                  (0, _util.warn)("Optional content group not found: ".concat(element));
                  return true;
                }

                switch (operator) {
                  case "And":
                    if (!state) {
                      return false;
                    }

                    break;

                  case "Or":
                    if (state) {
                      return true;
                    }

                    break;

                  case "Not":
                    return !state;

                  default:
                    return true;
                }
              }

              return operator === "And";
            }
          }, {
            key: "isVisible",
            value: function isVisible(group) {
              if (this._groups.size === 0) {
                return true;
              }

              if (!group) {
                (0, _util.warn)("Optional content group not defined.");
                return true;
              }

              if (group.type === "OCG") {
                if (!this._groups.has(group.id)) {
                  (0, _util.warn)("Optional content group not found: ".concat(group.id));
                  return true;
                }

                return this._groups.get(group.id).visible;
              } else if (group.type === "OCMD") {
                if (group.expression) {
                  return this._evaluateVisibilityExpression(group.expression);
                }

                if (!group.policy || group.policy === "AnyOn") {
                  var _iterator30 = _createForOfIteratorHelper(group.ids),
                      _step30;

                  try {
                    for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {
                      var id = _step30.value;

                      if (!this._groups.has(id)) {
                        (0, _util.warn)("Optional content group not found: ".concat(id));
                        return true;
                      }

                      if (this._groups.get(id).visible) {
                        return true;
                      }
                    }
                  } catch (err) {
                    _iterator30.e(err);
                  } finally {
                    _iterator30.f();
                  }

                  return false;
                } else if (group.policy === "AllOn") {
                  var _iterator31 = _createForOfIteratorHelper(group.ids),
                      _step31;

                  try {
                    for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {
                      var _id = _step31.value;

                      if (!this._groups.has(_id)) {
                        (0, _util.warn)("Optional content group not found: ".concat(_id));
                        return true;
                      }

                      if (!this._groups.get(_id).visible) {
                        return false;
                      }
                    }
                  } catch (err) {
                    _iterator31.e(err);
                  } finally {
                    _iterator31.f();
                  }

                  return true;
                } else if (group.policy === "AnyOff") {
                  var _iterator32 = _createForOfIteratorHelper(group.ids),
                      _step32;

                  try {
                    for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {
                      var _id2 = _step32.value;

                      if (!this._groups.has(_id2)) {
                        (0, _util.warn)("Optional content group not found: ".concat(_id2));
                        return true;
                      }

                      if (!this._groups.get(_id2).visible) {
                        return true;
                      }
                    }
                  } catch (err) {
                    _iterator32.e(err);
                  } finally {
                    _iterator32.f();
                  }

                  return false;
                } else if (group.policy === "AllOff") {
                  var _iterator33 = _createForOfIteratorHelper(group.ids),
                      _step33;

                  try {
                    for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {
                      var _id3 = _step33.value;

                      if (!this._groups.has(_id3)) {
                        (0, _util.warn)("Optional content group not found: ".concat(_id3));
                        return true;
                      }

                      if (this._groups.get(_id3).visible) {
                        return false;
                      }
                    }
                  } catch (err) {
                    _iterator33.e(err);
                  } finally {
                    _iterator33.f();
                  }

                  return true;
                }

                (0, _util.warn)("Unknown optional content policy ".concat(group.policy, "."));
                return true;
              }

              (0, _util.warn)("Unknown group type ".concat(group.type, "."));
              return true;
            }
          }, {
            key: "setVisibility",
            value: function setVisibility(id) {
              var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

              if (!this._groups.has(id)) {
                (0, _util.warn)("Optional content group not found: ".concat(id));
                return;
              }

              this._groups.get(id).visible = !!visible;
            }
          }, {
            key: "getOrder",
            value: function getOrder() {
              if (!this._groups.size) {
                return null;
              }

              if (this._order) {
                return this._order.slice();
              }

              return Array.from(this._groups.keys());
            }
          }, {
            key: "getGroups",
            value: function getGroups() {
              return this._groups.size > 0 ? (0, _util.objectFromMap)(this._groups) : null;
            }
          }, {
            key: "getGroup",
            value: function getGroup(id) {
              return this._groups.get(id) || null;
            }
          }]);

          return OptionalContentConfig;
        }();

        exports.OptionalContentConfig = OptionalContentConfig;
        /***/
      },
      /* 16 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFDataTransportStream = void 0;

        var _util = __w_pdfjs_require__(2);

        var _display_utils = __w_pdfjs_require__(1);

        var PDFDataTransportStream = /*#__PURE__*/function () {
          function PDFDataTransportStream(params, pdfDataRangeTransport) {
            var _this31 = this;

            _classCallCheck(this, PDFDataTransportStream);

            (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
            this._queuedChunks = [];
            this._progressiveDone = params.progressiveDone || false;
            this._contentDispositionFilename = params.contentDispositionFilename || null;
            var initialData = params.initialData;

            if ((initialData === null || initialData === void 0 ? void 0 : initialData.length) > 0) {
              var buffer = new Uint8Array(initialData).buffer;

              this._queuedChunks.push(buffer);
            }

            this._pdfDataRangeTransport = pdfDataRangeTransport;
            this._isStreamingSupported = !params.disableStream;
            this._isRangeSupported = !params.disableRange;
            this._contentLength = params.length;
            this._fullRequestReader = null;
            this._rangeReaders = [];

            this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) {
              _this31._onReceiveData({
                begin: begin,
                chunk: chunk
              });
            });

            this._pdfDataRangeTransport.addProgressListener(function (loaded, total) {
              _this31._onProgress({
                loaded: loaded,
                total: total
              });
            });

            this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {
              _this31._onReceiveData({
                chunk: chunk
              });
            });

            this._pdfDataRangeTransport.addProgressiveDoneListener(function () {
              _this31._onProgressiveDone();
            });

            this._pdfDataRangeTransport.transportReady();
          }

          _createClass(PDFDataTransportStream, [{
            key: "_onReceiveData",
            value: function _onReceiveData(args) {
              var buffer = new Uint8Array(args.chunk).buffer;

              if (args.begin === undefined) {
                if (this._fullRequestReader) {
                  this._fullRequestReader._enqueue(buffer);
                } else {
                  this._queuedChunks.push(buffer);
                }
              } else {
                var found = this._rangeReaders.some(function (rangeReader) {
                  if (rangeReader._begin !== args.begin) {
                    return false;
                  }

                  rangeReader._enqueue(buffer);

                  return true;
                });

                (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
              }
            }
          }, {
            key: "_progressiveDataLength",
            get: function get() {
              var _this$_fullRequestRea, _this$_fullRequestRea2;

              return (_this$_fullRequestRea = (_this$_fullRequestRea2 = this._fullRequestReader) === null || _this$_fullRequestRea2 === void 0 ? void 0 : _this$_fullRequestRea2._loaded) !== null && _this$_fullRequestRea !== void 0 ? _this$_fullRequestRea : 0;
            }
          }, {
            key: "_onProgress",
            value: function _onProgress(evt) {
              if (evt.total === undefined) {
                var firstReader = this._rangeReaders[0];

                if (firstReader !== null && firstReader !== void 0 && firstReader.onProgress) {
                  firstReader.onProgress({
                    loaded: evt.loaded
                  });
                }
              } else {
                var fullReader = this._fullRequestReader;

                if (fullReader !== null && fullReader !== void 0 && fullReader.onProgress) {
                  fullReader.onProgress({
                    loaded: evt.loaded,
                    total: evt.total
                  });
                }
              }
            }
          }, {
            key: "_onProgressiveDone",
            value: function _onProgressiveDone() {
              if (this._fullRequestReader) {
                this._fullRequestReader.progressiveDone();
              }

              this._progressiveDone = true;
            }
          }, {
            key: "_removeRangeReader",
            value: function _removeRangeReader(reader) {
              var i = this._rangeReaders.indexOf(reader);

              if (i >= 0) {
                this._rangeReaders.splice(i, 1);
              }
            }
          }, {
            key: "getFullReader",
            value: function getFullReader() {
              (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
              var queuedChunks = this._queuedChunks;
              this._queuedChunks = null;
              return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
            }
          }, {
            key: "getRangeReader",
            value: function getRangeReader(begin, end) {
              if (end <= this._progressiveDataLength) {
                return null;
              }

              var reader = new PDFDataTransportStreamRangeReader(this, begin, end);

              this._pdfDataRangeTransport.requestDataRange(begin, end);

              this._rangeReaders.push(reader);

              return reader;
            }
          }, {
            key: "cancelAllRequests",
            value: function cancelAllRequests(reason) {
              if (this._fullRequestReader) {
                this._fullRequestReader.cancel(reason);
              }

              var _iterator34 = _createForOfIteratorHelper(this._rangeReaders.slice(0)),
                  _step34;

              try {
                for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {
                  var reader = _step34.value;
                  reader.cancel(reason);
                }
              } catch (err) {
                _iterator34.e(err);
              } finally {
                _iterator34.f();
              }

              this._pdfDataRangeTransport.abort();
            }
          }]);

          return PDFDataTransportStream;
        }();

        exports.PDFDataTransportStream = PDFDataTransportStream;

        var PDFDataTransportStreamReader = /*#__PURE__*/function () {
          function PDFDataTransportStreamReader(stream, queuedChunks) {
            var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
            var contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

            _classCallCheck(this, PDFDataTransportStreamReader);

            this._stream = stream;
            this._done = progressiveDone || false;
            this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;
            this._queuedChunks = queuedChunks || [];
            this._loaded = 0;

            var _iterator35 = _createForOfIteratorHelper(this._queuedChunks),
                _step35;

            try {
              for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {
                var chunk = _step35.value;
                this._loaded += chunk.byteLength;
              }
            } catch (err) {
              _iterator35.e(err);
            } finally {
              _iterator35.f();
            }

            this._requests = [];
            this._headersReady = Promise.resolve();
            stream._fullRequestReader = this;
            this.onProgress = null;
          }

          _createClass(PDFDataTransportStreamReader, [{
            key: "_enqueue",
            value: function _enqueue(chunk) {
              if (this._done) {
                return;
              }

              if (this._requests.length > 0) {
                var requestCapability = this._requests.shift();

                requestCapability.resolve({
                  value: chunk,
                  done: false
                });
              } else {
                this._queuedChunks.push(chunk);
              }

              this._loaded += chunk.byteLength;
            }
          }, {
            key: "headersReady",
            get: function get() {
              return this._headersReady;
            }
          }, {
            key: "filename",
            get: function get() {
              return this._filename;
            }
          }, {
            key: "isRangeSupported",
            get: function get() {
              return this._stream._isRangeSupported;
            }
          }, {
            key: "isStreamingSupported",
            get: function get() {
              return this._stream._isStreamingSupported;
            }
          }, {
            key: "contentLength",
            get: function get() {
              return this._stream._contentLength;
            }
          }, {
            key: "read",
            value: function () {
              var _read = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                var chunk, requestCapability;
                return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                  while (1) {
                    switch (_context12.prev = _context12.next) {
                      case 0:
                        if (!(this._queuedChunks.length > 0)) {
                          _context12.next = 3;
                          break;
                        }

                        chunk = this._queuedChunks.shift();
                        return _context12.abrupt("return", {
                          value: chunk,
                          done: false
                        });

                      case 3:
                        if (!this._done) {
                          _context12.next = 5;
                          break;
                        }

                        return _context12.abrupt("return", {
                          value: undefined,
                          done: true
                        });

                      case 5:
                        requestCapability = (0, _util.createPromiseCapability)();

                        this._requests.push(requestCapability);

                        return _context12.abrupt("return", requestCapability.promise);

                      case 8:
                      case "end":
                        return _context12.stop();
                    }
                  }
                }, _callee12, this);
              }));

              function read() {
                return _read.apply(this, arguments);
              }

              return read;
            }()
          }, {
            key: "cancel",
            value: function cancel(reason) {
              this._done = true;

              var _iterator36 = _createForOfIteratorHelper(this._requests),
                  _step36;

              try {
                for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {
                  var requestCapability = _step36.value;
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                }
              } catch (err) {
                _iterator36.e(err);
              } finally {
                _iterator36.f();
              }

              this._requests.length = 0;
            }
          }, {
            key: "progressiveDone",
            value: function progressiveDone() {
              if (this._done) {
                return;
              }

              this._done = true;
            }
          }]);

          return PDFDataTransportStreamReader;
        }();

        var PDFDataTransportStreamRangeReader = /*#__PURE__*/function () {
          function PDFDataTransportStreamRangeReader(stream, begin, end) {
            _classCallCheck(this, PDFDataTransportStreamRangeReader);

            this._stream = stream;
            this._begin = begin;
            this._end = end;
            this._queuedChunk = null;
            this._requests = [];
            this._done = false;
            this.onProgress = null;
          }

          _createClass(PDFDataTransportStreamRangeReader, [{
            key: "_enqueue",
            value: function _enqueue(chunk) {
              if (this._done) {
                return;
              }

              if (this._requests.length === 0) {
                this._queuedChunk = chunk;
              } else {
                var requestsCapability = this._requests.shift();

                requestsCapability.resolve({
                  value: chunk,
                  done: false
                });

                var _iterator37 = _createForOfIteratorHelper(this._requests),
                    _step37;

                try {
                  for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {
                    var requestCapability = _step37.value;
                    requestCapability.resolve({
                      value: undefined,
                      done: true
                    });
                  }
                } catch (err) {
                  _iterator37.e(err);
                } finally {
                  _iterator37.f();
                }

                this._requests.length = 0;
              }

              this._done = true;

              this._stream._removeRangeReader(this);
            }
          }, {
            key: "isStreamingSupported",
            get: function get() {
              return false;
            }
          }, {
            key: "read",
            value: function () {
              var _read2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
                var chunk, requestCapability;
                return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                  while (1) {
                    switch (_context13.prev = _context13.next) {
                      case 0:
                        if (!this._queuedChunk) {
                          _context13.next = 4;
                          break;
                        }

                        chunk = this._queuedChunk;
                        this._queuedChunk = null;
                        return _context13.abrupt("return", {
                          value: chunk,
                          done: false
                        });

                      case 4:
                        if (!this._done) {
                          _context13.next = 6;
                          break;
                        }

                        return _context13.abrupt("return", {
                          value: undefined,
                          done: true
                        });

                      case 6:
                        requestCapability = (0, _util.createPromiseCapability)();

                        this._requests.push(requestCapability);

                        return _context13.abrupt("return", requestCapability.promise);

                      case 9:
                      case "end":
                        return _context13.stop();
                    }
                  }
                }, _callee13, this);
              }));

              function read() {
                return _read2.apply(this, arguments);
              }

              return read;
            }()
          }, {
            key: "cancel",
            value: function cancel(reason) {
              this._done = true;

              var _iterator38 = _createForOfIteratorHelper(this._requests),
                  _step38;

              try {
                for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {
                  var requestCapability = _step38.value;
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                }
              } catch (err) {
                _iterator38.e(err);
              } finally {
                _iterator38.f();
              }

              this._requests.length = 0;

              this._stream._removeRangeReader(this);
            }
          }]);

          return PDFDataTransportStreamRangeReader;
        }();
        /***/

      },
      /* 17 */

      /***/
      function (__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.XfaText = void 0;

        var XfaText = /*#__PURE__*/function () {
          function XfaText() {
            _classCallCheck(this, XfaText);
          }

          _createClass(XfaText, null, [{
            key: "textContent",
            value: function textContent(xfa) {
              var items = [];
              var output = {
                items: items,
                styles: Object.create(null)
              };

              function walk(node) {
                var _node$attributes;

                if (!node) {
                  return;
                }

                var str = null;
                var name = node.name;

                if (name === "#text") {
                  str = node.value;
                } else if (!XfaText.shouldBuildText(name)) {
                  return;
                } else if (node !== null && node !== void 0 && (_node$attributes = node.attributes) !== null && _node$attributes !== void 0 && _node$attributes.textContent) {
                  str = node.attributes.textContent;
                } else if (node.value) {
                  str = node.value;
                }

                if (str !== null) {
                  items.push({
                    str: str
                  });
                }

                if (!node.children) {
                  return;
                }

                var _iterator39 = _createForOfIteratorHelper(node.children),
                    _step39;

                try {
                  for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {
                    var child = _step39.value;
                    walk(child);
                  }
                } catch (err) {
                  _iterator39.e(err);
                } finally {
                  _iterator39.f();
                }
              }

              walk(xfa);
              return output;
            }
          }, {
            key: "shouldBuildText",
            value: function shouldBuildText(name) {
              return !(name === "textarea" || name === "input" || name === "option" || name === "select");
            }
          }]);

          return XfaText;
        }();

        exports.XfaText = XfaText;
        /***/
      },
      /* 18 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.AnnotationLayer = void 0;

        var _util = __w_pdfjs_require__(2);

        var _display_utils = __w_pdfjs_require__(1);

        var _annotation_storage = __w_pdfjs_require__(9);

        var _scripting_utils = __w_pdfjs_require__(19);

        var DEFAULT_TAB_INDEX = 1000;
        var GetElementsByNameSet = new WeakSet();

        var AnnotationElementFactory = /*#__PURE__*/function () {
          function AnnotationElementFactory() {
            _classCallCheck(this, AnnotationElementFactory);
          }

          _createClass(AnnotationElementFactory, null, [{
            key: "create",
            value: function create(parameters) {
              var subtype = parameters.data.annotationType;

              switch (subtype) {
                case _util.AnnotationType.LINK:
                  return new LinkAnnotationElement(parameters);

                case _util.AnnotationType.TEXT:
                  return new TextAnnotationElement(parameters);

                case _util.AnnotationType.WIDGET:
                  var fieldType = parameters.data.fieldType;

                  switch (fieldType) {
                    case "Tx":
                      return new TextWidgetAnnotationElement(parameters);

                    case "Btn":
                      if (parameters.data.radioButton) {
                        return new RadioButtonWidgetAnnotationElement(parameters);
                      } else if (parameters.data.checkBox) {
                        return new CheckboxWidgetAnnotationElement(parameters);
                      }

                      return new PushButtonWidgetAnnotationElement(parameters);

                    case "Ch":
                      return new ChoiceWidgetAnnotationElement(parameters);
                  }

                  return new WidgetAnnotationElement(parameters);

                case _util.AnnotationType.POPUP:
                  return new PopupAnnotationElement(parameters);

                case _util.AnnotationType.FREETEXT:
                  return new FreeTextAnnotationElement(parameters);

                case _util.AnnotationType.LINE:
                  return new LineAnnotationElement(parameters);

                case _util.AnnotationType.SQUARE:
                  return new SquareAnnotationElement(parameters);

                case _util.AnnotationType.CIRCLE:
                  return new CircleAnnotationElement(parameters);

                case _util.AnnotationType.POLYLINE:
                  return new PolylineAnnotationElement(parameters);

                case _util.AnnotationType.CARET:
                  return new CaretAnnotationElement(parameters);

                case _util.AnnotationType.INK:
                  return new InkAnnotationElement(parameters);

                case _util.AnnotationType.POLYGON:
                  return new PolygonAnnotationElement(parameters);

                case _util.AnnotationType.HIGHLIGHT:
                  return new HighlightAnnotationElement(parameters);

                case _util.AnnotationType.UNDERLINE:
                  return new UnderlineAnnotationElement(parameters);

                case _util.AnnotationType.SQUIGGLY:
                  return new SquigglyAnnotationElement(parameters);

                case _util.AnnotationType.STRIKEOUT:
                  return new StrikeOutAnnotationElement(parameters);

                case _util.AnnotationType.STAMP:
                  return new StampAnnotationElement(parameters);

                case _util.AnnotationType.FILEATTACHMENT:
                  return new FileAttachmentAnnotationElement(parameters);

                default:
                  return new AnnotationElement(parameters);
              }
            }
          }]);

          return AnnotationElementFactory;
        }();

        var AnnotationElement = /*#__PURE__*/function () {
          function AnnotationElement(parameters) {
            var _ref37 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                _ref37$isRenderable = _ref37.isRenderable,
                isRenderable = _ref37$isRenderable === void 0 ? false : _ref37$isRenderable,
                _ref37$ignoreBorder = _ref37.ignoreBorder,
                ignoreBorder = _ref37$ignoreBorder === void 0 ? false : _ref37$ignoreBorder,
                _ref37$createQuadrila = _ref37.createQuadrilaterals,
                createQuadrilaterals = _ref37$createQuadrila === void 0 ? false : _ref37$createQuadrila;

            _classCallCheck(this, AnnotationElement);

            this.isRenderable = isRenderable;
            this.data = parameters.data;
            this.layer = parameters.layer;
            this.page = parameters.page;
            this.viewport = parameters.viewport;
            this.linkService = parameters.linkService;
            this.downloadManager = parameters.downloadManager;
            this.imageResourcesPath = parameters.imageResourcesPath;
            this.renderForms = parameters.renderForms;
            this.svgFactory = parameters.svgFactory;
            this.annotationStorage = parameters.annotationStorage;
            this.enableScripting = parameters.enableScripting;
            this.hasJSActions = parameters.hasJSActions;
            this._fieldObjects = parameters.fieldObjects;
            this._mouseState = parameters.mouseState;

            if (isRenderable) {
              this.container = this._createContainer(ignoreBorder);
            }

            if (createQuadrilaterals) {
              this.quadrilaterals = this._createQuadrilaterals(ignoreBorder);
            }
          }

          _createClass(AnnotationElement, [{
            key: "_createContainer",
            value: function _createContainer() {
              var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              var data = this.data,
                  page = this.page,
                  viewport = this.viewport;
              var container = document.createElement("section");
              var width = data.rect[2] - data.rect[0];
              var height = data.rect[3] - data.rect[1];
              container.setAttribute("data-annotation-id", data.id);

              var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);

              container.style.transform = "matrix(".concat(viewport.transform.join(","), ")");
              container.style.transformOrigin = "".concat(-rect[0], "px ").concat(-rect[1], "px");

              if (!ignoreBorder && data.borderStyle.width > 0) {
                container.style.borderWidth = "".concat(data.borderStyle.width, "px");

                if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {
                  width -= 2 * data.borderStyle.width;
                  height -= 2 * data.borderStyle.width;
                }

                var horizontalRadius = data.borderStyle.horizontalCornerRadius;
                var verticalRadius = data.borderStyle.verticalCornerRadius;

                if (horizontalRadius > 0 || verticalRadius > 0) {
                  var radius = "".concat(horizontalRadius, "px / ").concat(verticalRadius, "px");
                  container.style.borderRadius = radius;
                }

                switch (data.borderStyle.style) {
                  case _util.AnnotationBorderStyleType.SOLID:
                    container.style.borderStyle = "solid";
                    break;

                  case _util.AnnotationBorderStyleType.DASHED:
                    container.style.borderStyle = "dashed";
                    break;

                  case _util.AnnotationBorderStyleType.BEVELED:
                    (0, _util.warn)("Unimplemented border style: beveled");
                    break;

                  case _util.AnnotationBorderStyleType.INSET:
                    (0, _util.warn)("Unimplemented border style: inset");
                    break;

                  case _util.AnnotationBorderStyleType.UNDERLINE:
                    container.style.borderBottomStyle = "solid";
                    break;

                  default:
                    break;
                }

                var borderColor = data.borderColor || data.color || null;

                if (borderColor) {
                  container.style.borderColor = _util.Util.makeHexColor(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);
                } else {
                  container.style.borderWidth = 0;
                }
              }

              container.style.left = "".concat(rect[0], "px");
              container.style.top = "".concat(rect[1], "px");
              container.style.width = "".concat(width, "px");
              container.style.height = "".concat(height, "px");
              return container;
            }
          }, {
            key: "_createQuadrilaterals",
            value: function _createQuadrilaterals() {
              var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

              if (!this.data.quadPoints) {
                return null;
              }

              var quadrilaterals = [];
              var savedRect = this.data.rect;

              var _iterator40 = _createForOfIteratorHelper(this.data.quadPoints),
                  _step40;

              try {
                for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {
                  var quadPoint = _step40.value;
                  this.data.rect = [quadPoint[2].x, quadPoint[2].y, quadPoint[1].x, quadPoint[1].y];
                  quadrilaterals.push(this._createContainer(ignoreBorder));
                }
              } catch (err) {
                _iterator40.e(err);
              } finally {
                _iterator40.f();
              }

              this.data.rect = savedRect;
              return quadrilaterals;
            }
          }, {
            key: "_createPopup",
            value: function _createPopup(trigger, data) {
              var container = this.container;

              if (this.quadrilaterals) {
                trigger = trigger || this.quadrilaterals;
                container = this.quadrilaterals[0];
              }

              if (!trigger) {
                trigger = document.createElement("div");
                trigger.style.height = container.style.height;
                trigger.style.width = container.style.width;
                container.appendChild(trigger);
              }

              var popupElement = new PopupElement({
                container: container,
                trigger: trigger,
                color: data.color,
                titleObj: data.titleObj,
                modificationDate: data.modificationDate,
                contentsObj: data.contentsObj,
                hideWrapper: true
              });
              var popup = popupElement.render();
              popup.style.left = container.style.width;
              container.appendChild(popup);
            }
          }, {
            key: "_renderQuadrilaterals",
            value: function _renderQuadrilaterals(className) {
              var _iterator41 = _createForOfIteratorHelper(this.quadrilaterals),
                  _step41;

              try {
                for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {
                  var quadrilateral = _step41.value;
                  quadrilateral.className = className;
                }
              } catch (err) {
                _iterator41.e(err);
              } finally {
                _iterator41.f();
              }

              return this.quadrilaterals;
            }
          }, {
            key: "render",
            value: function render() {
              (0, _util.unreachable)("Abstract method `AnnotationElement.render` called");
            }
          }, {
            key: "_getElementsByName",
            value: function _getElementsByName(name) {
              var skipId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              var fields = [];

              if (this._fieldObjects) {
                var fieldObj = this._fieldObjects[name];

                if (fieldObj) {
                  var _iterator42 = _createForOfIteratorHelper(fieldObj),
                      _step42;

                  try {
                    for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {
                      var _step42$value = _step42.value,
                          page = _step42$value.page,
                          id = _step42$value.id,
                          exportValues = _step42$value.exportValues;

                      if (page === -1) {
                        continue;
                      }

                      if (id === skipId) {
                        continue;
                      }

                      var exportValue = typeof exportValues === "string" ? exportValues : null;
                      var domElement = document.getElementById(id);

                      if (domElement && !GetElementsByNameSet.has(domElement)) {
                        (0, _util.warn)("_getElementsByName - element not allowed: ".concat(id));
                        continue;
                      }

                      fields.push({
                        id: id,
                        exportValue: exportValue,
                        domElement: domElement
                      });
                    }
                  } catch (err) {
                    _iterator42.e(err);
                  } finally {
                    _iterator42.f();
                  }
                }

                return fields;
              }

              var _iterator43 = _createForOfIteratorHelper(document.getElementsByName(name)),
                  _step43;

              try {
                for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {
                  var _domElement = _step43.value;
                  var _id4 = _domElement.id,
                      _exportValue = _domElement.exportValue;

                  if (_id4 === skipId) {
                    continue;
                  }

                  if (!GetElementsByNameSet.has(_domElement)) {
                    continue;
                  }

                  fields.push({
                    id: _id4,
                    exportValue: _exportValue,
                    domElement: _domElement
                  });
                }
              } catch (err) {
                _iterator43.e(err);
              } finally {
                _iterator43.f();
              }

              return fields;
            }
          }], [{
            key: "platform",
            get: function get() {
              var platform = typeof navigator !== "undefined" ? navigator.platform : "";
              return (0, _util.shadow)(this, "platform", {
                isWin: platform.includes("Win"),
                isMac: platform.includes("Mac")
              });
            }
          }]);

          return AnnotationElement;
        }();

        var LinkAnnotationElement = /*#__PURE__*/function (_AnnotationElement) {
          _inherits(LinkAnnotationElement, _AnnotationElement);

          var _super20 = _createSuper(LinkAnnotationElement);

          function LinkAnnotationElement(parameters) {
            _classCallCheck(this, LinkAnnotationElement);

            var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action || parameters.data.isTooltipOnly || parameters.data.resetForm || parameters.data.actions && (parameters.data.actions.Action || parameters.data.actions["Mouse Up"] || parameters.data.actions["Mouse Down"]));
            return _super20.call(this, parameters, {
              isRenderable: isRenderable,
              createQuadrilaterals: true
            });
          }

          _createClass(LinkAnnotationElement, [{
            key: "render",
            value: function render() {
              var data = this.data,
                  linkService = this.linkService;
              var link = document.createElement("a");

              if (data.url) {
                var _linkService$addLinkA;

                if (!linkService.addLinkAttributes) {
                  (0, _util.warn)("LinkAnnotationElement.render - missing `addLinkAttributes`-method on the `linkService`-instance.");
                }

                (_linkService$addLinkA = linkService.addLinkAttributes) === null || _linkService$addLinkA === void 0 ? void 0 : _linkService$addLinkA.call(linkService, link, data.url, data.newWindow);
              } else if (data.action) {
                this._bindNamedAction(link, data.action);
              } else if (data.dest) {
                this._bindLink(link, data.dest);
              } else {
                var hasClickAction = false;

                if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                  hasClickAction = true;

                  this._bindJSAction(link, data);
                }

                if (data.resetForm) {
                  this._bindResetFormAction(link, data.resetForm);
                } else if (!hasClickAction) {
                  this._bindLink(link, "");
                }
              }

              if (this.quadrilaterals) {
                return this._renderQuadrilaterals("linkAnnotation").map(function (quadrilateral, index) {
                  var linkElement = index === 0 ? link : link.cloneNode();
                  quadrilateral.appendChild(linkElement);
                  return quadrilateral;
                });
              }

              this.container.className = "linkAnnotation";
              this.container.appendChild(link);
              return this.container;
            }
          }, {
            key: "_bindLink",
            value: function _bindLink(link, destination) {
              var _this32 = this;

              link.href = this.linkService.getDestinationHash(destination);

              link.onclick = function () {
                if (destination) {
                  _this32.linkService.goToDestination(destination);
                }

                return false;
              };

              if (destination || destination === "") {
                link.className = "internalLink";
              }
            }
          }, {
            key: "_bindNamedAction",
            value: function _bindNamedAction(link, action) {
              var _this33 = this;

              link.href = this.linkService.getAnchorUrl("");

              link.onclick = function () {
                _this33.linkService.executeNamedAction(action);

                return false;
              };

              link.className = "internalLink";
            }
          }, {
            key: "_bindJSAction",
            value: function _bindJSAction(link, data) {
              var _this34 = this;

              link.href = this.linkService.getAnchorUrl("");
              var map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);

              var _loop2 = function _loop2() {
                var name = _Object$keys[_i6];
                var jsName = map.get(name);

                if (!jsName) {
                  return "continue";
                }

                link[jsName] = function () {
                  var _this34$linkService$e;

                  (_this34$linkService$e = _this34.linkService.eventBus) === null || _this34$linkService$e === void 0 ? void 0 : _this34$linkService$e.dispatch("dispatcheventinsandbox", {
                    source: _this34,
                    detail: {
                      id: data.id,
                      name: name
                    }
                  });
                  return false;
                };
              };

              for (var _i6 = 0, _Object$keys = Object.keys(data.actions); _i6 < _Object$keys.length; _i6++) {
                var _ret = _loop2();

                if (_ret === "continue") continue;
              }

              if (!link.onclick) {
                link.onclick = function () {
                  return false;
                };
              }

              link.className = "internalLink";
            }
          }, {
            key: "_bindResetFormAction",
            value: function _bindResetFormAction(link, resetForm) {
              var _this35 = this;

              var otherClickAction = link.onclick;

              if (!otherClickAction) {
                link.href = this.linkService.getAnchorUrl("");
              }

              link.className = "internalLink";

              if (!this._fieldObjects) {
                (0, _util.warn)("_bindResetFormAction - \"resetForm\" action not supported, " + "ensure that the `fieldObjects` parameter is provided.");

                if (!otherClickAction) {
                  link.onclick = function () {
                    return false;
                  };
                }

                return;
              }

              link.onclick = function () {
                if (otherClickAction) {
                  otherClickAction();
                }

                var resetFormFields = resetForm.fields,
                    resetFormRefs = resetForm.refs,
                    include = resetForm.include;
                var allFields = [];

                if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                  var fieldIds = new Set(resetFormRefs);

                  var _iterator44 = _createForOfIteratorHelper(resetFormFields),
                      _step44;

                  try {
                    for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {
                      var fieldName = _step44.value;

                      var _fields = _this35._fieldObjects[fieldName] || [];

                      var _iterator46 = _createForOfIteratorHelper(_fields),
                          _step46;

                      try {
                        for (_iterator46.s(); !(_step46 = _iterator46.n()).done;) {
                          var id = _step46.value.id;
                          fieldIds.add(id);
                        }
                      } catch (err) {
                        _iterator46.e(err);
                      } finally {
                        _iterator46.f();
                      }
                    }
                  } catch (err) {
                    _iterator44.e(err);
                  } finally {
                    _iterator44.f();
                  }

                  for (var _i7 = 0, _Object$values = Object.values(_this35._fieldObjects); _i7 < _Object$values.length; _i7++) {
                    var fields = _Object$values[_i7];

                    var _iterator45 = _createForOfIteratorHelper(fields),
                        _step45;

                    try {
                      for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {
                        var field = _step45.value;

                        if (fieldIds.has(field.id) === include) {
                          allFields.push(field);
                        }
                      }
                    } catch (err) {
                      _iterator45.e(err);
                    } finally {
                      _iterator45.f();
                    }
                  }
                } else {
                  for (var _i8 = 0, _Object$values2 = Object.values(_this35._fieldObjects); _i8 < _Object$values2.length; _i8++) {
                    var _fields2 = _Object$values2[_i8];
                    allFields.push.apply(allFields, _toConsumableArray(_fields2));
                  }
                }

                var storage = _this35.annotationStorage;
                var allIds = [];

                for (var _i9 = 0, _allFields = allFields; _i9 < _allFields.length; _i9++) {
                  var _field = _allFields[_i9];
                  var _id5 = _field.id;
                  allIds.push(_id5);

                  switch (_field.type) {
                    case "text":
                      {
                        var value = _field.defaultValue || "";
                        storage.setValue(_id5, {
                          value: value,
                          valueAsString: value
                        });
                        break;
                      }

                    case "checkbox":
                    case "radiobutton":
                      {
                        var _value = _field.defaultValue === _field.exportValues;

                        storage.setValue(_id5, {
                          value: _value
                        });
                        break;
                      }

                    case "combobox":
                    case "listbox":
                      {
                        var _value2 = _field.defaultValue || "";

                        storage.setValue(_id5, {
                          value: _value2
                        });
                        break;
                      }

                    default:
                      continue;
                  }

                  var domElement = document.getElementById(_id5);

                  if (!domElement || !GetElementsByNameSet.has(domElement)) {
                    continue;
                  }

                  domElement.dispatchEvent(new Event("resetform"));
                }

                if (_this35.enableScripting) {
                  var _this35$linkService$e;

                  (_this35$linkService$e = _this35.linkService.eventBus) === null || _this35$linkService$e === void 0 ? void 0 : _this35$linkService$e.dispatch("dispatcheventinsandbox", {
                    source: _this35,
                    detail: {
                      id: "app",
                      ids: allIds,
                      name: "ResetForm"
                    }
                  });
                }

                return false;
              };
            }
          }]);

          return LinkAnnotationElement;
        }(AnnotationElement);

        var TextAnnotationElement = /*#__PURE__*/function (_AnnotationElement2) {
          _inherits(TextAnnotationElement, _AnnotationElement2);

          var _super21 = _createSuper(TextAnnotationElement);

          function TextAnnotationElement(parameters) {
            var _parameters$data$titl, _parameters$data$cont;

            _classCallCheck(this, TextAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl = parameters.data.titleObj) !== null && _parameters$data$titl !== void 0 && _parameters$data$titl.str || (_parameters$data$cont = parameters.data.contentsObj) !== null && _parameters$data$cont !== void 0 && _parameters$data$cont.str);
            return _super21.call(this, parameters, {
              isRenderable: isRenderable
            });
          }

          _createClass(TextAnnotationElement, [{
            key: "render",
            value: function render() {
              this.container.className = "textAnnotation";
              var image = document.createElement("img");
              image.style.height = this.container.style.height;
              image.style.width = this.container.style.width;
              image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
              image.alt = "[{{type}} Annotation]";
              image.dataset.l10nId = "text_annotation_type";
              image.dataset.l10nArgs = JSON.stringify({
                type: this.data.name
              });

              if (!this.data.hasPopup) {
                this._createPopup(image, this.data);
              }

              this.container.appendChild(image);
              return this.container;
            }
          }]);

          return TextAnnotationElement;
        }(AnnotationElement);

        var WidgetAnnotationElement = /*#__PURE__*/function (_AnnotationElement3) {
          _inherits(WidgetAnnotationElement, _AnnotationElement3);

          var _super22 = _createSuper(WidgetAnnotationElement);

          function WidgetAnnotationElement() {
            _classCallCheck(this, WidgetAnnotationElement);

            return _super22.apply(this, arguments);
          }

          _createClass(WidgetAnnotationElement, [{
            key: "render",
            value: function render() {
              if (this.data.alternativeText) {
                this.container.title = this.data.alternativeText;
              }

              return this.container;
            }
          }, {
            key: "_getKeyModifier",
            value: function _getKeyModifier(event) {
              var _AnnotationElement$pl = AnnotationElement.platform,
                  isWin = _AnnotationElement$pl.isWin,
                  isMac = _AnnotationElement$pl.isMac;
              return isWin && event.ctrlKey || isMac && event.metaKey;
            }
          }, {
            key: "_setEventListener",
            value: function _setEventListener(element, baseName, eventName, valueGetter) {
              var _this36 = this;

              if (baseName.includes("mouse")) {
                element.addEventListener(baseName, function (event) {
                  var _this36$linkService$e;

                  (_this36$linkService$e = _this36.linkService.eventBus) === null || _this36$linkService$e === void 0 ? void 0 : _this36$linkService$e.dispatch("dispatcheventinsandbox", {
                    source: _this36,
                    detail: {
                      id: _this36.data.id,
                      name: eventName,
                      value: valueGetter(event),
                      shift: event.shiftKey,
                      modifier: _this36._getKeyModifier(event)
                    }
                  });
                });
              } else {
                element.addEventListener(baseName, function (event) {
                  var _this36$linkService$e2;

                  (_this36$linkService$e2 = _this36.linkService.eventBus) === null || _this36$linkService$e2 === void 0 ? void 0 : _this36$linkService$e2.dispatch("dispatcheventinsandbox", {
                    source: _this36,
                    detail: {
                      id: _this36.data.id,
                      name: eventName,
                      value: event.target.checked
                    }
                  });
                });
              }
            }
          }, {
            key: "_setEventListeners",
            value: function _setEventListeners(element, names, getter) {
              var _iterator47 = _createForOfIteratorHelper(names),
                  _step47;

              try {
                for (_iterator47.s(); !(_step47 = _iterator47.n()).done;) {
                  var _this$data$actions;

                  var _step47$value = _slicedToArray(_step47.value, 2),
                      baseName = _step47$value[0],
                      eventName = _step47$value[1];

                  if (eventName === "Action" || (_this$data$actions = this.data.actions) !== null && _this$data$actions !== void 0 && _this$data$actions[eventName]) {
                    this._setEventListener(element, baseName, eventName, getter);
                  }
                }
              } catch (err) {
                _iterator47.e(err);
              } finally {
                _iterator47.f();
              }
            }
          }, {
            key: "_setBackgroundColor",
            value: function _setBackgroundColor(element) {
              var color = this.data.backgroundColor || null;
              element.style.backgroundColor = color === null ? "transparent" : _util.Util.makeHexColor(color[0], color[1], color[2]);
            }
          }, {
            key: "_dispatchEventFromSandbox",
            value: function _dispatchEventFromSandbox(actions, jsEvent) {
              var _this37 = this;

              var setColor = function setColor(jsName, styleName, event) {
                var color = event.detail[jsName];
                event.target.style[styleName] = _scripting_utils.ColorConverters["".concat(color[0], "_HTML")](color.slice(1));
              };

              var commonActions = {
                display: function display(event) {
                  var hidden = event.detail.display % 2 === 1;
                  event.target.style.visibility = hidden ? "hidden" : "visible";

                  _this37.annotationStorage.setValue(_this37.data.id, {
                    hidden: hidden,
                    print: event.detail.display === 0 || event.detail.display === 3
                  });
                },
                print: function print(event) {
                  _this37.annotationStorage.setValue(_this37.data.id, {
                    print: event.detail.print
                  });
                },
                hidden: function hidden(event) {
                  event.target.style.visibility = event.detail.hidden ? "hidden" : "visible";

                  _this37.annotationStorage.setValue(_this37.data.id, {
                    hidden: event.detail.hidden
                  });
                },
                focus: function focus(event) {
                  setTimeout(function () {
                    return event.target.focus({
                      preventScroll: false
                    });
                  }, 0);
                },
                userName: function userName(event) {
                  event.target.title = event.detail.userName;
                },
                readonly: function readonly(event) {
                  if (event.detail.readonly) {
                    event.target.setAttribute("readonly", "");
                  } else {
                    event.target.removeAttribute("readonly");
                  }
                },
                required: function required(event) {
                  if (event.detail.required) {
                    event.target.setAttribute("required", "");
                  } else {
                    event.target.removeAttribute("required");
                  }
                },
                bgColor: function bgColor(event) {
                  setColor("bgColor", "backgroundColor", event);
                },
                fillColor: function fillColor(event) {
                  setColor("fillColor", "backgroundColor", event);
                },
                fgColor: function fgColor(event) {
                  setColor("fgColor", "color", event);
                },
                textColor: function textColor(event) {
                  setColor("textColor", "color", event);
                },
                borderColor: function borderColor(event) {
                  setColor("borderColor", "borderColor", event);
                },
                strokeColor: function strokeColor(event) {
                  setColor("strokeColor", "borderColor", event);
                }
              };

              for (var _i10 = 0, _Object$keys2 = Object.keys(jsEvent.detail); _i10 < _Object$keys2.length; _i10++) {
                var name = _Object$keys2[_i10];
                var action = actions[name] || commonActions[name];

                if (action) {
                  action(jsEvent);
                }
              }
            }
          }]);

          return WidgetAnnotationElement;
        }(AnnotationElement);

        var TextWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem) {
          _inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem);

          var _super23 = _createSuper(TextWidgetAnnotationElement);

          function TextWidgetAnnotationElement(parameters) {
            _classCallCheck(this, TextWidgetAnnotationElement);

            var isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
            return _super23.call(this, parameters, {
              isRenderable: isRenderable
            });
          }

          _createClass(TextWidgetAnnotationElement, [{
            key: "setPropertyOnSiblings",
            value: function setPropertyOnSiblings(base, key, value, keyInStorage) {
              var storage = this.annotationStorage;

              var _iterator48 = _createForOfIteratorHelper(this._getElementsByName(base.name, base.id)),
                  _step48;

              try {
                for (_iterator48.s(); !(_step48 = _iterator48.n()).done;) {
                  var element = _step48.value;

                  if (element.domElement) {
                    element.domElement[key] = value;
                  }

                  storage.setValue(element.id, _defineProperty({}, keyInStorage, value));
                }
              } catch (err) {
                _iterator48.e(err);
              } finally {
                _iterator48.f();
              }
            }
          }, {
            key: "render",
            value: function render() {
              var _this38 = this;

              var storage = this.annotationStorage;
              var id = this.data.id;
              this.container.className = "textWidgetAnnotation";
              var element = null;

              if (this.renderForms) {
                var storedData = storage.getValue(id, {
                  value: this.data.fieldValue,
                  valueAsString: this.data.fieldValue
                });
                var textContent = storedData.valueAsString || storedData.value || "";
                var elementData = {
                  userValue: null,
                  formattedValue: null,
                  beforeInputSelectionRange: null,
                  beforeInputValue: null
                };

                if (this.data.multiLine) {
                  element = document.createElement("textarea");
                  element.textContent = textContent;
                } else {
                  element = document.createElement("input");
                  element.type = "text";
                  element.setAttribute("value", textContent);
                }

                GetElementsByNameSet.add(element);
                element.disabled = this.data.readOnly;
                element.name = this.data.fieldName;
                element.tabIndex = DEFAULT_TAB_INDEX;
                elementData.userValue = textContent;
                element.setAttribute("id", id);
                element.addEventListener("input", function (event) {
                  storage.setValue(id, {
                    value: event.target.value
                  });

                  _this38.setPropertyOnSiblings(element, "value", event.target.value, "value");
                });
                element.addEventListener("resetform", function (event) {
                  var defaultValue = _this38.data.defaultFieldValue || "";
                  element.value = elementData.userValue = defaultValue;
                  delete elementData.formattedValue;
                });

                var blurListener = function blurListener(event) {
                  if (elementData.formattedValue) {
                    event.target.value = elementData.formattedValue;
                  }

                  event.target.scrollLeft = 0;
                  elementData.beforeInputSelectionRange = null;
                };

                if (this.enableScripting && this.hasJSActions) {
                  var _this$data$actions2;

                  element.addEventListener("focus", function (event) {
                    if (elementData.userValue) {
                      event.target.value = elementData.userValue;
                    }
                  });
                  element.addEventListener("updatefromsandbox", function (jsEvent) {
                    var actions = {
                      value: function value(event) {
                        elementData.userValue = event.detail.value || "";
                        storage.setValue(id, {
                          value: elementData.userValue.toString()
                        });

                        if (!elementData.formattedValue) {
                          event.target.value = elementData.userValue;
                        }
                      },
                      valueAsString: function valueAsString(event) {
                        elementData.formattedValue = event.detail.valueAsString || "";

                        if (event.target !== document.activeElement) {
                          event.target.value = elementData.formattedValue;
                        }

                        storage.setValue(id, {
                          formattedValue: elementData.formattedValue
                        });
                      },
                      selRange: function selRange(event) {
                        var _event$detail$selRang = _slicedToArray(event.detail.selRange, 2),
                            selStart = _event$detail$selRang[0],
                            selEnd = _event$detail$selRang[1];

                        if (selStart >= 0 && selEnd < event.target.value.length) {
                          event.target.setSelectionRange(selStart, selEnd);
                        }
                      }
                    };

                    _this38._dispatchEventFromSandbox(actions, jsEvent);
                  });
                  element.addEventListener("keydown", function (event) {
                    var _this38$linkService$e;

                    elementData.beforeInputValue = event.target.value;
                    var commitKey = -1;

                    if (event.key === "Escape") {
                      commitKey = 0;
                    } else if (event.key === "Enter") {
                      commitKey = 2;
                    } else if (event.key === "Tab") {
                      commitKey = 3;
                    }

                    if (commitKey === -1) {
                      return;
                    }

                    elementData.userValue = event.target.value;
                    (_this38$linkService$e = _this38.linkService.eventBus) === null || _this38$linkService$e === void 0 ? void 0 : _this38$linkService$e.dispatch("dispatcheventinsandbox", {
                      source: _this38,
                      detail: {
                        id: id,
                        name: "Keystroke",
                        value: event.target.value,
                        willCommit: true,
                        commitKey: commitKey,
                        selStart: event.target.selectionStart,
                        selEnd: event.target.selectionEnd
                      }
                    });
                  });
                  var _blurListener = blurListener;
                  blurListener = null;
                  element.addEventListener("blur", function (event) {
                    if (_this38._mouseState.isDown) {
                      var _this38$linkService$e2;

                      elementData.userValue = event.target.value;
                      (_this38$linkService$e2 = _this38.linkService.eventBus) === null || _this38$linkService$e2 === void 0 ? void 0 : _this38$linkService$e2.dispatch("dispatcheventinsandbox", {
                        source: _this38,
                        detail: {
                          id: id,
                          name: "Keystroke",
                          value: event.target.value,
                          willCommit: true,
                          commitKey: 1,
                          selStart: event.target.selectionStart,
                          selEnd: event.target.selectionEnd
                        }
                      });
                    }

                    _blurListener(event);
                  });
                  element.addEventListener("mousedown", function (event) {
                    elementData.beforeInputValue = event.target.value;
                    elementData.beforeInputSelectionRange = null;
                  });
                  element.addEventListener("keyup", function (event) {
                    if (event.target.selectionStart === event.target.selectionEnd) {
                      elementData.beforeInputSelectionRange = null;
                    }
                  });
                  element.addEventListener("select", function (event) {
                    elementData.beforeInputSelectionRange = [event.target.selectionStart, event.target.selectionEnd];
                  });

                  if ((_this$data$actions2 = this.data.actions) !== null && _this$data$actions2 !== void 0 && _this$data$actions2.Keystroke) {
                    element.addEventListener("input", function (event) {
                      var _this38$linkService$e3;

                      var selStart = -1;
                      var selEnd = -1;

                      if (elementData.beforeInputSelectionRange) {
                        var _elementData$beforeIn = _slicedToArray(elementData.beforeInputSelectionRange, 2);

                        selStart = _elementData$beforeIn[0];
                        selEnd = _elementData$beforeIn[1];
                      }

                      (_this38$linkService$e3 = _this38.linkService.eventBus) === null || _this38$linkService$e3 === void 0 ? void 0 : _this38$linkService$e3.dispatch("dispatcheventinsandbox", {
                        source: _this38,
                        detail: {
                          id: id,
                          name: "Keystroke",
                          value: elementData.beforeInputValue,
                          change: event.data,
                          willCommit: false,
                          selStart: selStart,
                          selEnd: selEnd
                        }
                      });
                    });
                  }

                  this._setEventListeners(element, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function (event) {
                    return event.target.value;
                  });
                }

                if (blurListener) {
                  element.addEventListener("blur", blurListener);
                }

                if (this.data.maxLen !== null) {
                  element.maxLength = this.data.maxLen;
                }

                if (this.data.comb) {
                  var fieldWidth = this.data.rect[2] - this.data.rect[0];
                  var combWidth = fieldWidth / this.data.maxLen;
                  element.classList.add("comb");
                  element.style.letterSpacing = "calc(".concat(combWidth, "px - 1ch)");
                }
              } else {
                element = document.createElement("div");
                element.textContent = this.data.fieldValue;
                element.style.verticalAlign = "middle";
                element.style.display = "table-cell";
              }

              this._setTextStyle(element);

              this._setBackgroundColor(element);

              this.container.appendChild(element);
              return this.container;
            }
          }, {
            key: "_setTextStyle",
            value: function _setTextStyle(element) {
              var TEXT_ALIGNMENT = ["left", "center", "right"];
              var _this$data$defaultApp = this.data.defaultAppearanceData,
                  fontSize = _this$data$defaultApp.fontSize,
                  fontColor = _this$data$defaultApp.fontColor;
              var style = element.style;

              if (fontSize) {
                style.fontSize = "".concat(fontSize, "px");
              }

              style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);

              if (this.data.textAlignment !== null) {
                style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
              }
            }
          }]);

          return TextWidgetAnnotationElement;
        }(WidgetAnnotationElement);

        var CheckboxWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem2) {
          _inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem2);

          var _super24 = _createSuper(CheckboxWidgetAnnotationElement);

          function CheckboxWidgetAnnotationElement(parameters) {
            _classCallCheck(this, CheckboxWidgetAnnotationElement);

            return _super24.call(this, parameters, {
              isRenderable: parameters.renderForms
            });
          }

          _createClass(CheckboxWidgetAnnotationElement, [{
            key: "render",
            value: function render() {
              var _this39 = this;

              var storage = this.annotationStorage;
              var data = this.data;
              var id = data.id;
              var value = storage.getValue(id, {
                value: data.exportValue === data.fieldValue
              }).value;

              if (typeof value === "string") {
                value = value !== "Off";
                storage.setValue(id, {
                  value: value
                });
              }

              this.container.className = "buttonWidgetAnnotation checkBox";
              var element = document.createElement("input");
              GetElementsByNameSet.add(element);
              element.disabled = data.readOnly;
              element.type = "checkbox";
              element.name = data.fieldName;

              if (value) {
                element.setAttribute("checked", true);
              }

              element.setAttribute("id", id);
              element.setAttribute("exportValue", data.exportValue);
              element.tabIndex = DEFAULT_TAB_INDEX;
              element.addEventListener("change", function (event) {
                var _event$target = event.target,
                    name = _event$target.name,
                    checked = _event$target.checked;

                var _iterator49 = _createForOfIteratorHelper(_this39._getElementsByName(name, id)),
                    _step49;

                try {
                  for (_iterator49.s(); !(_step49 = _iterator49.n()).done;) {
                    var checkbox = _step49.value;
                    var curChecked = checked && checkbox.exportValue === data.exportValue;

                    if (checkbox.domElement) {
                      checkbox.domElement.checked = curChecked;
                    }

                    storage.setValue(checkbox.id, {
                      value: curChecked
                    });
                  }
                } catch (err) {
                  _iterator49.e(err);
                } finally {
                  _iterator49.f();
                }

                storage.setValue(id, {
                  value: checked
                });
              });
              element.addEventListener("resetform", function (event) {
                var defaultValue = data.defaultFieldValue || "Off";
                event.target.checked = defaultValue === data.exportValue;
              });

              if (this.enableScripting && this.hasJSActions) {
                element.addEventListener("updatefromsandbox", function (jsEvent) {
                  var actions = {
                    value: function value(event) {
                      event.target.checked = event.detail.value !== "Off";
                      storage.setValue(id, {
                        value: event.target.checked
                      });
                    }
                  };

                  _this39._dispatchEventFromSandbox(actions, jsEvent);
                });

                this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function (event) {
                  return event.target.checked;
                });
              }

              this._setBackgroundColor(element);

              this.container.appendChild(element);
              return this.container;
            }
          }]);

          return CheckboxWidgetAnnotationElement;
        }(WidgetAnnotationElement);

        var RadioButtonWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem3) {
          _inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem3);

          var _super25 = _createSuper(RadioButtonWidgetAnnotationElement);

          function RadioButtonWidgetAnnotationElement(parameters) {
            _classCallCheck(this, RadioButtonWidgetAnnotationElement);

            return _super25.call(this, parameters, {
              isRenderable: parameters.renderForms
            });
          }

          _createClass(RadioButtonWidgetAnnotationElement, [{
            key: "render",
            value: function render() {
              var _this40 = this;

              this.container.className = "buttonWidgetAnnotation radioButton";
              var storage = this.annotationStorage;
              var data = this.data;
              var id = data.id;
              var value = storage.getValue(id, {
                value: data.fieldValue === data.buttonValue
              }).value;

              if (typeof value === "string") {
                value = value !== data.buttonValue;
                storage.setValue(id, {
                  value: value
                });
              }

              var element = document.createElement("input");
              GetElementsByNameSet.add(element);
              element.disabled = data.readOnly;
              element.type = "radio";
              element.name = data.fieldName;

              if (value) {
                element.setAttribute("checked", true);
              }

              element.setAttribute("id", id);
              element.tabIndex = DEFAULT_TAB_INDEX;
              element.addEventListener("change", function (event) {
                var _event$target2 = event.target,
                    name = _event$target2.name,
                    checked = _event$target2.checked;

                var _iterator50 = _createForOfIteratorHelper(_this40._getElementsByName(name, id)),
                    _step50;

                try {
                  for (_iterator50.s(); !(_step50 = _iterator50.n()).done;) {
                    var radio = _step50.value;
                    storage.setValue(radio.id, {
                      value: false
                    });
                  }
                } catch (err) {
                  _iterator50.e(err);
                } finally {
                  _iterator50.f();
                }

                storage.setValue(id, {
                  value: checked
                });
              });
              element.addEventListener("resetform", function (event) {
                var defaultValue = data.defaultFieldValue;
                event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
              });

              if (this.enableScripting && this.hasJSActions) {
                var pdfButtonValue = data.buttonValue;
                element.addEventListener("updatefromsandbox", function (jsEvent) {
                  var actions = {
                    value: function value(event) {
                      var checked = pdfButtonValue === event.detail.value;

                      var _iterator51 = _createForOfIteratorHelper(_this40._getElementsByName(event.target.name)),
                          _step51;

                      try {
                        for (_iterator51.s(); !(_step51 = _iterator51.n()).done;) {
                          var radio = _step51.value;
                          var curChecked = checked && radio.id === id;

                          if (radio.domElement) {
                            radio.domElement.checked = curChecked;
                          }

                          storage.setValue(radio.id, {
                            value: curChecked
                          });
                        }
                      } catch (err) {
                        _iterator51.e(err);
                      } finally {
                        _iterator51.f();
                      }
                    }
                  };

                  _this40._dispatchEventFromSandbox(actions, jsEvent);
                });

                this._setEventListeners(element, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], function (event) {
                  return event.target.checked;
                });
              }

              this._setBackgroundColor(element);

              this.container.appendChild(element);
              return this.container;
            }
          }]);

          return RadioButtonWidgetAnnotationElement;
        }(WidgetAnnotationElement);

        var PushButtonWidgetAnnotationElement = /*#__PURE__*/function (_LinkAnnotationElemen) {
          _inherits(PushButtonWidgetAnnotationElement, _LinkAnnotationElemen);

          var _super26 = _createSuper(PushButtonWidgetAnnotationElement);

          function PushButtonWidgetAnnotationElement() {
            _classCallCheck(this, PushButtonWidgetAnnotationElement);

            return _super26.apply(this, arguments);
          }

          _createClass(PushButtonWidgetAnnotationElement, [{
            key: "render",
            value: function render() {
              var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement.prototype), "render", this).call(this);

              container.className = "buttonWidgetAnnotation pushButton";

              if (this.data.alternativeText) {
                container.title = this.data.alternativeText;
              }

              return container;
            }
          }]);

          return PushButtonWidgetAnnotationElement;
        }(LinkAnnotationElement);

        var ChoiceWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem4) {
          _inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem4);

          var _super27 = _createSuper(ChoiceWidgetAnnotationElement);

          function ChoiceWidgetAnnotationElement(parameters) {
            _classCallCheck(this, ChoiceWidgetAnnotationElement);

            return _super27.call(this, parameters, {
              isRenderable: parameters.renderForms
            });
          }

          _createClass(ChoiceWidgetAnnotationElement, [{
            key: "render",
            value: function render() {
              var _this41 = this;

              this.container.className = "choiceWidgetAnnotation";
              var storage = this.annotationStorage;
              var id = this.data.id;
              storage.getValue(id, {
                value: this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : undefined
              });
              var fontSize = this.data.defaultAppearanceData.fontSize;

              if (!fontSize) {
                fontSize = 9;
              }

              var fontSizeStyle = "calc(".concat(fontSize, "px * var(--zoom-factor))");
              var selectElement = document.createElement("select");
              GetElementsByNameSet.add(selectElement);
              selectElement.disabled = this.data.readOnly;
              selectElement.name = this.data.fieldName;
              selectElement.setAttribute("id", id);
              selectElement.tabIndex = DEFAULT_TAB_INDEX;
              selectElement.style.fontSize = "".concat(fontSize, "px");

              if (!this.data.combo) {
                selectElement.size = this.data.options.length;

                if (this.data.multiSelect) {
                  selectElement.multiple = true;
                }
              }

              selectElement.addEventListener("resetform", function (event) {
                var defaultValue = _this41.data.defaultFieldValue;

                var _iterator52 = _createForOfIteratorHelper(selectElement.options),
                    _step52;

                try {
                  for (_iterator52.s(); !(_step52 = _iterator52.n()).done;) {
                    var option = _step52.value;
                    option.selected = option.value === defaultValue;
                  }
                } catch (err) {
                  _iterator52.e(err);
                } finally {
                  _iterator52.f();
                }
              });

              var _iterator53 = _createForOfIteratorHelper(this.data.options),
                  _step53;

              try {
                for (_iterator53.s(); !(_step53 = _iterator53.n()).done;) {
                  var option = _step53.value;
                  var optionElement = document.createElement("option");
                  optionElement.textContent = option.displayValue;
                  optionElement.value = option.exportValue;

                  if (this.data.combo) {
                    optionElement.style.fontSize = fontSizeStyle;
                  }

                  if (this.data.fieldValue.includes(option.exportValue)) {
                    optionElement.setAttribute("selected", true);
                  }

                  selectElement.appendChild(optionElement);
                }
              } catch (err) {
                _iterator53.e(err);
              } finally {
                _iterator53.f();
              }

              var getValue = function getValue(event, isExport) {
                var name = isExport ? "value" : "textContent";
                var options = event.target.options;

                if (!event.target.multiple) {
                  return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
                }

                return Array.prototype.filter.call(options, function (option) {
                  return option.selected;
                }).map(function (option) {
                  return option[name];
                });
              };

              var getItems = function getItems(event) {
                var options = event.target.options;
                return Array.prototype.map.call(options, function (option) {
                  return {
                    displayValue: option.textContent,
                    exportValue: option.value
                  };
                });
              };

              if (this.enableScripting && this.hasJSActions) {
                selectElement.addEventListener("updatefromsandbox", function (jsEvent) {
                  var actions = {
                    value: function value(event) {
                      var value = event.detail.value;
                      var values = new Set(Array.isArray(value) ? value : [value]);

                      var _iterator54 = _createForOfIteratorHelper(selectElement.options),
                          _step54;

                      try {
                        for (_iterator54.s(); !(_step54 = _iterator54.n()).done;) {
                          var option = _step54.value;
                          option.selected = values.has(option.value);
                        }
                      } catch (err) {
                        _iterator54.e(err);
                      } finally {
                        _iterator54.f();
                      }

                      storage.setValue(id, {
                        value: getValue(event, true)
                      });
                    },
                    multipleSelection: function multipleSelection(event) {
                      selectElement.multiple = true;
                    },
                    remove: function remove(event) {
                      var options = selectElement.options;
                      var index = event.detail.remove;
                      options[index].selected = false;
                      selectElement.remove(index);

                      if (options.length > 0) {
                        var i = Array.prototype.findIndex.call(options, function (option) {
                          return option.selected;
                        });

                        if (i === -1) {
                          options[0].selected = true;
                        }
                      }

                      storage.setValue(id, {
                        value: getValue(event, true),
                        items: getItems(event)
                      });
                    },
                    clear: function clear(event) {
                      while (selectElement.length !== 0) {
                        selectElement.remove(0);
                      }

                      storage.setValue(id, {
                        value: null,
                        items: []
                      });
                    },
                    insert: function insert(event) {
                      var _event$detail$insert = event.detail.insert,
                          index = _event$detail$insert.index,
                          displayValue = _event$detail$insert.displayValue,
                          exportValue = _event$detail$insert.exportValue;
                      var optionElement = document.createElement("option");
                      optionElement.textContent = displayValue;
                      optionElement.value = exportValue;
                      selectElement.insertBefore(optionElement, selectElement.children[index]);
                      storage.setValue(id, {
                        value: getValue(event, true),
                        items: getItems(event)
                      });
                    },
                    items: function items(event) {
                      var items = event.detail.items;

                      while (selectElement.length !== 0) {
                        selectElement.remove(0);
                      }

                      var _iterator55 = _createForOfIteratorHelper(items),
                          _step55;

                      try {
                        for (_iterator55.s(); !(_step55 = _iterator55.n()).done;) {
                          var item = _step55.value;
                          var displayValue = item.displayValue,
                              exportValue = item.exportValue;
                          var optionElement = document.createElement("option");
                          optionElement.textContent = displayValue;
                          optionElement.value = exportValue;
                          selectElement.appendChild(optionElement);
                        }
                      } catch (err) {
                        _iterator55.e(err);
                      } finally {
                        _iterator55.f();
                      }

                      if (selectElement.options.length > 0) {
                        selectElement.options[0].selected = true;
                      }

                      storage.setValue(id, {
                        value: getValue(event, true),
                        items: getItems(event)
                      });
                    },
                    indices: function indices(event) {
                      var indices = new Set(event.detail.indices);

                      var _iterator56 = _createForOfIteratorHelper(event.target.options),
                          _step56;

                      try {
                        for (_iterator56.s(); !(_step56 = _iterator56.n()).done;) {
                          var option = _step56.value;
                          option.selected = indices.has(option.index);
                        }
                      } catch (err) {
                        _iterator56.e(err);
                      } finally {
                        _iterator56.f();
                      }

                      storage.setValue(id, {
                        value: getValue(event, true)
                      });
                    },
                    editable: function editable(event) {
                      event.target.disabled = !event.detail.editable;
                    }
                  };

                  _this41._dispatchEventFromSandbox(actions, jsEvent);
                });
                selectElement.addEventListener("input", function (event) {
                  var _this41$linkService$e;

                  var exportValue = getValue(event, true);
                  var value = getValue(event, false);
                  storage.setValue(id, {
                    value: exportValue
                  });
                  (_this41$linkService$e = _this41.linkService.eventBus) === null || _this41$linkService$e === void 0 ? void 0 : _this41$linkService$e.dispatch("dispatcheventinsandbox", {
                    source: _this41,
                    detail: {
                      id: id,
                      name: "Keystroke",
                      value: value,
                      changeEx: exportValue,
                      willCommit: true,
                      commitKey: 1,
                      keyDown: false
                    }
                  });
                });

                this._setEventListeners(selectElement, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"]], function (event) {
                  return event.target.checked;
                });
              } else {
                selectElement.addEventListener("input", function (event) {
                  storage.setValue(id, {
                    value: getValue(event)
                  });
                });
              }

              this._setBackgroundColor(selectElement);

              this.container.appendChild(selectElement);
              return this.container;
            }
          }]);

          return ChoiceWidgetAnnotationElement;
        }(WidgetAnnotationElement);

        var PopupAnnotationElement = /*#__PURE__*/function (_AnnotationElement4) {
          _inherits(PopupAnnotationElement, _AnnotationElement4);

          var _super28 = _createSuper(PopupAnnotationElement);

          function PopupAnnotationElement(parameters) {
            var _parameters$data$titl2, _parameters$data$cont2;

            _classCallCheck(this, PopupAnnotationElement);

            var isRenderable = !!((_parameters$data$titl2 = parameters.data.titleObj) !== null && _parameters$data$titl2 !== void 0 && _parameters$data$titl2.str || (_parameters$data$cont2 = parameters.data.contentsObj) !== null && _parameters$data$cont2 !== void 0 && _parameters$data$cont2.str);
            return _super28.call(this, parameters, {
              isRenderable: isRenderable
            });
          }

          _createClass(PopupAnnotationElement, [{
            key: "render",
            value: function render() {
              var IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"];
              this.container.className = "popupAnnotation";

              if (IGNORE_TYPES.includes(this.data.parentType)) {
                return this.container;
              }

              var selector = "[data-annotation-id=\"".concat(this.data.parentId, "\"]");
              var parentElements = this.layer.querySelectorAll(selector);

              if (parentElements.length === 0) {
                return this.container;
              }

              var popup = new PopupElement({
                container: this.container,
                trigger: Array.from(parentElements),
                color: this.data.color,
                titleObj: this.data.titleObj,
                modificationDate: this.data.modificationDate,
                contentsObj: this.data.contentsObj
              });
              var page = this.page;

              var rect = _util.Util.normalizeRect([this.data.parentRect[0], page.view[3] - this.data.parentRect[1] + page.view[1], this.data.parentRect[2], page.view[3] - this.data.parentRect[3] + page.view[1]]);

              var popupLeft = rect[0] + this.data.parentRect[2] - this.data.parentRect[0];
              var popupTop = rect[1];
              this.container.style.transformOrigin = "".concat(-popupLeft, "px ").concat(-popupTop, "px");
              this.container.style.left = "".concat(popupLeft, "px");
              this.container.style.top = "".concat(popupTop, "px");
              this.container.appendChild(popup.render());
              return this.container;
            }
          }]);

          return PopupAnnotationElement;
        }(AnnotationElement);

        var PopupElement = /*#__PURE__*/function () {
          function PopupElement(parameters) {
            _classCallCheck(this, PopupElement);

            this.container = parameters.container;
            this.trigger = parameters.trigger;
            this.color = parameters.color;
            this.titleObj = parameters.titleObj;
            this.modificationDate = parameters.modificationDate;
            this.contentsObj = parameters.contentsObj;
            this.hideWrapper = parameters.hideWrapper || false;
            this.pinned = false;
          }

          _createClass(PopupElement, [{
            key: "render",
            value: function render() {
              var BACKGROUND_ENLIGHT = 0.7;
              var wrapper = document.createElement("div");
              wrapper.className = "popupWrapper";
              this.hideElement = this.hideWrapper ? wrapper : this.container;
              this.hideElement.hidden = true;
              var popup = document.createElement("div");
              popup.className = "popup";
              var color = this.color;

              if (color) {
                var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];
                var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];
                var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];
                popup.style.backgroundColor = _util.Util.makeHexColor(r | 0, g | 0, b | 0);
              }

              var title = document.createElement("h1");
              title.dir = this.titleObj.dir;
              title.textContent = this.titleObj.str;
              popup.appendChild(title);

              var dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);

              if (dateObject) {
                var modificationDate = document.createElement("span");
                modificationDate.textContent = "{{date}}, {{time}}";
                modificationDate.dataset.l10nId = "annotation_date_string";
                modificationDate.dataset.l10nArgs = JSON.stringify({
                  date: dateObject.toLocaleDateString(),
                  time: dateObject.toLocaleTimeString()
                });
                popup.appendChild(modificationDate);
              }

              var contents = this._formatContents(this.contentsObj);

              popup.appendChild(contents);

              if (!Array.isArray(this.trigger)) {
                this.trigger = [this.trigger];
              }

              var _iterator57 = _createForOfIteratorHelper(this.trigger),
                  _step57;

              try {
                for (_iterator57.s(); !(_step57 = _iterator57.n()).done;) {
                  var element = _step57.value;
                  element.addEventListener("click", this._toggle.bind(this));
                  element.addEventListener("mouseover", this._show.bind(this, false));
                  element.addEventListener("mouseout", this._hide.bind(this, false));
                }
              } catch (err) {
                _iterator57.e(err);
              } finally {
                _iterator57.f();
              }

              popup.addEventListener("click", this._hide.bind(this, true));
              wrapper.appendChild(popup);
              return wrapper;
            }
          }, {
            key: "_formatContents",
            value: function _formatContents(_ref38) {
              var str = _ref38.str,
                  dir = _ref38.dir;
              var p = document.createElement("p");
              p.dir = dir;
              var lines = str.split(/(?:\r\n?|\n)/);

              for (var i = 0, ii = lines.length; i < ii; ++i) {
                var line = lines[i];
                p.appendChild(document.createTextNode(line));

                if (i < ii - 1) {
                  p.appendChild(document.createElement("br"));
                }
              }

              return p;
            }
          }, {
            key: "_toggle",
            value: function _toggle() {
              if (this.pinned) {
                this._hide(true);
              } else {
                this._show(true);
              }
            }
          }, {
            key: "_show",
            value: function _show() {
              var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

              if (pin) {
                this.pinned = true;
              }

              if (this.hideElement.hidden) {
                this.hideElement.hidden = false;
                this.container.style.zIndex += 1;
              }
            }
          }, {
            key: "_hide",
            value: function _hide() {
              var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              if (unpin) {
                this.pinned = false;
              }

              if (!this.hideElement.hidden && !this.pinned) {
                this.hideElement.hidden = true;
                this.container.style.zIndex -= 1;
              }
            }
          }]);

          return PopupElement;
        }();

        var FreeTextAnnotationElement = /*#__PURE__*/function (_AnnotationElement5) {
          _inherits(FreeTextAnnotationElement, _AnnotationElement5);

          var _super29 = _createSuper(FreeTextAnnotationElement);

          function FreeTextAnnotationElement(parameters) {
            var _parameters$data$titl3, _parameters$data$cont3;

            _classCallCheck(this, FreeTextAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl3 = parameters.data.titleObj) !== null && _parameters$data$titl3 !== void 0 && _parameters$data$titl3.str || (_parameters$data$cont3 = parameters.data.contentsObj) !== null && _parameters$data$cont3 !== void 0 && _parameters$data$cont3.str);
            return _super29.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true
            });
          }

          _createClass(FreeTextAnnotationElement, [{
            key: "render",
            value: function render() {
              this.container.className = "freeTextAnnotation";

              if (!this.data.hasPopup) {
                this._createPopup(null, this.data);
              }

              return this.container;
            }
          }]);

          return FreeTextAnnotationElement;
        }(AnnotationElement);

        var LineAnnotationElement = /*#__PURE__*/function (_AnnotationElement6) {
          _inherits(LineAnnotationElement, _AnnotationElement6);

          var _super30 = _createSuper(LineAnnotationElement);

          function LineAnnotationElement(parameters) {
            var _parameters$data$titl4, _parameters$data$cont4;

            _classCallCheck(this, LineAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl4 = parameters.data.titleObj) !== null && _parameters$data$titl4 !== void 0 && _parameters$data$titl4.str || (_parameters$data$cont4 = parameters.data.contentsObj) !== null && _parameters$data$cont4 !== void 0 && _parameters$data$cont4.str);
            return _super30.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true
            });
          }

          _createClass(LineAnnotationElement, [{
            key: "render",
            value: function render() {
              this.container.className = "lineAnnotation";
              var data = this.data;
              var width = data.rect[2] - data.rect[0];
              var height = data.rect[3] - data.rect[1];
              var svg = this.svgFactory.create(width, height);
              var line = this.svgFactory.createElement("svg:line");
              line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
              line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
              line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
              line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
              line.setAttribute("stroke-width", data.borderStyle.width || 1);
              line.setAttribute("stroke", "transparent");
              svg.appendChild(line);
              this.container.append(svg);

              this._createPopup(line, data);

              return this.container;
            }
          }]);

          return LineAnnotationElement;
        }(AnnotationElement);

        var SquareAnnotationElement = /*#__PURE__*/function (_AnnotationElement7) {
          _inherits(SquareAnnotationElement, _AnnotationElement7);

          var _super31 = _createSuper(SquareAnnotationElement);

          function SquareAnnotationElement(parameters) {
            var _parameters$data$titl5, _parameters$data$cont5;

            _classCallCheck(this, SquareAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl5 = parameters.data.titleObj) !== null && _parameters$data$titl5 !== void 0 && _parameters$data$titl5.str || (_parameters$data$cont5 = parameters.data.contentsObj) !== null && _parameters$data$cont5 !== void 0 && _parameters$data$cont5.str);
            return _super31.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true
            });
          }

          _createClass(SquareAnnotationElement, [{
            key: "render",
            value: function render() {
              this.container.className = "squareAnnotation";
              var data = this.data;
              var width = data.rect[2] - data.rect[0];
              var height = data.rect[3] - data.rect[1];
              var svg = this.svgFactory.create(width, height);
              var borderWidth = data.borderStyle.width;
              var square = this.svgFactory.createElement("svg:rect");
              square.setAttribute("x", borderWidth / 2);
              square.setAttribute("y", borderWidth / 2);
              square.setAttribute("width", width - borderWidth);
              square.setAttribute("height", height - borderWidth);
              square.setAttribute("stroke-width", borderWidth || 1);
              square.setAttribute("stroke", "transparent");
              square.setAttribute("fill", "none");
              svg.appendChild(square);
              this.container.append(svg);

              this._createPopup(square, data);

              return this.container;
            }
          }]);

          return SquareAnnotationElement;
        }(AnnotationElement);

        var CircleAnnotationElement = /*#__PURE__*/function (_AnnotationElement8) {
          _inherits(CircleAnnotationElement, _AnnotationElement8);

          var _super32 = _createSuper(CircleAnnotationElement);

          function CircleAnnotationElement(parameters) {
            var _parameters$data$titl6, _parameters$data$cont6;

            _classCallCheck(this, CircleAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl6 = parameters.data.titleObj) !== null && _parameters$data$titl6 !== void 0 && _parameters$data$titl6.str || (_parameters$data$cont6 = parameters.data.contentsObj) !== null && _parameters$data$cont6 !== void 0 && _parameters$data$cont6.str);
            return _super32.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true
            });
          }

          _createClass(CircleAnnotationElement, [{
            key: "render",
            value: function render() {
              this.container.className = "circleAnnotation";
              var data = this.data;
              var width = data.rect[2] - data.rect[0];
              var height = data.rect[3] - data.rect[1];
              var svg = this.svgFactory.create(width, height);
              var borderWidth = data.borderStyle.width;
              var circle = this.svgFactory.createElement("svg:ellipse");
              circle.setAttribute("cx", width / 2);
              circle.setAttribute("cy", height / 2);
              circle.setAttribute("rx", width / 2 - borderWidth / 2);
              circle.setAttribute("ry", height / 2 - borderWidth / 2);
              circle.setAttribute("stroke-width", borderWidth || 1);
              circle.setAttribute("stroke", "transparent");
              circle.setAttribute("fill", "none");
              svg.appendChild(circle);
              this.container.append(svg);

              this._createPopup(circle, data);

              return this.container;
            }
          }]);

          return CircleAnnotationElement;
        }(AnnotationElement);

        var PolylineAnnotationElement = /*#__PURE__*/function (_AnnotationElement9) {
          _inherits(PolylineAnnotationElement, _AnnotationElement9);

          var _super33 = _createSuper(PolylineAnnotationElement);

          function PolylineAnnotationElement(parameters) {
            var _parameters$data$titl7, _parameters$data$cont7;

            var _this42;

            _classCallCheck(this, PolylineAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl7 = parameters.data.titleObj) !== null && _parameters$data$titl7 !== void 0 && _parameters$data$titl7.str || (_parameters$data$cont7 = parameters.data.contentsObj) !== null && _parameters$data$cont7 !== void 0 && _parameters$data$cont7.str);
            _this42 = _super33.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true
            });
            _this42.containerClassName = "polylineAnnotation";
            _this42.svgElementName = "svg:polyline";
            return _this42;
          }

          _createClass(PolylineAnnotationElement, [{
            key: "render",
            value: function render() {
              this.container.className = this.containerClassName;
              var data = this.data;
              var width = data.rect[2] - data.rect[0];
              var height = data.rect[3] - data.rect[1];
              var svg = this.svgFactory.create(width, height);
              var points = [];

              var _iterator58 = _createForOfIteratorHelper(data.vertices),
                  _step58;

              try {
                for (_iterator58.s(); !(_step58 = _iterator58.n()).done;) {
                  var coordinate = _step58.value;
                  var x = coordinate.x - data.rect[0];
                  var y = data.rect[3] - coordinate.y;
                  points.push(x + "," + y);
                }
              } catch (err) {
                _iterator58.e(err);
              } finally {
                _iterator58.f();
              }

              points = points.join(" ");
              var polyline = this.svgFactory.createElement(this.svgElementName);
              polyline.setAttribute("points", points);
              polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
              polyline.setAttribute("stroke", "transparent");
              polyline.setAttribute("fill", "none");
              svg.appendChild(polyline);
              this.container.append(svg);

              this._createPopup(polyline, data);

              return this.container;
            }
          }]);

          return PolylineAnnotationElement;
        }(AnnotationElement);

        var PolygonAnnotationElement = /*#__PURE__*/function (_PolylineAnnotationEl) {
          _inherits(PolygonAnnotationElement, _PolylineAnnotationEl);

          var _super34 = _createSuper(PolygonAnnotationElement);

          function PolygonAnnotationElement(parameters) {
            var _this43;

            _classCallCheck(this, PolygonAnnotationElement);

            _this43 = _super34.call(this, parameters);
            _this43.containerClassName = "polygonAnnotation";
            _this43.svgElementName = "svg:polygon";
            return _this43;
          }

          return _createClass(PolygonAnnotationElement);
        }(PolylineAnnotationElement);

        var CaretAnnotationElement = /*#__PURE__*/function (_AnnotationElement10) {
          _inherits(CaretAnnotationElement, _AnnotationElement10);

          var _super35 = _createSuper(CaretAnnotationElement);

          function CaretAnnotationElement(parameters) {
            var _parameters$data$titl8, _parameters$data$cont8;

            _classCallCheck(this, CaretAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl8 = parameters.data.titleObj) !== null && _parameters$data$titl8 !== void 0 && _parameters$data$titl8.str || (_parameters$data$cont8 = parameters.data.contentsObj) !== null && _parameters$data$cont8 !== void 0 && _parameters$data$cont8.str);
            return _super35.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true
            });
          }

          _createClass(CaretAnnotationElement, [{
            key: "render",
            value: function render() {
              this.container.className = "caretAnnotation";

              if (!this.data.hasPopup) {
                this._createPopup(null, this.data);
              }

              return this.container;
            }
          }]);

          return CaretAnnotationElement;
        }(AnnotationElement);

        var InkAnnotationElement = /*#__PURE__*/function (_AnnotationElement11) {
          _inherits(InkAnnotationElement, _AnnotationElement11);

          var _super36 = _createSuper(InkAnnotationElement);

          function InkAnnotationElement(parameters) {
            var _parameters$data$titl9, _parameters$data$cont9;

            var _this44;

            _classCallCheck(this, InkAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl9 = parameters.data.titleObj) !== null && _parameters$data$titl9 !== void 0 && _parameters$data$titl9.str || (_parameters$data$cont9 = parameters.data.contentsObj) !== null && _parameters$data$cont9 !== void 0 && _parameters$data$cont9.str);
            _this44 = _super36.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true
            });
            _this44.containerClassName = "inkAnnotation";
            _this44.svgElementName = "svg:polyline";
            return _this44;
          }

          _createClass(InkAnnotationElement, [{
            key: "render",
            value: function render() {
              this.container.className = this.containerClassName;
              var data = this.data;
              var width = data.rect[2] - data.rect[0];
              var height = data.rect[3] - data.rect[1];
              var svg = this.svgFactory.create(width, height);

              var _iterator59 = _createForOfIteratorHelper(data.inkLists),
                  _step59;

              try {
                for (_iterator59.s(); !(_step59 = _iterator59.n()).done;) {
                  var inkList = _step59.value;
                  var points = [];

                  var _iterator60 = _createForOfIteratorHelper(inkList),
                      _step60;

                  try {
                    for (_iterator60.s(); !(_step60 = _iterator60.n()).done;) {
                      var coordinate = _step60.value;
                      var x = coordinate.x - data.rect[0];
                      var y = data.rect[3] - coordinate.y;
                      points.push("".concat(x, ",").concat(y));
                    }
                  } catch (err) {
                    _iterator60.e(err);
                  } finally {
                    _iterator60.f();
                  }

                  points = points.join(" ");
                  var polyline = this.svgFactory.createElement(this.svgElementName);
                  polyline.setAttribute("points", points);
                  polyline.setAttribute("stroke-width", data.borderStyle.width || 1);
                  polyline.setAttribute("stroke", "transparent");
                  polyline.setAttribute("fill", "none");

                  this._createPopup(polyline, data);

                  svg.appendChild(polyline);
                }
              } catch (err) {
                _iterator59.e(err);
              } finally {
                _iterator59.f();
              }

              this.container.append(svg);
              return this.container;
            }
          }]);

          return InkAnnotationElement;
        }(AnnotationElement);

        var HighlightAnnotationElement = /*#__PURE__*/function (_AnnotationElement12) {
          _inherits(HighlightAnnotationElement, _AnnotationElement12);

          var _super37 = _createSuper(HighlightAnnotationElement);

          function HighlightAnnotationElement(parameters) {
            var _parameters$data$titl10, _parameters$data$cont10;

            _classCallCheck(this, HighlightAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl10 = parameters.data.titleObj) !== null && _parameters$data$titl10 !== void 0 && _parameters$data$titl10.str || (_parameters$data$cont10 = parameters.data.contentsObj) !== null && _parameters$data$cont10 !== void 0 && _parameters$data$cont10.str);
            return _super37.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }

          _createClass(HighlightAnnotationElement, [{
            key: "render",
            value: function render() {
              if (!this.data.hasPopup) {
                this._createPopup(null, this.data);
              }

              if (this.quadrilaterals) {
                return this._renderQuadrilaterals("highlightAnnotation");
              }

              this.container.className = "highlightAnnotation";
              return this.container;
            }
          }]);

          return HighlightAnnotationElement;
        }(AnnotationElement);

        var UnderlineAnnotationElement = /*#__PURE__*/function (_AnnotationElement13) {
          _inherits(UnderlineAnnotationElement, _AnnotationElement13);

          var _super38 = _createSuper(UnderlineAnnotationElement);

          function UnderlineAnnotationElement(parameters) {
            var _parameters$data$titl11, _parameters$data$cont11;

            _classCallCheck(this, UnderlineAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl11 = parameters.data.titleObj) !== null && _parameters$data$titl11 !== void 0 && _parameters$data$titl11.str || (_parameters$data$cont11 = parameters.data.contentsObj) !== null && _parameters$data$cont11 !== void 0 && _parameters$data$cont11.str);
            return _super38.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }

          _createClass(UnderlineAnnotationElement, [{
            key: "render",
            value: function render() {
              if (!this.data.hasPopup) {
                this._createPopup(null, this.data);
              }

              if (this.quadrilaterals) {
                return this._renderQuadrilaterals("underlineAnnotation");
              }

              this.container.className = "underlineAnnotation";
              return this.container;
            }
          }]);

          return UnderlineAnnotationElement;
        }(AnnotationElement);

        var SquigglyAnnotationElement = /*#__PURE__*/function (_AnnotationElement14) {
          _inherits(SquigglyAnnotationElement, _AnnotationElement14);

          var _super39 = _createSuper(SquigglyAnnotationElement);

          function SquigglyAnnotationElement(parameters) {
            var _parameters$data$titl12, _parameters$data$cont12;

            _classCallCheck(this, SquigglyAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl12 = parameters.data.titleObj) !== null && _parameters$data$titl12 !== void 0 && _parameters$data$titl12.str || (_parameters$data$cont12 = parameters.data.contentsObj) !== null && _parameters$data$cont12 !== void 0 && _parameters$data$cont12.str);
            return _super39.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }

          _createClass(SquigglyAnnotationElement, [{
            key: "render",
            value: function render() {
              if (!this.data.hasPopup) {
                this._createPopup(null, this.data);
              }

              if (this.quadrilaterals) {
                return this._renderQuadrilaterals("squigglyAnnotation");
              }

              this.container.className = "squigglyAnnotation";
              return this.container;
            }
          }]);

          return SquigglyAnnotationElement;
        }(AnnotationElement);

        var StrikeOutAnnotationElement = /*#__PURE__*/function (_AnnotationElement15) {
          _inherits(StrikeOutAnnotationElement, _AnnotationElement15);

          var _super40 = _createSuper(StrikeOutAnnotationElement);

          function StrikeOutAnnotationElement(parameters) {
            var _parameters$data$titl13, _parameters$data$cont13;

            _classCallCheck(this, StrikeOutAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl13 = parameters.data.titleObj) !== null && _parameters$data$titl13 !== void 0 && _parameters$data$titl13.str || (_parameters$data$cont13 = parameters.data.contentsObj) !== null && _parameters$data$cont13 !== void 0 && _parameters$data$cont13.str);
            return _super40.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }

          _createClass(StrikeOutAnnotationElement, [{
            key: "render",
            value: function render() {
              if (!this.data.hasPopup) {
                this._createPopup(null, this.data);
              }

              if (this.quadrilaterals) {
                return this._renderQuadrilaterals("strikeoutAnnotation");
              }

              this.container.className = "strikeoutAnnotation";
              return this.container;
            }
          }]);

          return StrikeOutAnnotationElement;
        }(AnnotationElement);

        var StampAnnotationElement = /*#__PURE__*/function (_AnnotationElement16) {
          _inherits(StampAnnotationElement, _AnnotationElement16);

          var _super41 = _createSuper(StampAnnotationElement);

          function StampAnnotationElement(parameters) {
            var _parameters$data$titl14, _parameters$data$cont14;

            _classCallCheck(this, StampAnnotationElement);

            var isRenderable = !!(parameters.data.hasPopup || (_parameters$data$titl14 = parameters.data.titleObj) !== null && _parameters$data$titl14 !== void 0 && _parameters$data$titl14.str || (_parameters$data$cont14 = parameters.data.contentsObj) !== null && _parameters$data$cont14 !== void 0 && _parameters$data$cont14.str);
            return _super41.call(this, parameters, {
              isRenderable: isRenderable,
              ignoreBorder: true
            });
          }

          _createClass(StampAnnotationElement, [{
            key: "render",
            value: function render() {
              this.container.className = "stampAnnotation";

              if (!this.data.hasPopup) {
                this._createPopup(null, this.data);
              }

              return this.container;
            }
          }]);

          return StampAnnotationElement;
        }(AnnotationElement);

        var FileAttachmentAnnotationElement = /*#__PURE__*/function (_AnnotationElement17) {
          _inherits(FileAttachmentAnnotationElement, _AnnotationElement17);

          var _super42 = _createSuper(FileAttachmentAnnotationElement);

          function FileAttachmentAnnotationElement(parameters) {
            var _this45$linkService$e;

            var _this45;

            _classCallCheck(this, FileAttachmentAnnotationElement);

            _this45 = _super42.call(this, parameters, {
              isRenderable: true
            });
            var _this45$data$file = _this45.data.file,
                filename = _this45$data$file.filename,
                content = _this45$data$file.content;
            _this45.filename = (0, _display_utils.getFilenameFromUrl)(filename);
            _this45.content = content;
            (_this45$linkService$e = _this45.linkService.eventBus) === null || _this45$linkService$e === void 0 ? void 0 : _this45$linkService$e.dispatch("fileattachmentannotation", {
              source: _assertThisInitialized(_this45),
              id: (0, _util.stringToPDFString)(filename),
              filename: filename,
              content: content
            });
            return _this45;
          }

          _createClass(FileAttachmentAnnotationElement, [{
            key: "render",
            value: function render() {
              var _this$data$titleObj, _this$data$contentsOb;

              this.container.className = "fileAttachmentAnnotation";
              var trigger = document.createElement("div");
              trigger.style.height = this.container.style.height;
              trigger.style.width = this.container.style.width;
              trigger.addEventListener("dblclick", this._download.bind(this));

              if (!this.data.hasPopup && ((_this$data$titleObj = this.data.titleObj) !== null && _this$data$titleObj !== void 0 && _this$data$titleObj.str || (_this$data$contentsOb = this.data.contentsObj) !== null && _this$data$contentsOb !== void 0 && _this$data$contentsOb.str)) {
                this._createPopup(trigger, this.data);
              }

              this.container.appendChild(trigger);
              return this.container;
            }
          }, {
            key: "_download",
            value: function _download() {
              var _this$downloadManager;

              (_this$downloadManager = this.downloadManager) === null || _this$downloadManager === void 0 ? void 0 : _this$downloadManager.openOrDownloadData(this.container, this.content, this.filename);
            }
          }]);

          return FileAttachmentAnnotationElement;
        }(AnnotationElement);

        var AnnotationLayer = /*#__PURE__*/function () {
          function AnnotationLayer() {
            _classCallCheck(this, AnnotationLayer);
          }

          _createClass(AnnotationLayer, null, [{
            key: "render",
            value: function render(parameters) {
              var sortedAnnotations = [],
                  popupAnnotations = [];

              var _iterator61 = _createForOfIteratorHelper(parameters.annotations),
                  _step61;

              try {
                for (_iterator61.s(); !(_step61 = _iterator61.n()).done;) {
                  var _data3 = _step61.value;

                  if (!_data3) {
                    continue;
                  }

                  if (_data3.annotationType === _util.AnnotationType.POPUP) {
                    popupAnnotations.push(_data3);
                    continue;
                  }

                  sortedAnnotations.push(_data3);
                }
              } catch (err) {
                _iterator61.e(err);
              } finally {
                _iterator61.f();
              }

              if (popupAnnotations.length) {
                sortedAnnotations.push.apply(sortedAnnotations, popupAnnotations);
              }

              for (var _i11 = 0, _sortedAnnotations = sortedAnnotations; _i11 < _sortedAnnotations.length; _i11++) {
                var data = _sortedAnnotations[_i11];
                var element = AnnotationElementFactory.create({
                  data: data,
                  layer: parameters.div,
                  page: parameters.page,
                  viewport: parameters.viewport,
                  linkService: parameters.linkService,
                  downloadManager: parameters.downloadManager,
                  imageResourcesPath: parameters.imageResourcesPath || "",
                  renderForms: parameters.renderForms !== false,
                  svgFactory: new _display_utils.DOMSVGFactory(),
                  annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage(),
                  enableScripting: parameters.enableScripting,
                  hasJSActions: parameters.hasJSActions,
                  fieldObjects: parameters.fieldObjects,
                  mouseState: parameters.mouseState || {
                    isDown: false
                  }
                });

                if (element.isRenderable) {
                  var rendered = element.render();

                  if (data.hidden) {
                    rendered.style.visibility = "hidden";
                  }

                  if (Array.isArray(rendered)) {
                    var _iterator62 = _createForOfIteratorHelper(rendered),
                        _step62;

                    try {
                      for (_iterator62.s(); !(_step62 = _iterator62.n()).done;) {
                        var renderedElement = _step62.value;
                        parameters.div.appendChild(renderedElement);
                      }
                    } catch (err) {
                      _iterator62.e(err);
                    } finally {
                      _iterator62.f();
                    }
                  } else {
                    if (element instanceof PopupAnnotationElement) {
                      parameters.div.prepend(rendered);
                    } else {
                      parameters.div.appendChild(rendered);
                    }
                  }
                }
              }
            }
          }, {
            key: "update",
            value: function update(parameters) {
              var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");

              var _iterator63 = _createForOfIteratorHelper(parameters.annotations),
                  _step63;

              try {
                for (_iterator63.s(); !(_step63 = _iterator63.n()).done;) {
                  var data = _step63.value;
                  var elements = parameters.div.querySelectorAll("[data-annotation-id=\"".concat(data.id, "\"]"));

                  if (elements) {
                    var _iterator64 = _createForOfIteratorHelper(elements),
                        _step64;

                    try {
                      for (_iterator64.s(); !(_step64 = _iterator64.n()).done;) {
                        var element = _step64.value;
                        element.style.transform = transform;
                      }
                    } catch (err) {
                      _iterator64.e(err);
                    } finally {
                      _iterator64.f();
                    }
                  }
                }
              } catch (err) {
                _iterator63.e(err);
              } finally {
                _iterator63.f();
              }

              parameters.div.hidden = false;
            }
          }]);

          return AnnotationLayer;
        }();

        exports.AnnotationLayer = AnnotationLayer;
        /***/
      },
      /* 19 */

      /***/
      function (__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.ColorConverters = void 0;

        function makeColorComp(n) {
          return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
        }

        var ColorConverters = /*#__PURE__*/function () {
          function ColorConverters() {
            _classCallCheck(this, ColorConverters);
          }

          _createClass(ColorConverters, null, [{
            key: "CMYK_G",
            value: function CMYK_G(_ref39) {
              var _ref40 = _slicedToArray(_ref39, 4),
                  c = _ref40[0],
                  y = _ref40[1],
                  m = _ref40[2],
                  k = _ref40[3];

              return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
            }
          }, {
            key: "G_CMYK",
            value: function G_CMYK(_ref41) {
              var _ref42 = _slicedToArray(_ref41, 1),
                  g = _ref42[0];

              return ["CMYK", 0, 0, 0, 1 - g];
            }
          }, {
            key: "G_RGB",
            value: function G_RGB(_ref43) {
              var _ref44 = _slicedToArray(_ref43, 1),
                  g = _ref44[0];

              return ["RGB", g, g, g];
            }
          }, {
            key: "G_HTML",
            value: function G_HTML(_ref45) {
              var _ref46 = _slicedToArray(_ref45, 1),
                  g = _ref46[0];

              var G = makeColorComp(g);
              return "#".concat(G).concat(G).concat(G);
            }
          }, {
            key: "RGB_G",
            value: function RGB_G(_ref47) {
              var _ref48 = _slicedToArray(_ref47, 3),
                  r = _ref48[0],
                  g = _ref48[1],
                  b = _ref48[2];

              return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
            }
          }, {
            key: "RGB_HTML",
            value: function RGB_HTML(_ref49) {
              var _ref50 = _slicedToArray(_ref49, 3),
                  r = _ref50[0],
                  g = _ref50[1],
                  b = _ref50[2];

              var R = makeColorComp(r);
              var G = makeColorComp(g);
              var B = makeColorComp(b);
              return "#".concat(R).concat(G).concat(B);
            }
          }, {
            key: "T_HTML",
            value: function T_HTML() {
              return "#00000000";
            }
          }, {
            key: "CMYK_RGB",
            value: function CMYK_RGB(_ref51) {
              var _ref52 = _slicedToArray(_ref51, 4),
                  c = _ref52[0],
                  y = _ref52[1],
                  m = _ref52[2],
                  k = _ref52[3];

              return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
            }
          }, {
            key: "CMYK_HTML",
            value: function CMYK_HTML(components) {
              return this.RGB_HTML(this.CMYK_RGB(components));
            }
          }, {
            key: "RGB_CMYK",
            value: function RGB_CMYK(_ref53) {
              var _ref54 = _slicedToArray(_ref53, 3),
                  r = _ref54[0],
                  g = _ref54[1],
                  b = _ref54[2];

              var c = 1 - r;
              var m = 1 - g;
              var y = 1 - b;
              var k = Math.min(c, m, y);
              return ["CMYK", c, m, y, k];
            }
          }]);

          return ColorConverters;
        }();

        exports.ColorConverters = ColorConverters;
        /***/
      },
      /* 20 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.renderTextLayer = renderTextLayer;

        var _util = __w_pdfjs_require__(2);

        var MAX_TEXT_DIVS_TO_RENDER = 100000;
        var DEFAULT_FONT_SIZE = 30;
        var DEFAULT_FONT_ASCENT = 0.8;
        var ascentCache = new Map();
        var AllWhitespaceRegexp = /^\s+$/g;

        function getAscent(fontFamily, ctx) {
          var cachedAscent = ascentCache.get(fontFamily);

          if (cachedAscent) {
            return cachedAscent;
          }

          ctx.save();
          ctx.font = "".concat(DEFAULT_FONT_SIZE, "px ").concat(fontFamily);
          var metrics = ctx.measureText("");
          var ascent = metrics.fontBoundingBoxAscent;
          var descent = Math.abs(metrics.fontBoundingBoxDescent);

          if (ascent) {
            ctx.restore();
            var ratio = ascent / (ascent + descent);
            ascentCache.set(fontFamily, ratio);
            return ratio;
          }

          ctx.strokeStyle = "red";
          ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
          ctx.strokeText("g", 0, 0);
          var pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
          descent = 0;

          for (var i = pixels.length - 1 - 3; i >= 0; i -= 4) {
            if (pixels[i] > 0) {
              descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);
              break;
            }
          }

          ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);
          ctx.strokeText("A", 0, DEFAULT_FONT_SIZE);
          pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;
          ascent = 0;

          for (var _i12 = 0, ii = pixels.length; _i12 < ii; _i12 += 4) {
            if (pixels[_i12] > 0) {
              ascent = DEFAULT_FONT_SIZE - Math.floor(_i12 / 4 / DEFAULT_FONT_SIZE);
              break;
            }
          }

          ctx.restore();

          if (ascent) {
            var _ratio = ascent / (ascent + descent);

            ascentCache.set(fontFamily, _ratio);
            return _ratio;
          }

          ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);
          return DEFAULT_FONT_ASCENT;
        }

        function appendText(task, geom, styles, ctx) {
          var textDiv = document.createElement("span");
          var textDivProperties = task._enhanceTextSelection ? {
            angle: 0,
            canvasWidth: 0,
            hasText: geom.str !== "",
            hasEOL: geom.hasEOL,
            originalTransform: null,
            paddingBottom: 0,
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            scale: 1
          } : {
            angle: 0,
            canvasWidth: 0,
            hasText: geom.str !== "",
            hasEOL: geom.hasEOL
          };

          task._textDivs.push(textDiv);

          var tx = _util.Util.transform(task._viewport.transform, geom.transform);

          var angle = Math.atan2(tx[1], tx[0]);
          var style = styles[geom.fontName];

          if (style.vertical) {
            angle += Math.PI / 2;
          }

          var fontHeight = Math.hypot(tx[2], tx[3]);
          var fontAscent = fontHeight * getAscent(style.fontFamily, ctx);
          var left, top;

          if (angle === 0) {
            left = tx[4];
            top = tx[5] - fontAscent;
          } else {
            left = tx[4] + fontAscent * Math.sin(angle);
            top = tx[5] - fontAscent * Math.cos(angle);
          }

          textDiv.style.left = "".concat(left, "px");
          textDiv.style.top = "".concat(top, "px");
          textDiv.style.fontSize = "".concat(fontHeight, "px");
          textDiv.style.fontFamily = style.fontFamily;
          textDiv.setAttribute("role", "presentation");
          textDiv.textContent = geom.str;
          textDiv.dir = geom.dir;

          if (task._fontInspectorEnabled) {
            textDiv.dataset.fontName = geom.fontName;
          }

          if (angle !== 0) {
            textDivProperties.angle = angle * (180 / Math.PI);
          }

          var shouldScaleText = false;

          if (geom.str.length > 1 || task._enhanceTextSelection && AllWhitespaceRegexp.test(geom.str)) {
            shouldScaleText = true;
          } else if (geom.transform[0] !== geom.transform[3]) {
            var absScaleX = Math.abs(geom.transform[0]),
                absScaleY = Math.abs(geom.transform[3]);

            if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
              shouldScaleText = true;
            }
          }

          if (shouldScaleText) {
            if (style.vertical) {
              textDivProperties.canvasWidth = geom.height * task._viewport.scale;
            } else {
              textDivProperties.canvasWidth = geom.width * task._viewport.scale;
            }
          }

          task._textDivProperties.set(textDiv, textDivProperties);

          if (task._textContentStream) {
            task._layoutText(textDiv);
          }

          if (task._enhanceTextSelection && textDivProperties.hasText) {
            var angleCos = 1,
                angleSin = 0;

            if (angle !== 0) {
              angleCos = Math.cos(angle);
              angleSin = Math.sin(angle);
            }

            var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;
            var divHeight = fontHeight;
            var m, b;

            if (angle !== 0) {
              m = [angleCos, angleSin, -angleSin, angleCos, left, top];
              b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);
            } else {
              b = [left, top, left + divWidth, top + divHeight];
            }

            task._bounds.push({
              left: b[0],
              top: b[1],
              right: b[2],
              bottom: b[3],
              div: textDiv,
              size: [divWidth, divHeight],
              m: m
            });
          }
        }

        function render(task) {
          if (task._canceled) {
            return;
          }

          var textDivs = task._textDivs;
          var capability = task._capability;
          var textDivsLength = textDivs.length;

          if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {
            task._renderingDone = true;
            capability.resolve();
            return;
          }

          if (!task._textContentStream) {
            for (var i = 0; i < textDivsLength; i++) {
              task._layoutText(textDivs[i]);
            }
          }

          task._renderingDone = true;
          capability.resolve();
        }

        function findPositiveMin(ts, offset, count) {
          var result = 0;

          for (var i = 0; i < count; i++) {
            var t = ts[offset++];

            if (t > 0) {
              result = result ? Math.min(t, result) : t;
            }
          }

          return result;
        }

        function expand(task) {
          var bounds = task._bounds;
          var viewport = task._viewport;
          var expanded = expandBounds(viewport.width, viewport.height, bounds);

          for (var i = 0; i < expanded.length; i++) {
            var div = bounds[i].div;

            var divProperties = task._textDivProperties.get(div);

            if (divProperties.angle === 0) {
              divProperties.paddingLeft = bounds[i].left - expanded[i].left;
              divProperties.paddingTop = bounds[i].top - expanded[i].top;
              divProperties.paddingRight = expanded[i].right - bounds[i].right;
              divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;

              task._textDivProperties.set(div, divProperties);

              continue;
            }

            var e = expanded[i],
                b = bounds[i];
            var m = b.m,
                c = m[0],
                s = m[1];
            var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];
            var ts = new Float64Array(64);

            for (var j = 0, jj = points.length; j < jj; j++) {
              var t = _util.Util.applyTransform(points[j], m);

              ts[j + 0] = c && (e.left - t[0]) / c;
              ts[j + 4] = s && (e.top - t[1]) / s;
              ts[j + 8] = c && (e.right - t[0]) / c;
              ts[j + 12] = s && (e.bottom - t[1]) / s;
              ts[j + 16] = s && (e.left - t[0]) / -s;
              ts[j + 20] = c && (e.top - t[1]) / c;
              ts[j + 24] = s && (e.right - t[0]) / -s;
              ts[j + 28] = c && (e.bottom - t[1]) / c;
              ts[j + 32] = c && (e.left - t[0]) / -c;
              ts[j + 36] = s && (e.top - t[1]) / -s;
              ts[j + 40] = c && (e.right - t[0]) / -c;
              ts[j + 44] = s && (e.bottom - t[1]) / -s;
              ts[j + 48] = s && (e.left - t[0]) / s;
              ts[j + 52] = c && (e.top - t[1]) / -c;
              ts[j + 56] = s && (e.right - t[0]) / s;
              ts[j + 60] = c && (e.bottom - t[1]) / -c;
            }

            var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));
            divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;
            divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;
            divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;
            divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;

            task._textDivProperties.set(div, divProperties);
          }
        }

        function expandBounds(width, height, boxes) {
          var bounds = boxes.map(function (box, i) {
            return {
              x1: box.left,
              y1: box.top,
              x2: box.right,
              y2: box.bottom,
              index: i,
              x1New: undefined,
              x2New: undefined
            };
          });
          expandBoundsLTR(width, bounds);
          var expanded = new Array(boxes.length);

          var _iterator65 = _createForOfIteratorHelper(bounds),
              _step65;

          try {
            for (_iterator65.s(); !(_step65 = _iterator65.n()).done;) {
              var b = _step65.value;
              var i = b.index;
              expanded[i] = {
                left: b.x1New,
                top: 0,
                right: b.x2New,
                bottom: 0
              };
            }
          } catch (err) {
            _iterator65.e(err);
          } finally {
            _iterator65.f();
          }

          boxes.map(function (box, i) {
            var e = expanded[i],
                b = bounds[i];
            b.x1 = box.top;
            b.y1 = width - e.right;
            b.x2 = box.bottom;
            b.y2 = width - e.left;
            b.index = i;
            b.x1New = undefined;
            b.x2New = undefined;
          });
          expandBoundsLTR(height, bounds);

          var _iterator66 = _createForOfIteratorHelper(bounds),
              _step66;

          try {
            for (_iterator66.s(); !(_step66 = _iterator66.n()).done;) {
              var _b = _step66.value;
              var _i13 = _b.index;
              expanded[_i13].top = _b.x1New;
              expanded[_i13].bottom = _b.x2New;
            }
          } catch (err) {
            _iterator66.e(err);
          } finally {
            _iterator66.f();
          }

          return expanded;
        }

        function expandBoundsLTR(width, bounds) {
          bounds.sort(function (a, b) {
            return a.x1 - b.x1 || a.index - b.index;
          });
          var fakeBoundary = {
            x1: -Infinity,
            y1: -Infinity,
            x2: 0,
            y2: Infinity,
            index: -1,
            x1New: 0,
            x2New: 0
          };
          var horizon = [{
            start: -Infinity,
            end: Infinity,
            boundary: fakeBoundary
          }];

          var _iterator67 = _createForOfIteratorHelper(bounds),
              _step67;

          try {
            for (_iterator67.s(); !(_step67 = _iterator67.n()).done;) {
              var boundary = _step67.value;
              var i = 0;

              while (i < horizon.length && horizon[i].end <= boundary.y1) {
                i++;
              }

              var j = horizon.length - 1;

              while (j >= 0 && horizon[j].start >= boundary.y2) {
                j--;
              }

              var _horizonPart = void 0,
                  _affectedBoundary = void 0;

              var q = void 0,
                  k = void 0,
                  maxXNew = -Infinity;

              for (q = i; q <= j; q++) {
                _horizonPart = horizon[q];
                _affectedBoundary = _horizonPart.boundary;
                var xNew = void 0;

                if (_affectedBoundary.x2 > boundary.x1) {
                  xNew = _affectedBoundary.index > boundary.index ? _affectedBoundary.x1New : boundary.x1;
                } else if (_affectedBoundary.x2New === undefined) {
                  xNew = (_affectedBoundary.x2 + boundary.x1) / 2;
                } else {
                  xNew = _affectedBoundary.x2New;
                }

                if (xNew > maxXNew) {
                  maxXNew = xNew;
                }
              }

              boundary.x1New = maxXNew;

              for (q = i; q <= j; q++) {
                _horizonPart = horizon[q];
                _affectedBoundary = _horizonPart.boundary;

                if (_affectedBoundary.x2New === undefined) {
                  if (_affectedBoundary.x2 > boundary.x1) {
                    if (_affectedBoundary.index > boundary.index) {
                      _affectedBoundary.x2New = _affectedBoundary.x2;
                    }
                  } else {
                    _affectedBoundary.x2New = maxXNew;
                  }
                } else if (_affectedBoundary.x2New > maxXNew) {
                  _affectedBoundary.x2New = Math.max(maxXNew, _affectedBoundary.x2);
                }
              }

              var changedHorizon = [];
              var lastBoundary = null;

              for (q = i; q <= j; q++) {
                _horizonPart = horizon[q];
                _affectedBoundary = _horizonPart.boundary;
                var useBoundary = _affectedBoundary.x2 > boundary.x2 ? _affectedBoundary : boundary;

                if (lastBoundary === useBoundary) {
                  changedHorizon[changedHorizon.length - 1].end = _horizonPart.end;
                } else {
                  changedHorizon.push({
                    start: _horizonPart.start,
                    end: _horizonPart.end,
                    boundary: useBoundary
                  });
                  lastBoundary = useBoundary;
                }
              }

              if (horizon[i].start < boundary.y1) {
                changedHorizon[0].start = boundary.y1;
                changedHorizon.unshift({
                  start: horizon[i].start,
                  end: boundary.y1,
                  boundary: horizon[i].boundary
                });
              }

              if (boundary.y2 < horizon[j].end) {
                changedHorizon[changedHorizon.length - 1].end = boundary.y2;
                changedHorizon.push({
                  start: boundary.y2,
                  end: horizon[j].end,
                  boundary: horizon[j].boundary
                });
              }

              for (q = i; q <= j; q++) {
                _horizonPart = horizon[q];
                _affectedBoundary = _horizonPart.boundary;

                if (_affectedBoundary.x2New !== undefined) {
                  continue;
                }

                var used = false;

                for (k = i - 1; !used && k >= 0 && horizon[k].start >= _affectedBoundary.y1; k--) {
                  used = horizon[k].boundary === _affectedBoundary;
                }

                for (k = j + 1; !used && k < horizon.length && horizon[k].end <= _affectedBoundary.y2; k++) {
                  used = horizon[k].boundary === _affectedBoundary;
                }

                for (k = 0; !used && k < changedHorizon.length; k++) {
                  used = changedHorizon[k].boundary === _affectedBoundary;
                }

                if (!used) {
                  _affectedBoundary.x2New = maxXNew;
                }
              }

              Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));
            }
          } catch (err) {
            _iterator67.e(err);
          } finally {
            _iterator67.f();
          }

          for (var _i14 = 0, _horizon = horizon; _i14 < _horizon.length; _i14++) {
            var horizonPart = _horizon[_i14];
            var affectedBoundary = horizonPart.boundary;

            if (affectedBoundary.x2New === undefined) {
              affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);
            }
          }
        }

        var TextLayerRenderTask = /*#__PURE__*/function () {
          function TextLayerRenderTask(_ref55) {
            var _globalThis$FontInspe2,
                _this46 = this;

            var textContent = _ref55.textContent,
                textContentStream = _ref55.textContentStream,
                container = _ref55.container,
                viewport = _ref55.viewport,
                textDivs = _ref55.textDivs,
                textContentItemsStr = _ref55.textContentItemsStr,
                enhanceTextSelection = _ref55.enhanceTextSelection;

            _classCallCheck(this, TextLayerRenderTask);

            this._textContent = textContent;
            this._textContentStream = textContentStream;
            this._container = container;
            this._document = container.ownerDocument;
            this._viewport = viewport;
            this._textDivs = textDivs || [];
            this._textContentItemsStr = textContentItemsStr || [];
            this._enhanceTextSelection = !!enhanceTextSelection;
            this._fontInspectorEnabled = !!((_globalThis$FontInspe2 = globalThis.FontInspector) !== null && _globalThis$FontInspe2 !== void 0 && _globalThis$FontInspe2.enabled);
            this._reader = null;
            this._layoutTextLastFontSize = null;
            this._layoutTextLastFontFamily = null;
            this._layoutTextCtx = null;
            this._textDivProperties = new WeakMap();
            this._renderingDone = false;
            this._canceled = false;
            this._capability = (0, _util.createPromiseCapability)();
            this._renderTimer = null;
            this._bounds = [];

            this._capability.promise["finally"](function () {
              if (!_this46._enhanceTextSelection) {
                _this46._textDivProperties = null;
              }

              if (_this46._layoutTextCtx) {
                _this46._layoutTextCtx.canvas.width = 0;
                _this46._layoutTextCtx.canvas.height = 0;
                _this46._layoutTextCtx = null;
              }
            })["catch"](function () {});
          }

          _createClass(TextLayerRenderTask, [{
            key: "promise",
            get: function get() {
              return this._capability.promise;
            }
          }, {
            key: "cancel",
            value: function cancel() {
              this._canceled = true;

              if (this._reader) {
                this._reader.cancel(new _util.AbortException("TextLayer task cancelled."))["catch"](function () {});

                this._reader = null;
              }

              if (this._renderTimer !== null) {
                clearTimeout(this._renderTimer);
                this._renderTimer = null;
              }

              this._capability.reject(new Error("TextLayer task cancelled."));
            }
          }, {
            key: "_processItems",
            value: function _processItems(items, styleCache) {
              for (var i = 0, len = items.length; i < len; i++) {
                if (items[i].str === undefined) {
                  if (items[i].type === "beginMarkedContentProps" || items[i].type === "beginMarkedContent") {
                    var parent = this._container;
                    this._container = document.createElement("span");

                    this._container.classList.add("markedContent");

                    if (items[i].id !== null) {
                      this._container.setAttribute("id", "".concat(items[i].id));
                    }

                    parent.appendChild(this._container);
                  } else if (items[i].type === "endMarkedContent") {
                    this._container = this._container.parentNode;
                  }

                  continue;
                }

                this._textContentItemsStr.push(items[i].str);

                appendText(this, items[i], styleCache, this._layoutTextCtx);
              }
            }
          }, {
            key: "_layoutText",
            value: function _layoutText(textDiv) {
              var textDivProperties = this._textDivProperties.get(textDiv);

              var transform = "";

              if (textDivProperties.canvasWidth !== 0 && textDivProperties.hasText) {
                var _textDiv$style = textDiv.style,
                    fontSize = _textDiv$style.fontSize,
                    fontFamily = _textDiv$style.fontFamily;

                if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {
                  this._layoutTextCtx.font = "".concat(fontSize, " ").concat(fontFamily);
                  this._layoutTextLastFontSize = fontSize;
                  this._layoutTextLastFontFamily = fontFamily;
                }

                var _this$_layoutTextCtx$ = this._layoutTextCtx.measureText(textDiv.textContent),
                    width = _this$_layoutTextCtx$.width;

                if (width > 0) {
                  var scale = textDivProperties.canvasWidth / width;

                  if (this._enhanceTextSelection) {
                    textDivProperties.scale = scale;
                  }

                  transform = "scaleX(".concat(scale, ")");
                }
              }

              if (textDivProperties.angle !== 0) {
                transform = "rotate(".concat(textDivProperties.angle, "deg) ").concat(transform);
              }

              if (transform.length > 0) {
                if (this._enhanceTextSelection) {
                  textDivProperties.originalTransform = transform;
                }

                textDiv.style.transform = transform;
              }

              if (textDivProperties.hasText) {
                this._container.appendChild(textDiv);
              }

              if (textDivProperties.hasEOL) {
                var br = document.createElement("br");
                br.setAttribute("role", "presentation");

                this._container.appendChild(br);
              }
            }
          }, {
            key: "_render",
            value: function _render() {
              var _this47 = this;

              var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var capability = (0, _util.createPromiseCapability)();
              var styleCache = Object.create(null);

              var canvas = this._document.createElement("canvas");

              canvas.height = canvas.width = DEFAULT_FONT_SIZE;
              canvas.mozOpaque = true;
              this._layoutTextCtx = canvas.getContext("2d", {
                alpha: false
              });

              if (this._textContent) {
                var textItems = this._textContent.items;
                var textStyles = this._textContent.styles;

                this._processItems(textItems, textStyles);

                capability.resolve();
              } else if (this._textContentStream) {
                var pump = function pump() {
                  _this47._reader.read().then(function (_ref56) {
                    var value = _ref56.value,
                        done = _ref56.done;

                    if (done) {
                      capability.resolve();
                      return;
                    }

                    Object.assign(styleCache, value.styles);

                    _this47._processItems(value.items, styleCache);

                    pump();
                  }, capability.reject);
                };

                this._reader = this._textContentStream.getReader();
                pump();
              } else {
                throw new Error('Neither "textContent" nor "textContentStream" parameters specified.');
              }

              capability.promise.then(function () {
                styleCache = null;

                if (!timeout) {
                  render(_this47);
                } else {
                  _this47._renderTimer = setTimeout(function () {
                    render(_this47);
                    _this47._renderTimer = null;
                  }, timeout);
                }
              }, this._capability.reject);
            }
          }, {
            key: "expandTextDivs",
            value: function expandTextDivs() {
              var expandDivs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

              if (!this._enhanceTextSelection || !this._renderingDone) {
                return;
              }

              if (this._bounds !== null) {
                expand(this);
                this._bounds = null;
              }

              var transformBuf = [],
                  paddingBuf = [];

              for (var i = 0, ii = this._textDivs.length; i < ii; i++) {
                var div = this._textDivs[i];

                var divProps = this._textDivProperties.get(div);

                if (!divProps.hasText) {
                  continue;
                }

                if (expandDivs) {
                  transformBuf.length = 0;
                  paddingBuf.length = 0;

                  if (divProps.originalTransform) {
                    transformBuf.push(divProps.originalTransform);
                  }

                  if (divProps.paddingTop > 0) {
                    paddingBuf.push("".concat(divProps.paddingTop, "px"));
                    transformBuf.push("translateY(".concat(-divProps.paddingTop, "px)"));
                  } else {
                    paddingBuf.push(0);
                  }

                  if (divProps.paddingRight > 0) {
                    paddingBuf.push("".concat(divProps.paddingRight / divProps.scale, "px"));
                  } else {
                    paddingBuf.push(0);
                  }

                  if (divProps.paddingBottom > 0) {
                    paddingBuf.push("".concat(divProps.paddingBottom, "px"));
                  } else {
                    paddingBuf.push(0);
                  }

                  if (divProps.paddingLeft > 0) {
                    paddingBuf.push("".concat(divProps.paddingLeft / divProps.scale, "px"));
                    transformBuf.push("translateX(".concat(-divProps.paddingLeft / divProps.scale, "px)"));
                  } else {
                    paddingBuf.push(0);
                  }

                  div.style.padding = paddingBuf.join(" ");

                  if (transformBuf.length) {
                    div.style.transform = transformBuf.join(" ");
                  }
                } else {
                  div.style.padding = null;
                  div.style.transform = divProps.originalTransform;
                }
              }
            }
          }]);

          return TextLayerRenderTask;
        }();

        function renderTextLayer(renderParameters) {
          var task = new TextLayerRenderTask({
            textContent: renderParameters.textContent,
            textContentStream: renderParameters.textContentStream,
            container: renderParameters.container,
            viewport: renderParameters.viewport,
            textDivs: renderParameters.textDivs,
            textContentItemsStr: renderParameters.textContentItemsStr,
            enhanceTextSelection: renderParameters.enhanceTextSelection
          });

          task._render(renderParameters.timeout);

          return task;
        }
        /***/

      },
      /* 21 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.SVGGraphics = void 0;

        var _util = __w_pdfjs_require__(2);

        var _display_utils = __w_pdfjs_require__(1);

        var _is_node = __w_pdfjs_require__(4);

        var SVGGraphics = /*#__PURE__*/_createClass(function SVGGraphics() {
          _classCallCheck(this, SVGGraphics);

          (0, _util.unreachable)("Not implemented: SVGGraphics");
        });

        exports.SVGGraphics = SVGGraphics;
        {
          var opListToTree = function opListToTree(opList) {
            var opTree = [];
            var tmp = [];

            var _iterator68 = _createForOfIteratorHelper(opList),
                _step68;

            try {
              for (_iterator68.s(); !(_step68 = _iterator68.n()).done;) {
                var opListElement = _step68.value;

                if (opListElement.fn === "save") {
                  opTree.push({
                    fnId: 92,
                    fn: "group",
                    items: []
                  });
                  tmp.push(opTree);
                  opTree = opTree[opTree.length - 1].items;
                  continue;
                }

                if (opListElement.fn === "restore") {
                  opTree = tmp.pop();
                } else {
                  opTree.push(opListElement);
                }
              }
            } catch (err) {
              _iterator68.e(err);
            } finally {
              _iterator68.f();
            }

            return opTree;
          };

          var pf = function pf(value) {
            if (Number.isInteger(value)) {
              return value.toString();
            }

            var s = value.toFixed(10);
            var i = s.length - 1;

            if (s[i] !== "0") {
              return s;
            }

            do {
              i--;
            } while (s[i] === "0");

            return s.substring(0, s[i] === "." ? i : i + 1);
          };

          var pm = function pm(m) {
            if (m[4] === 0 && m[5] === 0) {
              if (m[1] === 0 && m[2] === 0) {
                if (m[0] === 1 && m[3] === 1) {
                  return "";
                }

                return "scale(".concat(pf(m[0]), " ").concat(pf(m[3]), ")");
              }

              if (m[0] === m[3] && m[1] === -m[2]) {
                var a = Math.acos(m[0]) * 180 / Math.PI;
                return "rotate(".concat(pf(a), ")");
              }
            } else {
              if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {
                return "translate(".concat(pf(m[4]), " ").concat(pf(m[5]), ")");
              }
            }

            return "matrix(".concat(pf(m[0]), " ").concat(pf(m[1]), " ").concat(pf(m[2]), " ").concat(pf(m[3]), " ").concat(pf(m[4]), " ") + "".concat(pf(m[5]), ")");
          };

          var SVG_DEFAULTS = {
            fontStyle: "normal",
            fontWeight: "normal",
            fillColor: "#000000"
          };
          var XML_NS = "http://www.w3.org/XML/1998/namespace";
          var XLINK_NS = "http://www.w3.org/1999/xlink";
          var LINE_CAP_STYLES = ["butt", "round", "square"];
          var LINE_JOIN_STYLES = ["miter", "round", "bevel"];

          var convertImgDataToPng = function () {
            var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);
            var CHUNK_WRAPPER_SIZE = 12;
            var crcTable = new Int32Array(256);

            for (var i = 0; i < 256; i++) {
              var c = i;

              for (var h = 0; h < 8; h++) {
                if (c & 1) {
                  c = 0xedb88320 ^ c >> 1 & 0x7fffffff;
                } else {
                  c = c >> 1 & 0x7fffffff;
                }
              }

              crcTable[i] = c;
            }

            function crc32(data, start, end) {
              var crc = -1;

              for (var _i15 = start; _i15 < end; _i15++) {
                var a = (crc ^ data[_i15]) & 0xff;
                var b = crcTable[a];
                crc = crc >>> 8 ^ b;
              }

              return crc ^ -1;
            }

            function writePngChunk(type, body, data, offset) {
              var p = offset;
              var len = body.length;
              data[p] = len >> 24 & 0xff;
              data[p + 1] = len >> 16 & 0xff;
              data[p + 2] = len >> 8 & 0xff;
              data[p + 3] = len & 0xff;
              p += 4;
              data[p] = type.charCodeAt(0) & 0xff;
              data[p + 1] = type.charCodeAt(1) & 0xff;
              data[p + 2] = type.charCodeAt(2) & 0xff;
              data[p + 3] = type.charCodeAt(3) & 0xff;
              p += 4;
              data.set(body, p);
              p += body.length;
              var crc = crc32(data, offset + 4, p);
              data[p] = crc >> 24 & 0xff;
              data[p + 1] = crc >> 16 & 0xff;
              data[p + 2] = crc >> 8 & 0xff;
              data[p + 3] = crc & 0xff;
            }

            function adler32(data, start, end) {
              var a = 1;
              var b = 0;

              for (var _i16 = start; _i16 < end; ++_i16) {
                a = (a + (data[_i16] & 0xff)) % 65521;
                b = (b + a) % 65521;
              }

              return b << 16 | a;
            }

            function deflateSync(literals) {
              if (!_is_node.isNodeJS) {
                return deflateSyncUncompressed(literals);
              }

              try {
                var input;

                if (parseInt(process.versions.node) >= 8) {
                  input = literals;
                } else {
                  input = Buffer.from(literals);
                }

                var output = __webpack_require__(19).deflateSync(input, {
                  level: 9
                });

                return output instanceof Uint8Array ? output : new Uint8Array(output);
              } catch (e) {
                (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e);
              }

              return deflateSyncUncompressed(literals);
            }

            function deflateSyncUncompressed(literals) {
              var len = literals.length;
              var maxBlockLength = 0xffff;
              var deflateBlocks = Math.ceil(len / maxBlockLength);
              var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);
              var pi = 0;
              idat[pi++] = 0x78;
              idat[pi++] = 0x9c;
              var pos = 0;

              while (len > maxBlockLength) {
                idat[pi++] = 0x00;
                idat[pi++] = 0xff;
                idat[pi++] = 0xff;
                idat[pi++] = 0x00;
                idat[pi++] = 0x00;
                idat.set(literals.subarray(pos, pos + maxBlockLength), pi);
                pi += maxBlockLength;
                pos += maxBlockLength;
                len -= maxBlockLength;
              }

              idat[pi++] = 0x01;
              idat[pi++] = len & 0xff;
              idat[pi++] = len >> 8 & 0xff;
              idat[pi++] = ~len & 0xffff & 0xff;
              idat[pi++] = (~len & 0xffff) >> 8 & 0xff;
              idat.set(literals.subarray(pos), pi);
              pi += literals.length - pos;
              var adler = adler32(literals, 0, literals.length);
              idat[pi++] = adler >> 24 & 0xff;
              idat[pi++] = adler >> 16 & 0xff;
              idat[pi++] = adler >> 8 & 0xff;
              idat[pi++] = adler & 0xff;
              return idat;
            }

            function encode(imgData, kind, forceDataSchema, isMask) {
              var width = imgData.width;
              var height = imgData.height;
              var bitDepth, colorType, lineSize;
              var bytes = imgData.data;

              switch (kind) {
                case _util.ImageKind.GRAYSCALE_1BPP:
                  colorType = 0;
                  bitDepth = 1;
                  lineSize = width + 7 >> 3;
                  break;

                case _util.ImageKind.RGB_24BPP:
                  colorType = 2;
                  bitDepth = 8;
                  lineSize = width * 3;
                  break;

                case _util.ImageKind.RGBA_32BPP:
                  colorType = 6;
                  bitDepth = 8;
                  lineSize = width * 4;
                  break;

                default:
                  throw new Error("invalid format");
              }

              var literals = new Uint8Array((1 + lineSize) * height);
              var offsetLiterals = 0,
                  offsetBytes = 0;

              for (var y = 0; y < height; ++y) {
                literals[offsetLiterals++] = 0;
                literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);
                offsetBytes += lineSize;
                offsetLiterals += lineSize;
              }

              if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {
                offsetLiterals = 0;

                for (var _y = 0; _y < height; _y++) {
                  offsetLiterals++;

                  for (var _i17 = 0; _i17 < lineSize; _i17++) {
                    literals[offsetLiterals++] ^= 0xff;
                  }
                }
              }

              var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
              var idat = deflateSync(literals);
              var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;
              var data = new Uint8Array(pngLength);
              var offset = 0;
              data.set(PNG_HEADER, offset);
              offset += PNG_HEADER.length;
              writePngChunk("IHDR", ihdr, data, offset);
              offset += CHUNK_WRAPPER_SIZE + ihdr.length;
              writePngChunk("IDATA", idat, data, offset);
              offset += CHUNK_WRAPPER_SIZE + idat.length;
              writePngChunk("IEND", new Uint8Array(0), data, offset);
              return (0, _util.createObjectURL)(data, "image/png", forceDataSchema);
            }

            return function convertImgDataToPng(imgData, forceDataSchema, isMask) {
              var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;
              return encode(imgData, kind, forceDataSchema, isMask);
            };
          }();

          var SVGExtraState = /*#__PURE__*/function () {
            function SVGExtraState() {
              _classCallCheck(this, SVGExtraState);

              this.fontSizeScale = 1;
              this.fontWeight = SVG_DEFAULTS.fontWeight;
              this.fontSize = 0;
              this.textMatrix = _util.IDENTITY_MATRIX;
              this.fontMatrix = _util.FONT_IDENTITY_MATRIX;
              this.leading = 0;
              this.textRenderingMode = _util.TextRenderingMode.FILL;
              this.textMatrixScale = 1;
              this.x = 0;
              this.y = 0;
              this.lineX = 0;
              this.lineY = 0;
              this.charSpacing = 0;
              this.wordSpacing = 0;
              this.textHScale = 1;
              this.textRise = 0;
              this.fillColor = SVG_DEFAULTS.fillColor;
              this.strokeColor = "#000000";
              this.fillAlpha = 1;
              this.strokeAlpha = 1;
              this.lineWidth = 1;
              this.lineJoin = "";
              this.lineCap = "";
              this.miterLimit = 0;
              this.dashArray = [];
              this.dashPhase = 0;
              this.dependencies = [];
              this.activeClipUrl = null;
              this.clipGroup = null;
              this.maskId = "";
            }

            _createClass(SVGExtraState, [{
              key: "clone",
              value: function clone() {
                return Object.create(this);
              }
            }, {
              key: "setCurrentPoint",
              value: function setCurrentPoint(x, y) {
                this.x = x;
                this.y = y;
              }
            }]);

            return SVGExtraState;
          }();

          var clipCount = 0;
          var maskCount = 0;
          var shadingCount = 0;

          exports.SVGGraphics = SVGGraphics = /*#__PURE__*/function () {
            function SVGGraphics(commonObjs, objs) {
              var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

              _classCallCheck(this, SVGGraphics);

              this.svgFactory = new _display_utils.DOMSVGFactory();
              this.current = new SVGExtraState();
              this.transformMatrix = _util.IDENTITY_MATRIX;
              this.transformStack = [];
              this.extraStack = [];
              this.commonObjs = commonObjs;
              this.objs = objs;
              this.pendingClip = null;
              this.pendingEOFill = false;
              this.embedFonts = false;
              this.embeddedFonts = Object.create(null);
              this.cssStyle = null;
              this.forceDataSchema = !!forceDataSchema;
              this._operatorIdMapping = [];

              for (var op in _util.OPS) {
                this._operatorIdMapping[_util.OPS[op]] = op;
              }
            }

            _createClass(SVGGraphics, [{
              key: "save",
              value: function save() {
                this.transformStack.push(this.transformMatrix);
                var old = this.current;
                this.extraStack.push(old);
                this.current = old.clone();
              }
            }, {
              key: "restore",
              value: function restore() {
                this.transformMatrix = this.transformStack.pop();
                this.current = this.extraStack.pop();
                this.pendingClip = null;
                this.tgrp = null;
              }
            }, {
              key: "group",
              value: function group(items) {
                this.save();
                this.executeOpTree(items);
                this.restore();
              }
            }, {
              key: "loadDependencies",
              value: function loadDependencies(operatorList) {
                var _this48 = this;

                var fnArray = operatorList.fnArray;
                var argsArray = operatorList.argsArray;

                for (var i = 0, ii = fnArray.length; i < ii; i++) {
                  if (fnArray[i] !== _util.OPS.dependency) {
                    continue;
                  }

                  var _iterator69 = _createForOfIteratorHelper(argsArray[i]),
                      _step69;

                  try {
                    var _loop3 = function _loop3() {
                      var obj = _step69.value;
                      var objsPool = obj.startsWith("g_") ? _this48.commonObjs : _this48.objs;
                      var promise = new Promise(function (resolve) {
                        objsPool.get(obj, resolve);
                      });

                      _this48.current.dependencies.push(promise);
                    };

                    for (_iterator69.s(); !(_step69 = _iterator69.n()).done;) {
                      _loop3();
                    }
                  } catch (err) {
                    _iterator69.e(err);
                  } finally {
                    _iterator69.f();
                  }
                }

                return Promise.all(this.current.dependencies);
              }
            }, {
              key: "transform",
              value: function transform(a, b, c, d, e, f) {
                var transformMatrix = [a, b, c, d, e, f];
                this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);
                this.tgrp = null;
              }
            }, {
              key: "getSVG",
              value: function getSVG(operatorList, viewport) {
                var _this49 = this;

                this.viewport = viewport;

                var svgElement = this._initialize(viewport);

                return this.loadDependencies(operatorList).then(function () {
                  _this49.transformMatrix = _util.IDENTITY_MATRIX;

                  _this49.executeOpTree(_this49.convertOpList(operatorList));

                  return svgElement;
                });
              }
            }, {
              key: "convertOpList",
              value: function convertOpList(operatorList) {
                var operatorIdMapping = this._operatorIdMapping;
                var argsArray = operatorList.argsArray;
                var fnArray = operatorList.fnArray;
                var opList = [];

                for (var i = 0, ii = fnArray.length; i < ii; i++) {
                  var fnId = fnArray[i];
                  opList.push({
                    fnId: fnId,
                    fn: operatorIdMapping[fnId],
                    args: argsArray[i]
                  });
                }

                return opListToTree(opList);
              }
            }, {
              key: "executeOpTree",
              value: function executeOpTree(opTree) {
                var _iterator70 = _createForOfIteratorHelper(opTree),
                    _step70;

                try {
                  for (_iterator70.s(); !(_step70 = _iterator70.n()).done;) {
                    var opTreeElement = _step70.value;
                    var fn = opTreeElement.fn;
                    var fnId = opTreeElement.fnId;
                    var args = opTreeElement.args;

                    switch (fnId | 0) {
                      case _util.OPS.beginText:
                        this.beginText();
                        break;

                      case _util.OPS.dependency:
                        break;

                      case _util.OPS.setLeading:
                        this.setLeading(args);
                        break;

                      case _util.OPS.setLeadingMoveText:
                        this.setLeadingMoveText(args[0], args[1]);
                        break;

                      case _util.OPS.setFont:
                        this.setFont(args);
                        break;

                      case _util.OPS.showText:
                        this.showText(args[0]);
                        break;

                      case _util.OPS.showSpacedText:
                        this.showText(args[0]);
                        break;

                      case _util.OPS.endText:
                        this.endText();
                        break;

                      case _util.OPS.moveText:
                        this.moveText(args[0], args[1]);
                        break;

                      case _util.OPS.setCharSpacing:
                        this.setCharSpacing(args[0]);
                        break;

                      case _util.OPS.setWordSpacing:
                        this.setWordSpacing(args[0]);
                        break;

                      case _util.OPS.setHScale:
                        this.setHScale(args[0]);
                        break;

                      case _util.OPS.setTextMatrix:
                        this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;

                      case _util.OPS.setTextRise:
                        this.setTextRise(args[0]);
                        break;

                      case _util.OPS.setTextRenderingMode:
                        this.setTextRenderingMode(args[0]);
                        break;

                      case _util.OPS.setLineWidth:
                        this.setLineWidth(args[0]);
                        break;

                      case _util.OPS.setLineJoin:
                        this.setLineJoin(args[0]);
                        break;

                      case _util.OPS.setLineCap:
                        this.setLineCap(args[0]);
                        break;

                      case _util.OPS.setMiterLimit:
                        this.setMiterLimit(args[0]);
                        break;

                      case _util.OPS.setFillRGBColor:
                        this.setFillRGBColor(args[0], args[1], args[2]);
                        break;

                      case _util.OPS.setStrokeRGBColor:
                        this.setStrokeRGBColor(args[0], args[1], args[2]);
                        break;

                      case _util.OPS.setStrokeColorN:
                        this.setStrokeColorN(args);
                        break;

                      case _util.OPS.setFillColorN:
                        this.setFillColorN(args);
                        break;

                      case _util.OPS.shadingFill:
                        this.shadingFill(args[0]);
                        break;

                      case _util.OPS.setDash:
                        this.setDash(args[0], args[1]);
                        break;

                      case _util.OPS.setRenderingIntent:
                        this.setRenderingIntent(args[0]);
                        break;

                      case _util.OPS.setFlatness:
                        this.setFlatness(args[0]);
                        break;

                      case _util.OPS.setGState:
                        this.setGState(args[0]);
                        break;

                      case _util.OPS.fill:
                        this.fill();
                        break;

                      case _util.OPS.eoFill:
                        this.eoFill();
                        break;

                      case _util.OPS.stroke:
                        this.stroke();
                        break;

                      case _util.OPS.fillStroke:
                        this.fillStroke();
                        break;

                      case _util.OPS.eoFillStroke:
                        this.eoFillStroke();
                        break;

                      case _util.OPS.clip:
                        this.clip("nonzero");
                        break;

                      case _util.OPS.eoClip:
                        this.clip("evenodd");
                        break;

                      case _util.OPS.paintSolidColorImageMask:
                        this.paintSolidColorImageMask();
                        break;

                      case _util.OPS.paintImageXObject:
                        this.paintImageXObject(args[0]);
                        break;

                      case _util.OPS.paintInlineImageXObject:
                        this.paintInlineImageXObject(args[0]);
                        break;

                      case _util.OPS.paintImageMaskXObject:
                        this.paintImageMaskXObject(args[0]);
                        break;

                      case _util.OPS.paintFormXObjectBegin:
                        this.paintFormXObjectBegin(args[0], args[1]);
                        break;

                      case _util.OPS.paintFormXObjectEnd:
                        this.paintFormXObjectEnd();
                        break;

                      case _util.OPS.closePath:
                        this.closePath();
                        break;

                      case _util.OPS.closeStroke:
                        this.closeStroke();
                        break;

                      case _util.OPS.closeFillStroke:
                        this.closeFillStroke();
                        break;

                      case _util.OPS.closeEOFillStroke:
                        this.closeEOFillStroke();
                        break;

                      case _util.OPS.nextLine:
                        this.nextLine();
                        break;

                      case _util.OPS.transform:
                        this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);
                        break;

                      case _util.OPS.constructPath:
                        this.constructPath(args[0], args[1]);
                        break;

                      case _util.OPS.endPath:
                        this.endPath();
                        break;

                      case 92:
                        this.group(opTreeElement.items);
                        break;

                      default:
                        (0, _util.warn)("Unimplemented operator ".concat(fn));
                        break;
                    }
                  }
                } catch (err) {
                  _iterator70.e(err);
                } finally {
                  _iterator70.f();
                }
              }
            }, {
              key: "setWordSpacing",
              value: function setWordSpacing(wordSpacing) {
                this.current.wordSpacing = wordSpacing;
              }
            }, {
              key: "setCharSpacing",
              value: function setCharSpacing(charSpacing) {
                this.current.charSpacing = charSpacing;
              }
            }, {
              key: "nextLine",
              value: function nextLine() {
                this.moveText(0, this.current.leading);
              }
            }, {
              key: "setTextMatrix",
              value: function setTextMatrix(a, b, c, d, e, f) {
                var current = this.current;
                current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];
                current.textMatrixScale = Math.hypot(a, b);
                current.x = current.lineX = 0;
                current.y = current.lineY = 0;
                current.xcoords = [];
                current.ycoords = [];
                current.tspan = this.svgFactory.createElement("svg:tspan");
                current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                current.tspan.setAttributeNS(null, "y", pf(-current.y));
                current.txtElement = this.svgFactory.createElement("svg:text");
                current.txtElement.appendChild(current.tspan);
              }
            }, {
              key: "beginText",
              value: function beginText() {
                var current = this.current;
                current.x = current.lineX = 0;
                current.y = current.lineY = 0;
                current.textMatrix = _util.IDENTITY_MATRIX;
                current.lineMatrix = _util.IDENTITY_MATRIX;
                current.textMatrixScale = 1;
                current.tspan = this.svgFactory.createElement("svg:tspan");
                current.txtElement = this.svgFactory.createElement("svg:text");
                current.txtgrp = this.svgFactory.createElement("svg:g");
                current.xcoords = [];
                current.ycoords = [];
              }
            }, {
              key: "moveText",
              value: function moveText(x, y) {
                var current = this.current;
                current.x = current.lineX += x;
                current.y = current.lineY += y;
                current.xcoords = [];
                current.ycoords = [];
                current.tspan = this.svgFactory.createElement("svg:tspan");
                current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));
                current.tspan.setAttributeNS(null, "y", pf(-current.y));
              }
            }, {
              key: "showText",
              value: function showText(glyphs) {
                var current = this.current;
                var font = current.font;
                var fontSize = current.fontSize;

                if (fontSize === 0) {
                  return;
                }

                var fontSizeScale = current.fontSizeScale;
                var charSpacing = current.charSpacing;
                var wordSpacing = current.wordSpacing;
                var fontDirection = current.fontDirection;
                var textHScale = current.textHScale * fontDirection;
                var vertical = font.vertical;
                var spacingDir = vertical ? 1 : -1;
                var defaultVMetrics = font.defaultVMetrics;
                var widthAdvanceScale = fontSize * current.fontMatrix[0];
                var x = 0;

                var _iterator71 = _createForOfIteratorHelper(glyphs),
                    _step71;

                try {
                  for (_iterator71.s(); !(_step71 = _iterator71.n()).done;) {
                    var glyph = _step71.value;

                    if (glyph === null) {
                      x += fontDirection * wordSpacing;
                      continue;
                    } else if ((0, _util.isNum)(glyph)) {
                      x += spacingDir * glyph * fontSize / 1000;
                      continue;
                    }

                    var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
                    var character = glyph.fontChar;
                    var scaledX = void 0,
                        scaledY = void 0;
                    var width = glyph.width;

                    if (vertical) {
                      var vx = void 0;
                      var vmetric = glyph.vmetric || defaultVMetrics;
                      vx = glyph.vmetric ? vmetric[1] : width * 0.5;
                      vx = -vx * widthAdvanceScale;
                      var vy = vmetric[2] * widthAdvanceScale;
                      width = vmetric ? -vmetric[0] : width;
                      scaledX = vx / fontSizeScale;
                      scaledY = (x + vy) / fontSizeScale;
                    } else {
                      scaledX = x / fontSizeScale;
                      scaledY = 0;
                    }

                    if (glyph.isInFont || font.missingFile) {
                      current.xcoords.push(current.x + scaledX);

                      if (vertical) {
                        current.ycoords.push(-current.y + scaledY);
                      }

                      current.tspan.textContent += character;
                    } else {}

                    var charWidth = void 0;

                    if (vertical) {
                      charWidth = width * widthAdvanceScale - spacing * fontDirection;
                    } else {
                      charWidth = width * widthAdvanceScale + spacing * fontDirection;
                    }

                    x += charWidth;
                  }
                } catch (err) {
                  _iterator71.e(err);
                } finally {
                  _iterator71.f();
                }

                current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" "));

                if (vertical) {
                  current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" "));
                } else {
                  current.tspan.setAttributeNS(null, "y", pf(-current.y));
                }

                if (vertical) {
                  current.y -= x;
                } else {
                  current.x += x * textHScale;
                }

                current.tspan.setAttributeNS(null, "font-family", current.fontFamily);
                current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px"));

                if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {
                  current.tspan.setAttributeNS(null, "font-style", current.fontStyle);
                }

                if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {
                  current.tspan.setAttributeNS(null, "font-weight", current.fontWeight);
                }

                var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;

                if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                  if (current.fillColor !== SVG_DEFAULTS.fillColor) {
                    current.tspan.setAttributeNS(null, "fill", current.fillColor);
                  }

                  if (current.fillAlpha < 1) {
                    current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                  }
                } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {
                  current.tspan.setAttributeNS(null, "fill", "transparent");
                } else {
                  current.tspan.setAttributeNS(null, "fill", "none");
                }

                if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {
                  var lineWidthScale = 1 / (current.textMatrixScale || 1);

                  this._setStrokeAttributes(current.tspan, lineWidthScale);
                }

                var textMatrix = current.textMatrix;

                if (current.textRise !== 0) {
                  textMatrix = textMatrix.slice();
                  textMatrix[5] += current.textRise;
                }

                current.txtElement.setAttributeNS(null, "transform", "".concat(pm(textMatrix), " scale(").concat(pf(textHScale), ", -1)"));
                current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve");
                current.txtElement.appendChild(current.tspan);
                current.txtgrp.appendChild(current.txtElement);

                this._ensureTransformGroup().appendChild(current.txtElement);
              }
            }, {
              key: "setLeadingMoveText",
              value: function setLeadingMoveText(x, y) {
                this.setLeading(-y);
                this.moveText(x, y);
              }
            }, {
              key: "addFontStyle",
              value: function addFontStyle(fontObj) {
                if (!fontObj.data) {
                  throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.');
                }

                if (!this.cssStyle) {
                  this.cssStyle = this.svgFactory.createElement("svg:style");
                  this.cssStyle.setAttributeNS(null, "type", "text/css");
                  this.defs.appendChild(this.cssStyle);
                }

                var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);
                this.cssStyle.textContent += "@font-face { font-family: \"".concat(fontObj.loadedName, "\";") + " src: url(".concat(url, "); }\n");
              }
            }, {
              key: "setFont",
              value: function setFont(details) {
                var current = this.current;
                var fontObj = this.commonObjs.get(details[0]);
                var size = details[1];
                current.font = fontObj;

                if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {
                  this.addFontStyle(fontObj);
                  this.embeddedFonts[fontObj.loadedName] = fontObj;
                }

                current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;
                var bold = "normal";

                if (fontObj.black) {
                  bold = "900";
                } else if (fontObj.bold) {
                  bold = "bold";
                }

                var italic = fontObj.italic ? "italic" : "normal";

                if (size < 0) {
                  size = -size;
                  current.fontDirection = -1;
                } else {
                  current.fontDirection = 1;
                }

                current.fontSize = size;
                current.fontFamily = fontObj.loadedName;
                current.fontWeight = bold;
                current.fontStyle = italic;
                current.tspan = this.svgFactory.createElement("svg:tspan");
                current.tspan.setAttributeNS(null, "y", pf(-current.y));
                current.xcoords = [];
                current.ycoords = [];
              }
            }, {
              key: "endText",
              value: function endText() {
                var _current$txtElement;

                var current = this.current;

                if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && (_current$txtElement = current.txtElement) !== null && _current$txtElement !== void 0 && _current$txtElement.hasChildNodes()) {
                  current.element = current.txtElement;
                  this.clip("nonzero");
                  this.endPath();
                }
              }
            }, {
              key: "setLineWidth",
              value: function setLineWidth(width) {
                if (width > 0) {
                  this.current.lineWidth = width;
                }
              }
            }, {
              key: "setLineCap",
              value: function setLineCap(style) {
                this.current.lineCap = LINE_CAP_STYLES[style];
              }
            }, {
              key: "setLineJoin",
              value: function setLineJoin(style) {
                this.current.lineJoin = LINE_JOIN_STYLES[style];
              }
            }, {
              key: "setMiterLimit",
              value: function setMiterLimit(limit) {
                this.current.miterLimit = limit;
              }
            }, {
              key: "setStrokeAlpha",
              value: function setStrokeAlpha(strokeAlpha) {
                this.current.strokeAlpha = strokeAlpha;
              }
            }, {
              key: "setStrokeRGBColor",
              value: function setStrokeRGBColor(r, g, b) {
                this.current.strokeColor = _util.Util.makeHexColor(r, g, b);
              }
            }, {
              key: "setFillAlpha",
              value: function setFillAlpha(fillAlpha) {
                this.current.fillAlpha = fillAlpha;
              }
            }, {
              key: "setFillRGBColor",
              value: function setFillRGBColor(r, g, b) {
                this.current.fillColor = _util.Util.makeHexColor(r, g, b);
                this.current.tspan = this.svgFactory.createElement("svg:tspan");
                this.current.xcoords = [];
                this.current.ycoords = [];
              }
            }, {
              key: "setStrokeColorN",
              value: function setStrokeColorN(args) {
                this.current.strokeColor = this._makeColorN_Pattern(args);
              }
            }, {
              key: "setFillColorN",
              value: function setFillColorN(args) {
                this.current.fillColor = this._makeColorN_Pattern(args);
              }
            }, {
              key: "shadingFill",
              value: function shadingFill(args) {
                var width = this.viewport.width;
                var height = this.viewport.height;

                var inv = _util.Util.inverseTransform(this.transformMatrix);

                var bl = _util.Util.applyTransform([0, 0], inv);

                var br = _util.Util.applyTransform([0, height], inv);

                var ul = _util.Util.applyTransform([width, 0], inv);

                var ur = _util.Util.applyTransform([width, height], inv);

                var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);
                var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);
                var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);
                var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);
                var rect = this.svgFactory.createElement("svg:rect");
                rect.setAttributeNS(null, "x", x0);
                rect.setAttributeNS(null, "y", y0);
                rect.setAttributeNS(null, "width", x1 - x0);
                rect.setAttributeNS(null, "height", y1 - y0);
                rect.setAttributeNS(null, "fill", this._makeShadingPattern(args));

                if (this.current.fillAlpha < 1) {
                  rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha);
                }

                this._ensureTransformGroup().appendChild(rect);
              }
            }, {
              key: "_makeColorN_Pattern",
              value: function _makeColorN_Pattern(args) {
                if (args[0] === "TilingPattern") {
                  return this._makeTilingPattern(args);
                }

                return this._makeShadingPattern(args);
              }
            }, {
              key: "_makeTilingPattern",
              value: function _makeTilingPattern(args) {
                var color = args[1];
                var operatorList = args[2];
                var matrix = args[3] || _util.IDENTITY_MATRIX;

                var _args$ = _slicedToArray(args[4], 4),
                    x0 = _args$[0],
                    y0 = _args$[1],
                    x1 = _args$[2],
                    y1 = _args$[3];

                var xstep = args[5];
                var ystep = args[6];
                var paintType = args[7];
                var tilingId = "shading".concat(shadingCount++);

                var _util$Util$normalizeR = _util.Util.normalizeRect([].concat(_toConsumableArray(_util.Util.applyTransform([x0, y0], matrix)), _toConsumableArray(_util.Util.applyTransform([x1, y1], matrix)))),
                    _util$Util$normalizeR2 = _slicedToArray(_util$Util$normalizeR, 4),
                    tx0 = _util$Util$normalizeR2[0],
                    ty0 = _util$Util$normalizeR2[1],
                    tx1 = _util$Util$normalizeR2[2],
                    ty1 = _util$Util$normalizeR2[3];

                var _util$Util$singularVa = _util.Util.singularValueDecompose2dScale(matrix),
                    _util$Util$singularVa2 = _slicedToArray(_util$Util$singularVa, 2),
                    xscale = _util$Util$singularVa2[0],
                    yscale = _util$Util$singularVa2[1];

                var txstep = xstep * xscale;
                var tystep = ystep * yscale;
                var tiling = this.svgFactory.createElement("svg:pattern");
                tiling.setAttributeNS(null, "id", tilingId);
                tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse");
                tiling.setAttributeNS(null, "width", txstep);
                tiling.setAttributeNS(null, "height", tystep);
                tiling.setAttributeNS(null, "x", "".concat(tx0));
                tiling.setAttributeNS(null, "y", "".concat(ty0));
                var svg = this.svg;
                var transformMatrix = this.transformMatrix;
                var fillColor = this.current.fillColor;
                var strokeColor = this.current.strokeColor;
                var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);
                this.svg = bbox;
                this.transformMatrix = matrix;

                if (paintType === 2) {
                  var _util$Util;

                  var cssColor = (_util$Util = _util.Util).makeHexColor.apply(_util$Util, _toConsumableArray(color));

                  this.current.fillColor = cssColor;
                  this.current.strokeColor = cssColor;
                }

                this.executeOpTree(this.convertOpList(operatorList));
                this.svg = svg;
                this.transformMatrix = transformMatrix;
                this.current.fillColor = fillColor;
                this.current.strokeColor = strokeColor;
                tiling.appendChild(bbox.childNodes[0]);
                this.defs.appendChild(tiling);
                return "url(#".concat(tilingId, ")");
              }
            }, {
              key: "_makeShadingPattern",
              value: function _makeShadingPattern(args) {
                switch (args[0]) {
                  case "RadialAxial":
                    var shadingId = "shading".concat(shadingCount++);
                    var colorStops = args[3];
                    var gradient;

                    switch (args[1]) {
                      case "axial":
                        var point0 = args[4];
                        var point1 = args[5];
                        gradient = this.svgFactory.createElement("svg:linearGradient");
                        gradient.setAttributeNS(null, "id", shadingId);
                        gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                        gradient.setAttributeNS(null, "x1", point0[0]);
                        gradient.setAttributeNS(null, "y1", point0[1]);
                        gradient.setAttributeNS(null, "x2", point1[0]);
                        gradient.setAttributeNS(null, "y2", point1[1]);
                        break;

                      case "radial":
                        var focalPoint = args[4];
                        var circlePoint = args[5];
                        var focalRadius = args[6];
                        var circleRadius = args[7];
                        gradient = this.svgFactory.createElement("svg:radialGradient");
                        gradient.setAttributeNS(null, "id", shadingId);
                        gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse");
                        gradient.setAttributeNS(null, "cx", circlePoint[0]);
                        gradient.setAttributeNS(null, "cy", circlePoint[1]);
                        gradient.setAttributeNS(null, "r", circleRadius);
                        gradient.setAttributeNS(null, "fx", focalPoint[0]);
                        gradient.setAttributeNS(null, "fy", focalPoint[1]);
                        gradient.setAttributeNS(null, "fr", focalRadius);
                        break;

                      default:
                        throw new Error("Unknown RadialAxial type: ".concat(args[1]));
                    }

                    var _iterator72 = _createForOfIteratorHelper(colorStops),
                        _step72;

                    try {
                      for (_iterator72.s(); !(_step72 = _iterator72.n()).done;) {
                        var colorStop = _step72.value;
                        var stop = this.svgFactory.createElement("svg:stop");
                        stop.setAttributeNS(null, "offset", colorStop[0]);
                        stop.setAttributeNS(null, "stop-color", colorStop[1]);
                        gradient.appendChild(stop);
                      }
                    } catch (err) {
                      _iterator72.e(err);
                    } finally {
                      _iterator72.f();
                    }

                    this.defs.appendChild(gradient);
                    return "url(#".concat(shadingId, ")");

                  case "Mesh":
                    (0, _util.warn)("Unimplemented pattern Mesh");
                    return null;

                  case "Dummy":
                    return "hotpink";

                  default:
                    throw new Error("Unknown IR type: ".concat(args[0]));
                }
              }
            }, {
              key: "setDash",
              value: function setDash(dashArray, dashPhase) {
                this.current.dashArray = dashArray;
                this.current.dashPhase = dashPhase;
              }
            }, {
              key: "constructPath",
              value: function constructPath(ops, args) {
                var current = this.current;
                var x = current.x,
                    y = current.y;
                var d = [];
                var j = 0;

                var _iterator73 = _createForOfIteratorHelper(ops),
                    _step73;

                try {
                  for (_iterator73.s(); !(_step73 = _iterator73.n()).done;) {
                    var op = _step73.value;

                    switch (op | 0) {
                      case _util.OPS.rectangle:
                        x = args[j++];
                        y = args[j++];
                        var width = args[j++];
                        var height = args[j++];
                        var xw = x + width;
                        var yh = y + height;
                        d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z");
                        break;

                      case _util.OPS.moveTo:
                        x = args[j++];
                        y = args[j++];
                        d.push("M", pf(x), pf(y));
                        break;

                      case _util.OPS.lineTo:
                        x = args[j++];
                        y = args[j++];
                        d.push("L", pf(x), pf(y));
                        break;

                      case _util.OPS.curveTo:
                        x = args[j + 4];
                        y = args[j + 5];
                        d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));
                        j += 6;
                        break;

                      case _util.OPS.curveTo2:
                        d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));
                        x = args[j + 2];
                        y = args[j + 3];
                        j += 4;
                        break;

                      case _util.OPS.curveTo3:
                        x = args[j + 2];
                        y = args[j + 3];
                        d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));
                        j += 4;
                        break;

                      case _util.OPS.closePath:
                        d.push("Z");
                        break;
                    }
                  }
                } catch (err) {
                  _iterator73.e(err);
                } finally {
                  _iterator73.f();
                }

                d = d.join(" ");

                if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {
                  d = current.path.getAttributeNS(null, "d") + d;
                } else {
                  current.path = this.svgFactory.createElement("svg:path");

                  this._ensureTransformGroup().appendChild(current.path);
                }

                current.path.setAttributeNS(null, "d", d);
                current.path.setAttributeNS(null, "fill", "none");
                current.element = current.path;
                current.setCurrentPoint(x, y);
              }
            }, {
              key: "endPath",
              value: function endPath() {
                var current = this.current;
                current.path = null;

                if (!this.pendingClip) {
                  return;
                }

                if (!current.element) {
                  this.pendingClip = null;
                  return;
                }

                var clipId = "clippath".concat(clipCount++);
                var clipPath = this.svgFactory.createElement("svg:clipPath");
                clipPath.setAttributeNS(null, "id", clipId);
                clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix));
                var clipElement = current.element.cloneNode(true);

                if (this.pendingClip === "evenodd") {
                  clipElement.setAttributeNS(null, "clip-rule", "evenodd");
                } else {
                  clipElement.setAttributeNS(null, "clip-rule", "nonzero");
                }

                this.pendingClip = null;
                clipPath.appendChild(clipElement);
                this.defs.appendChild(clipPath);

                if (current.activeClipUrl) {
                  current.clipGroup = null;

                  var _iterator74 = _createForOfIteratorHelper(this.extraStack),
                      _step74;

                  try {
                    for (_iterator74.s(); !(_step74 = _iterator74.n()).done;) {
                      var prev = _step74.value;
                      prev.clipGroup = null;
                    }
                  } catch (err) {
                    _iterator74.e(err);
                  } finally {
                    _iterator74.f();
                  }

                  clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl);
                }

                current.activeClipUrl = "url(#".concat(clipId, ")");
                this.tgrp = null;
              }
            }, {
              key: "clip",
              value: function clip(type) {
                this.pendingClip = type;
              }
            }, {
              key: "closePath",
              value: function closePath() {
                var current = this.current;

                if (current.path) {
                  var d = "".concat(current.path.getAttributeNS(null, "d"), "Z");
                  current.path.setAttributeNS(null, "d", d);
                }
              }
            }, {
              key: "setLeading",
              value: function setLeading(leading) {
                this.current.leading = -leading;
              }
            }, {
              key: "setTextRise",
              value: function setTextRise(textRise) {
                this.current.textRise = textRise;
              }
            }, {
              key: "setTextRenderingMode",
              value: function setTextRenderingMode(textRenderingMode) {
                this.current.textRenderingMode = textRenderingMode;
              }
            }, {
              key: "setHScale",
              value: function setHScale(scale) {
                this.current.textHScale = scale / 100;
              }
            }, {
              key: "setRenderingIntent",
              value: function setRenderingIntent(intent) {}
            }, {
              key: "setFlatness",
              value: function setFlatness(flatness) {}
            }, {
              key: "setGState",
              value: function setGState(states) {
                var _iterator75 = _createForOfIteratorHelper(states),
                    _step75;

                try {
                  for (_iterator75.s(); !(_step75 = _iterator75.n()).done;) {
                    var _step75$value = _slicedToArray(_step75.value, 2),
                        key = _step75$value[0],
                        value = _step75$value[1];

                    switch (key) {
                      case "LW":
                        this.setLineWidth(value);
                        break;

                      case "LC":
                        this.setLineCap(value);
                        break;

                      case "LJ":
                        this.setLineJoin(value);
                        break;

                      case "ML":
                        this.setMiterLimit(value);
                        break;

                      case "D":
                        this.setDash(value[0], value[1]);
                        break;

                      case "RI":
                        this.setRenderingIntent(value);
                        break;

                      case "FL":
                        this.setFlatness(value);
                        break;

                      case "Font":
                        this.setFont(value);
                        break;

                      case "CA":
                        this.setStrokeAlpha(value);
                        break;

                      case "ca":
                        this.setFillAlpha(value);
                        break;

                      default:
                        (0, _util.warn)("Unimplemented graphic state operator ".concat(key));
                        break;
                    }
                  }
                } catch (err) {
                  _iterator75.e(err);
                } finally {
                  _iterator75.f();
                }
              }
            }, {
              key: "fill",
              value: function fill() {
                var current = this.current;

                if (current.element) {
                  current.element.setAttributeNS(null, "fill", current.fillColor);
                  current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha);
                  this.endPath();
                }
              }
            }, {
              key: "stroke",
              value: function stroke() {
                var current = this.current;

                if (current.element) {
                  this._setStrokeAttributes(current.element);

                  current.element.setAttributeNS(null, "fill", "none");
                  this.endPath();
                }
              }
            }, {
              key: "_setStrokeAttributes",
              value: function _setStrokeAttributes(element) {
                var lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                var current = this.current;
                var dashArray = current.dashArray;

                if (lineWidthScale !== 1 && dashArray.length > 0) {
                  dashArray = dashArray.map(function (value) {
                    return lineWidthScale * value;
                  });
                }

                element.setAttributeNS(null, "stroke", current.strokeColor);
                element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha);
                element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit));
                element.setAttributeNS(null, "stroke-linecap", current.lineCap);
                element.setAttributeNS(null, "stroke-linejoin", current.lineJoin);
                element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px");
                element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" "));
                element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px");
              }
            }, {
              key: "eoFill",
              value: function eoFill() {
                if (this.current.element) {
                  this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                }

                this.fill();
              }
            }, {
              key: "fillStroke",
              value: function fillStroke() {
                this.stroke();
                this.fill();
              }
            }, {
              key: "eoFillStroke",
              value: function eoFillStroke() {
                if (this.current.element) {
                  this.current.element.setAttributeNS(null, "fill-rule", "evenodd");
                }

                this.fillStroke();
              }
            }, {
              key: "closeStroke",
              value: function closeStroke() {
                this.closePath();
                this.stroke();
              }
            }, {
              key: "closeFillStroke",
              value: function closeFillStroke() {
                this.closePath();
                this.fillStroke();
              }
            }, {
              key: "closeEOFillStroke",
              value: function closeEOFillStroke() {
                this.closePath();
                this.eoFillStroke();
              }
            }, {
              key: "paintSolidColorImageMask",
              value: function paintSolidColorImageMask() {
                var rect = this.svgFactory.createElement("svg:rect");
                rect.setAttributeNS(null, "x", "0");
                rect.setAttributeNS(null, "y", "0");
                rect.setAttributeNS(null, "width", "1px");
                rect.setAttributeNS(null, "height", "1px");
                rect.setAttributeNS(null, "fill", this.current.fillColor);

                this._ensureTransformGroup().appendChild(rect);
              }
            }, {
              key: "paintImageXObject",
              value: function paintImageXObject(objId) {
                var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId);

                if (!imgData) {
                  (0, _util.warn)("Dependent image with object ID ".concat(objId, " is not ready yet"));
                  return;
                }

                this.paintInlineImageXObject(imgData);
              }
            }, {
              key: "paintInlineImageXObject",
              value: function paintInlineImageXObject(imgData, mask) {
                var width = imgData.width;
                var height = imgData.height;
                var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);
                var cliprect = this.svgFactory.createElement("svg:rect");
                cliprect.setAttributeNS(null, "x", "0");
                cliprect.setAttributeNS(null, "y", "0");
                cliprect.setAttributeNS(null, "width", pf(width));
                cliprect.setAttributeNS(null, "height", pf(height));
                this.current.element = cliprect;
                this.clip("nonzero");
                var imgEl = this.svgFactory.createElement("svg:image");
                imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc);
                imgEl.setAttributeNS(null, "x", "0");
                imgEl.setAttributeNS(null, "y", pf(-height));
                imgEl.setAttributeNS(null, "width", pf(width) + "px");
                imgEl.setAttributeNS(null, "height", pf(height) + "px");
                imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / width), " ").concat(pf(-1 / height), ")"));

                if (mask) {
                  mask.appendChild(imgEl);
                } else {
                  this._ensureTransformGroup().appendChild(imgEl);
                }
              }
            }, {
              key: "paintImageMaskXObject",
              value: function paintImageMaskXObject(imgData) {
                var current = this.current;
                var width = imgData.width;
                var height = imgData.height;
                var fillColor = current.fillColor;
                current.maskId = "mask".concat(maskCount++);
                var mask = this.svgFactory.createElement("svg:mask");
                mask.setAttributeNS(null, "id", current.maskId);
                var rect = this.svgFactory.createElement("svg:rect");
                rect.setAttributeNS(null, "x", "0");
                rect.setAttributeNS(null, "y", "0");
                rect.setAttributeNS(null, "width", pf(width));
                rect.setAttributeNS(null, "height", pf(height));
                rect.setAttributeNS(null, "fill", fillColor);
                rect.setAttributeNS(null, "mask", "url(#".concat(current.maskId, ")"));
                this.defs.appendChild(mask);

                this._ensureTransformGroup().appendChild(rect);

                this.paintInlineImageXObject(imgData, mask);
              }
            }, {
              key: "paintFormXObjectBegin",
              value: function paintFormXObjectBegin(matrix, bbox) {
                if (Array.isArray(matrix) && matrix.length === 6) {
                  this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
                }

                if (bbox) {
                  var width = bbox[2] - bbox[0];
                  var height = bbox[3] - bbox[1];
                  var cliprect = this.svgFactory.createElement("svg:rect");
                  cliprect.setAttributeNS(null, "x", bbox[0]);
                  cliprect.setAttributeNS(null, "y", bbox[1]);
                  cliprect.setAttributeNS(null, "width", pf(width));
                  cliprect.setAttributeNS(null, "height", pf(height));
                  this.current.element = cliprect;
                  this.clip("nonzero");
                  this.endPath();
                }
              }
            }, {
              key: "paintFormXObjectEnd",
              value: function paintFormXObjectEnd() {}
            }, {
              key: "_initialize",
              value: function _initialize(viewport) {
                var svg = this.svgFactory.create(viewport.width, viewport.height);
                var definitions = this.svgFactory.createElement("svg:defs");
                svg.appendChild(definitions);
                this.defs = definitions;
                var rootGroup = this.svgFactory.createElement("svg:g");
                rootGroup.setAttributeNS(null, "transform", pm(viewport.transform));
                svg.appendChild(rootGroup);
                this.svg = rootGroup;
                return svg;
              }
            }, {
              key: "_ensureClipGroup",
              value: function _ensureClipGroup() {
                if (!this.current.clipGroup) {
                  var clipGroup = this.svgFactory.createElement("svg:g");
                  clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl);
                  this.svg.appendChild(clipGroup);
                  this.current.clipGroup = clipGroup;
                }

                return this.current.clipGroup;
              }
            }, {
              key: "_ensureTransformGroup",
              value: function _ensureTransformGroup() {
                if (!this.tgrp) {
                  this.tgrp = this.svgFactory.createElement("svg:g");
                  this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix));

                  if (this.current.activeClipUrl) {
                    this._ensureClipGroup().appendChild(this.tgrp);
                  } else {
                    this.svg.appendChild(this.tgrp);
                  }
                }

                return this.tgrp;
              }
            }]);

            return SVGGraphics;
          }();
        }
        /***/
      },
      /* 22 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.XfaLayer = void 0;

        var _util = __w_pdfjs_require__(2);

        var _xfa_text = __w_pdfjs_require__(17);

        var XfaLayer = /*#__PURE__*/function () {
          function XfaLayer() {
            _classCallCheck(this, XfaLayer);
          }

          _createClass(XfaLayer, null, [{
            key: "setupStorage",
            value: function setupStorage(html, id, element, storage, intent) {
              var storedData = storage.getValue(id, {
                value: null
              });

              switch (element.name) {
                case "textarea":
                  if (storedData.value !== null) {
                    html.textContent = storedData.value;
                  }

                  if (intent === "print") {
                    break;
                  }

                  html.addEventListener("input", function (event) {
                    storage.setValue(id, {
                      value: event.target.value
                    });
                  });
                  break;

                case "input":
                  if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                    if (storedData.value === element.attributes.xfaOn) {
                      html.setAttribute("checked", true);
                    } else if (storedData.value === element.attributes.xfaOff) {
                      html.removeAttribute("checked");
                    }

                    if (intent === "print") {
                      break;
                    }

                    html.addEventListener("change", function (event) {
                      storage.setValue(id, {
                        value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                      });
                    });
                  } else {
                    if (storedData.value !== null) {
                      html.setAttribute("value", storedData.value);
                    }

                    if (intent === "print") {
                      break;
                    }

                    html.addEventListener("input", function (event) {
                      storage.setValue(id, {
                        value: event.target.value
                      });
                    });
                  }

                  break;

                case "select":
                  if (storedData.value !== null) {
                    var _iterator76 = _createForOfIteratorHelper(element.children),
                        _step76;

                    try {
                      for (_iterator76.s(); !(_step76 = _iterator76.n()).done;) {
                        var option = _step76.value;

                        if (option.attributes.value === storedData.value) {
                          option.attributes.selected = true;
                        }
                      }
                    } catch (err) {
                      _iterator76.e(err);
                    } finally {
                      _iterator76.f();
                    }
                  }

                  html.addEventListener("input", function (event) {
                    var options = event.target.options;
                    var value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                    storage.setValue(id, {
                      value: value
                    });
                  });
                  break;
              }
            }
          }, {
            key: "setAttributes",
            value: function setAttributes(_ref57) {
              var html = _ref57.html,
                  element = _ref57.element,
                  _ref57$storage = _ref57.storage,
                  storage = _ref57$storage === void 0 ? null : _ref57$storage,
                  intent = _ref57.intent,
                  linkService = _ref57.linkService;
              var attributes = element.attributes;
              var isHTMLAnchorElement = html instanceof HTMLAnchorElement;

              if (attributes.type === "radio") {
                attributes.name = "".concat(attributes.name, "-").concat(intent);
              }

              for (var _i18 = 0, _Object$entries2 = Object.entries(attributes); _i18 < _Object$entries2.length; _i18++) {
                var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i18], 2),
                    key = _Object$entries2$_i[0],
                    value = _Object$entries2$_i[1];

                if (value === null || value === undefined || key === "dataId") {
                  continue;
                }

                if (key !== "style") {
                  if (key === "textContent") {
                    html.textContent = value;
                  } else if (key === "class") {
                    html.setAttribute(key, value.join(" "));
                  } else {
                    if (isHTMLAnchorElement && (key === "href" || key === "newWindow")) {
                      continue;
                    }

                    html.setAttribute(key, value);
                  }
                } else {
                  Object.assign(html.style, value);
                }
              }

              if (isHTMLAnchorElement) {
                var _linkService$addLinkA2;

                if (!linkService.addLinkAttributes) {
                  (0, _util.warn)("XfaLayer.setAttribute - missing `addLinkAttributes`-method on the `linkService`-instance.");
                }

                (_linkService$addLinkA2 = linkService.addLinkAttributes) === null || _linkService$addLinkA2 === void 0 ? void 0 : _linkService$addLinkA2.call(linkService, html, attributes.href, attributes.newWindow);
              }

              if (storage && attributes.dataId) {
                this.setupStorage(html, attributes.dataId, element, storage);
              }
            }
          }, {
            key: "render",
            value: function render(parameters) {
              var storage = parameters.annotationStorage;
              var linkService = parameters.linkService;
              var root = parameters.xfa;
              var intent = parameters.intent || "display";
              var rootHtml = document.createElement(root.name);

              if (root.attributes) {
                this.setAttributes({
                  html: rootHtml,
                  element: root,
                  intent: intent,
                  linkService: linkService
                });
              }

              var stack = [[root, -1, rootHtml]];
              var rootDiv = parameters.div;
              rootDiv.appendChild(rootHtml);
              var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
              rootDiv.style.transform = transform;
              rootDiv.setAttribute("class", "xfaLayer xfaFont");
              var textDivs = [];

              while (stack.length > 0) {
                var _child$attributes;

                var _stack = _slicedToArray(stack[stack.length - 1], 3),
                    parent = _stack[0],
                    i = _stack[1],
                    html = _stack[2];

                if (i + 1 === parent.children.length) {
                  stack.pop();
                  continue;
                }

                var child = parent.children[++stack[stack.length - 1][1]];

                if (child === null) {
                  continue;
                }

                var name = child.name;

                if (name === "#text") {
                  var node = document.createTextNode(child.value);
                  textDivs.push(node);
                  html.appendChild(node);
                  continue;
                }

                var childHtml = void 0;

                if (child !== null && child !== void 0 && (_child$attributes = child.attributes) !== null && _child$attributes !== void 0 && _child$attributes.xmlns) {
                  childHtml = document.createElementNS(child.attributes.xmlns, name);
                } else {
                  childHtml = document.createElement(name);
                }

                html.appendChild(childHtml);

                if (child.attributes) {
                  this.setAttributes({
                    html: childHtml,
                    element: child,
                    storage: storage,
                    intent: intent,
                    linkService: linkService
                  });
                }

                if (child.children && child.children.length > 0) {
                  stack.push([child, -1, childHtml]);
                } else if (child.value) {
                  var _node = document.createTextNode(child.value);

                  if (_xfa_text.XfaText.shouldBuildText(name)) {
                    textDivs.push(_node);
                  }

                  childHtml.appendChild(_node);
                }
              }

              var _iterator77 = _createForOfIteratorHelper(rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")),
                  _step77;

              try {
                for (_iterator77.s(); !(_step77 = _iterator77.n()).done;) {
                  var el = _step77.value;
                  el.setAttribute("readOnly", true);
                }
              } catch (err) {
                _iterator77.e(err);
              } finally {
                _iterator77.f();
              }

              return {
                textDivs: textDivs
              };
            }
          }, {
            key: "update",
            value: function update(parameters) {
              var transform = "matrix(".concat(parameters.viewport.transform.join(","), ")");
              parameters.div.style.transform = transform;
              parameters.div.hidden = false;
            }
          }]);

          return XfaLayer;
        }();

        exports.XfaLayer = XfaLayer;
        /***/
      },
      /* 23 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFNodeStream = void 0;

        var _util = __w_pdfjs_require__(2);

        var _network_utils = __w_pdfjs_require__(24);

        ;

        var fs = __webpack_require__(17);

        var http = __webpack_require__(20);

        var https = __webpack_require__(21);

        var url = __webpack_require__(22);

        var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;

        function parseUrl(sourceUrl) {
          var parsedUrl = url.parse(sourceUrl);

          if (parsedUrl.protocol === "file:" || parsedUrl.host) {
            return parsedUrl;
          }

          if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
            return url.parse("file:///".concat(sourceUrl));
          }

          if (!parsedUrl.host) {
            parsedUrl.protocol = "file:";
          }

          return parsedUrl;
        }

        var PDFNodeStream = /*#__PURE__*/function () {
          function PDFNodeStream(source) {
            _classCallCheck(this, PDFNodeStream);

            this.source = source;
            this.url = parseUrl(source.url);
            this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:";
            this.isFsUrl = this.url.protocol === "file:";
            this.httpHeaders = this.isHttp && source.httpHeaders || {};
            this._fullRequestReader = null;
            this._rangeRequestReaders = [];
          }

          _createClass(PDFNodeStream, [{
            key: "_progressiveDataLength",
            get: function get() {
              var _this$_fullRequestRea3, _this$_fullRequestRea4;

              return (_this$_fullRequestRea3 = (_this$_fullRequestRea4 = this._fullRequestReader) === null || _this$_fullRequestRea4 === void 0 ? void 0 : _this$_fullRequestRea4._loaded) !== null && _this$_fullRequestRea3 !== void 0 ? _this$_fullRequestRea3 : 0;
            }
          }, {
            key: "getFullReader",
            value: function getFullReader() {
              (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
              this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);
              return this._fullRequestReader;
            }
          }, {
            key: "getRangeReader",
            value: function getRangeReader(start, end) {
              if (end <= this._progressiveDataLength) {
                return null;
              }

              var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);

              this._rangeRequestReaders.push(rangeReader);

              return rangeReader;
            }
          }, {
            key: "cancelAllRequests",
            value: function cancelAllRequests(reason) {
              if (this._fullRequestReader) {
                this._fullRequestReader.cancel(reason);
              }

              var _iterator78 = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),
                  _step78;

              try {
                for (_iterator78.s(); !(_step78 = _iterator78.n()).done;) {
                  var reader = _step78.value;
                  reader.cancel(reason);
                }
              } catch (err) {
                _iterator78.e(err);
              } finally {
                _iterator78.f();
              }
            }
          }]);

          return PDFNodeStream;
        }();

        exports.PDFNodeStream = PDFNodeStream;

        var BaseFullReader = /*#__PURE__*/function () {
          function BaseFullReader(stream) {
            _classCallCheck(this, BaseFullReader);

            this._url = stream.url;
            this._done = false;
            this._storedError = null;
            this.onProgress = null;
            var source = stream.source;
            this._contentLength = source.length;
            this._loaded = 0;
            this._filename = null;
            this._disableRange = source.disableRange || false;
            this._rangeChunkSize = source.rangeChunkSize;

            if (!this._rangeChunkSize && !this._disableRange) {
              this._disableRange = true;
            }

            this._isStreamingSupported = !source.disableStream;
            this._isRangeSupported = !source.disableRange;
            this._readableStream = null;
            this._readCapability = (0, _util.createPromiseCapability)();
            this._headersCapability = (0, _util.createPromiseCapability)();
          }

          _createClass(BaseFullReader, [{
            key: "headersReady",
            get: function get() {
              return this._headersCapability.promise;
            }
          }, {
            key: "filename",
            get: function get() {
              return this._filename;
            }
          }, {
            key: "contentLength",
            get: function get() {
              return this._contentLength;
            }
          }, {
            key: "isRangeSupported",
            get: function get() {
              return this._isRangeSupported;
            }
          }, {
            key: "isStreamingSupported",
            get: function get() {
              return this._isStreamingSupported;
            }
          }, {
            key: "read",
            value: function () {
              var _read3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
                var chunk, buffer;
                return _regeneratorRuntime().wrap(function _callee14$(_context14) {
                  while (1) {
                    switch (_context14.prev = _context14.next) {
                      case 0:
                        _context14.next = 2;
                        return this._readCapability.promise;

                      case 2:
                        if (!this._done) {
                          _context14.next = 4;
                          break;
                        }

                        return _context14.abrupt("return", {
                          value: undefined,
                          done: true
                        });

                      case 4:
                        if (!this._storedError) {
                          _context14.next = 6;
                          break;
                        }

                        throw this._storedError;

                      case 6:
                        chunk = this._readableStream.read();

                        if (!(chunk === null)) {
                          _context14.next = 10;
                          break;
                        }

                        this._readCapability = (0, _util.createPromiseCapability)();
                        return _context14.abrupt("return", this.read());

                      case 10:
                        this._loaded += chunk.length;

                        if (this.onProgress) {
                          this.onProgress({
                            loaded: this._loaded,
                            total: this._contentLength
                          });
                        }

                        buffer = new Uint8Array(chunk).buffer;
                        return _context14.abrupt("return", {
                          value: buffer,
                          done: false
                        });

                      case 14:
                      case "end":
                        return _context14.stop();
                    }
                  }
                }, _callee14, this);
              }));

              function read() {
                return _read3.apply(this, arguments);
              }

              return read;
            }()
          }, {
            key: "cancel",
            value: function cancel(reason) {
              if (!this._readableStream) {
                this._error(reason);

                return;
              }

              this._readableStream.destroy(reason);
            }
          }, {
            key: "_error",
            value: function _error(reason) {
              this._storedError = reason;

              this._readCapability.resolve();
            }
          }, {
            key: "_setReadableStream",
            value: function _setReadableStream(readableStream) {
              var _this50 = this;

              this._readableStream = readableStream;
              readableStream.on("readable", function () {
                _this50._readCapability.resolve();
              });
              readableStream.on("end", function () {
                readableStream.destroy();
                _this50._done = true;

                _this50._readCapability.resolve();
              });
              readableStream.on("error", function (reason) {
                _this50._error(reason);
              });

              if (!this._isStreamingSupported && this._isRangeSupported) {
                this._error(new _util.AbortException("streaming is disabled"));
              }

              if (this._storedError) {
                this._readableStream.destroy(this._storedError);
              }
            }
          }]);

          return BaseFullReader;
        }();

        var BaseRangeReader = /*#__PURE__*/function () {
          function BaseRangeReader(stream) {
            _classCallCheck(this, BaseRangeReader);

            this._url = stream.url;
            this._done = false;
            this._storedError = null;
            this.onProgress = null;
            this._loaded = 0;
            this._readableStream = null;
            this._readCapability = (0, _util.createPromiseCapability)();
            var source = stream.source;
            this._isStreamingSupported = !source.disableStream;
          }

          _createClass(BaseRangeReader, [{
            key: "isStreamingSupported",
            get: function get() {
              return this._isStreamingSupported;
            }
          }, {
            key: "read",
            value: function () {
              var _read4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
                var chunk, buffer;
                return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                  while (1) {
                    switch (_context15.prev = _context15.next) {
                      case 0:
                        _context15.next = 2;
                        return this._readCapability.promise;

                      case 2:
                        if (!this._done) {
                          _context15.next = 4;
                          break;
                        }

                        return _context15.abrupt("return", {
                          value: undefined,
                          done: true
                        });

                      case 4:
                        if (!this._storedError) {
                          _context15.next = 6;
                          break;
                        }

                        throw this._storedError;

                      case 6:
                        chunk = this._readableStream.read();

                        if (!(chunk === null)) {
                          _context15.next = 10;
                          break;
                        }

                        this._readCapability = (0, _util.createPromiseCapability)();
                        return _context15.abrupt("return", this.read());

                      case 10:
                        this._loaded += chunk.length;

                        if (this.onProgress) {
                          this.onProgress({
                            loaded: this._loaded
                          });
                        }

                        buffer = new Uint8Array(chunk).buffer;
                        return _context15.abrupt("return", {
                          value: buffer,
                          done: false
                        });

                      case 14:
                      case "end":
                        return _context15.stop();
                    }
                  }
                }, _callee15, this);
              }));

              function read() {
                return _read4.apply(this, arguments);
              }

              return read;
            }()
          }, {
            key: "cancel",
            value: function cancel(reason) {
              if (!this._readableStream) {
                this._error(reason);

                return;
              }

              this._readableStream.destroy(reason);
            }
          }, {
            key: "_error",
            value: function _error(reason) {
              this._storedError = reason;

              this._readCapability.resolve();
            }
          }, {
            key: "_setReadableStream",
            value: function _setReadableStream(readableStream) {
              var _this51 = this;

              this._readableStream = readableStream;
              readableStream.on("readable", function () {
                _this51._readCapability.resolve();
              });
              readableStream.on("end", function () {
                readableStream.destroy();
                _this51._done = true;

                _this51._readCapability.resolve();
              });
              readableStream.on("error", function (reason) {
                _this51._error(reason);
              });

              if (this._storedError) {
                this._readableStream.destroy(this._storedError);
              }
            }
          }]);

          return BaseRangeReader;
        }();

        function createRequestOptions(parsedUrl, headers) {
          return {
            protocol: parsedUrl.protocol,
            auth: parsedUrl.auth,
            host: parsedUrl.hostname,
            port: parsedUrl.port,
            path: parsedUrl.path,
            method: "GET",
            headers: headers
          };
        }

        var PDFNodeStreamFullReader = /*#__PURE__*/function (_BaseFullReader) {
          _inherits(PDFNodeStreamFullReader, _BaseFullReader);

          var _super43 = _createSuper(PDFNodeStreamFullReader);

          function PDFNodeStreamFullReader(stream) {
            var _this52;

            _classCallCheck(this, PDFNodeStreamFullReader);

            _this52 = _super43.call(this, stream);

            var handleResponse = function handleResponse(response) {
              if (response.statusCode === 404) {
                var error = new _util.MissingPDFException("Missing PDF \"".concat(_this52._url, "\"."));
                _this52._storedError = error;

                _this52._headersCapability.reject(error);

                return;
              }

              _this52._headersCapability.resolve();

              _this52._setReadableStream(response);

              var getResponseHeader = function getResponseHeader(name) {
                return _this52._readableStream.headers[name.toLowerCase()];
              };

              var _ref58 = (0, _network_utils.validateRangeRequestCapabilities)({
                getResponseHeader: getResponseHeader,
                isHttp: stream.isHttp,
                rangeChunkSize: _this52._rangeChunkSize,
                disableRange: _this52._disableRange
              }),
                  allowRangeRequests = _ref58.allowRangeRequests,
                  suggestedLength = _ref58.suggestedLength;

              _this52._isRangeSupported = allowRangeRequests;
              _this52._contentLength = suggestedLength || _this52._contentLength;
              _this52._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);
            };

            _this52._request = null;

            if (_this52._url.protocol === "http:") {
              _this52._request = http.request(createRequestOptions(_this52._url, stream.httpHeaders), handleResponse);
            } else {
              _this52._request = https.request(createRequestOptions(_this52._url, stream.httpHeaders), handleResponse);
            }

            _this52._request.on("error", function (reason) {
              _this52._storedError = reason;

              _this52._headersCapability.reject(reason);
            });

            _this52._request.end();

            return _this52;
          }

          return _createClass(PDFNodeStreamFullReader);
        }(BaseFullReader);

        var PDFNodeStreamRangeReader = /*#__PURE__*/function (_BaseRangeReader) {
          _inherits(PDFNodeStreamRangeReader, _BaseRangeReader);

          var _super44 = _createSuper(PDFNodeStreamRangeReader);

          function PDFNodeStreamRangeReader(stream, start, end) {
            var _this53;

            _classCallCheck(this, PDFNodeStreamRangeReader);

            _this53 = _super44.call(this, stream);
            _this53._httpHeaders = {};

            for (var property in stream.httpHeaders) {
              var value = stream.httpHeaders[property];

              if (typeof value === "undefined") {
                continue;
              }

              _this53._httpHeaders[property] = value;
            }

            _this53._httpHeaders.Range = "bytes=".concat(start, "-").concat(end - 1);

            var handleResponse = function handleResponse(response) {
              if (response.statusCode === 404) {
                var error = new _util.MissingPDFException("Missing PDF \"".concat(_this53._url, "\"."));
                _this53._storedError = error;
                return;
              }

              _this53._setReadableStream(response);
            };

            _this53._request = null;

            if (_this53._url.protocol === "http:") {
              _this53._request = http.request(createRequestOptions(_this53._url, _this53._httpHeaders), handleResponse);
            } else {
              _this53._request = https.request(createRequestOptions(_this53._url, _this53._httpHeaders), handleResponse);
            }

            _this53._request.on("error", function (reason) {
              _this53._storedError = reason;
            });

            _this53._request.end();

            return _this53;
          }

          return _createClass(PDFNodeStreamRangeReader);
        }(BaseRangeReader);

        var PDFNodeStreamFsFullReader = /*#__PURE__*/function (_BaseFullReader2) {
          _inherits(PDFNodeStreamFsFullReader, _BaseFullReader2);

          var _super45 = _createSuper(PDFNodeStreamFsFullReader);

          function PDFNodeStreamFsFullReader(stream) {
            var _this54;

            _classCallCheck(this, PDFNodeStreamFsFullReader);

            _this54 = _super45.call(this, stream);
            var path = decodeURIComponent(_this54._url.path);

            if (fileUriRegex.test(_this54._url.href)) {
              path = path.replace(/^\//, "");
            }

            fs.lstat(path, function (error, stat) {
              if (error) {
                if (error.code === "ENOENT") {
                  error = new _util.MissingPDFException("Missing PDF \"".concat(path, "\"."));
                }

                _this54._storedError = error;

                _this54._headersCapability.reject(error);

                return;
              }

              _this54._contentLength = stat.size;

              _this54._setReadableStream(fs.createReadStream(path));

              _this54._headersCapability.resolve();
            });
            return _this54;
          }

          return _createClass(PDFNodeStreamFsFullReader);
        }(BaseFullReader);

        var PDFNodeStreamFsRangeReader = /*#__PURE__*/function (_BaseRangeReader2) {
          _inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2);

          var _super46 = _createSuper(PDFNodeStreamFsRangeReader);

          function PDFNodeStreamFsRangeReader(stream, start, end) {
            var _this55;

            _classCallCheck(this, PDFNodeStreamFsRangeReader);

            _this55 = _super46.call(this, stream);
            var path = decodeURIComponent(_this55._url.path);

            if (fileUriRegex.test(_this55._url.href)) {
              path = path.replace(/^\//, "");
            }

            _this55._setReadableStream(fs.createReadStream(path, {
              start: start,
              end: end - 1
            }));

            return _this55;
          }

          return _createClass(PDFNodeStreamFsRangeReader);
        }(BaseRangeReader);
        /***/

      },
      /* 24 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.createResponseStatusError = createResponseStatusError;
        exports.extractFilenameFromHeader = extractFilenameFromHeader;
        exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;
        exports.validateResponseStatus = validateResponseStatus;

        var _util = __w_pdfjs_require__(2);

        var _content_disposition = __w_pdfjs_require__(25);

        var _display_utils = __w_pdfjs_require__(1);

        function validateRangeRequestCapabilities(_ref59) {
          var getResponseHeader = _ref59.getResponseHeader,
              isHttp = _ref59.isHttp,
              rangeChunkSize = _ref59.rangeChunkSize,
              disableRange = _ref59.disableRange;
          (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero");
          var returnValues = {
            allowRangeRequests: false,
            suggestedLength: undefined
          };
          var length = parseInt(getResponseHeader("Content-Length"), 10);

          if (!Number.isInteger(length)) {
            return returnValues;
          }

          returnValues.suggestedLength = length;

          if (length <= 2 * rangeChunkSize) {
            return returnValues;
          }

          if (disableRange || !isHttp) {
            return returnValues;
          }

          if (getResponseHeader("Accept-Ranges") !== "bytes") {
            return returnValues;
          }

          var contentEncoding = getResponseHeader("Content-Encoding") || "identity";

          if (contentEncoding !== "identity") {
            return returnValues;
          }

          returnValues.allowRangeRequests = true;
          return returnValues;
        }

        function extractFilenameFromHeader(getResponseHeader) {
          var contentDisposition = getResponseHeader("Content-Disposition");

          if (contentDisposition) {
            var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);

            if (filename.includes("%")) {
              try {
                filename = decodeURIComponent(filename);
              } catch (ex) {}
            }

            if ((0, _display_utils.isPdfFile)(filename)) {
              return filename;
            }
          }

          return null;
        }

        function createResponseStatusError(status, url) {
          if (status === 404 || status === 0 && url.startsWith("file:")) {
            return new _util.MissingPDFException('Missing PDF "' + url + '".');
          }

          return new _util.UnexpectedResponseException("Unexpected server response (".concat(status, ") while retrieving PDF \"").concat(url, "\"."), status);
        }

        function validateResponseStatus(status) {
          return status === 200 || status === 206;
        }
        /***/

      },
      /* 25 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;

        var _util = __w_pdfjs_require__(2);

        function getFilenameFromContentDispositionHeader(contentDisposition) {
          var needsEncodingFixup = true;
          var tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);

          if (tmp) {
            tmp = tmp[1];
            var filename = rfc2616unquote(tmp);
            filename = unescape(filename);
            filename = rfc5987decode(filename);
            filename = rfc2047decode(filename);
            return fixupEncoding(filename);
          }

          tmp = rfc2231getparam(contentDisposition);

          if (tmp) {
            var _filename = rfc2047decode(tmp);

            return fixupEncoding(_filename);
          }

          tmp = toParamRegExp("filename", "i").exec(contentDisposition);

          if (tmp) {
            tmp = tmp[1];

            var _filename2 = rfc2616unquote(tmp);

            _filename2 = rfc2047decode(_filename2);
            return fixupEncoding(_filename2);
          }

          function toParamRegExp(attributePattern, flags) {
            return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
          }

          function textdecode(encoding, value) {
            if (encoding) {
              if (!/^[\x00-\xFF]+$/.test(value)) {
                return value;
              }

              try {
                var decoder = new TextDecoder(encoding, {
                  fatal: true
                });
                var buffer = (0, _util.stringToBytes)(value);
                value = decoder.decode(buffer);
                needsEncodingFixup = false;
              } catch (e) {
                if (/^utf-?8$/i.test(encoding)) {
                  try {
                    value = decodeURIComponent(escape(value));
                    needsEncodingFixup = false;
                  } catch (err) {}
                }
              }
            }

            return value;
          }

          function fixupEncoding(value) {
            if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
              value = textdecode("utf-8", value);

              if (needsEncodingFixup) {
                value = textdecode("iso-8859-1", value);
              }
            }

            return value;
          }

          function rfc2231getparam(contentDispositionStr) {
            var matches = [];
            var match;
            var iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");

            while ((match = iter.exec(contentDispositionStr)) !== null) {
              var _match = match,
                  _match2 = _slicedToArray(_match, 4),
                  n = _match2[1],
                  quot = _match2[2],
                  part = _match2[3];

              n = parseInt(n, 10);

              if (n in matches) {
                if (n === 0) {
                  break;
                }

                continue;
              }

              matches[n] = [quot, part];
            }

            var parts = [];

            for (var _n2 = 0; _n2 < matches.length; ++_n2) {
              if (!(_n2 in matches)) {
                break;
              }

              var _matches$_n = _slicedToArray(matches[_n2], 2),
                  _quot = _matches$_n[0],
                  _part = _matches$_n[1];

              _part = rfc2616unquote(_part);

              if (_quot) {
                _part = unescape(_part);

                if (_n2 === 0) {
                  _part = rfc5987decode(_part);
                }
              }

              parts.push(_part);
            }

            return parts.join("");
          }

          function rfc2616unquote(value) {
            if (value.startsWith('"')) {
              var parts = value.slice(1).split('\\"');

              for (var i = 0; i < parts.length; ++i) {
                var quotindex = parts[i].indexOf('"');

                if (quotindex !== -1) {
                  parts[i] = parts[i].slice(0, quotindex);
                  parts.length = i + 1;
                }

                parts[i] = parts[i].replace(/\\(.)/g, "$1");
              }

              value = parts.join('"');
            }

            return value;
          }

          function rfc5987decode(extvalue) {
            var encodingend = extvalue.indexOf("'");

            if (encodingend === -1) {
              return extvalue;
            }

            var encoding = extvalue.slice(0, encodingend);
            var langvalue = extvalue.slice(encodingend + 1);
            var value = langvalue.replace(/^[^']*'/, "");
            return textdecode(encoding, value);
          }

          function rfc2047decode(value) {
            if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
              return value;
            }

            return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
              if (encoding === "q" || encoding === "Q") {
                text = text.replace(/_/g, " ");
                text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {
                  return String.fromCharCode(parseInt(hex, 16));
                });
                return textdecode(charset, text);
              }

              try {
                text = atob(text);
              } catch (e) {}

              return textdecode(charset, text);
            });
          }

          return "";
        }
        /***/

      },
      /* 26 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFNetworkStream = void 0;

        var _util = __w_pdfjs_require__(2);

        var _network_utils = __w_pdfjs_require__(24);

        ;
        var OK_RESPONSE = 200;
        var PARTIAL_CONTENT_RESPONSE = 206;

        function getArrayBuffer(xhr) {
          var data = xhr.response;

          if (typeof data !== "string") {
            return data;
          }

          var array = (0, _util.stringToBytes)(data);
          return array.buffer;
        }

        var NetworkManager = /*#__PURE__*/function () {
          function NetworkManager(url) {
            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            _classCallCheck(this, NetworkManager);

            this.url = url;
            this.isHttp = /^https?:/i.test(url);
            this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);
            this.withCredentials = args.withCredentials || false;

            this.getXhr = args.getXhr || function NetworkManager_getXhr() {
              return new XMLHttpRequest();
            };

            this.currXhrId = 0;
            this.pendingRequests = Object.create(null);
          }

          _createClass(NetworkManager, [{
            key: "requestRange",
            value: function requestRange(begin, end, listeners) {
              var args = {
                begin: begin,
                end: end
              };

              for (var prop in listeners) {
                args[prop] = listeners[prop];
              }

              return this.request(args);
            }
          }, {
            key: "requestFull",
            value: function requestFull(listeners) {
              return this.request(listeners);
            }
          }, {
            key: "request",
            value: function request(args) {
              var xhr = this.getXhr();
              var xhrId = this.currXhrId++;
              var pendingRequest = this.pendingRequests[xhrId] = {
                xhr: xhr
              };
              xhr.open("GET", this.url);
              xhr.withCredentials = this.withCredentials;

              for (var property in this.httpHeaders) {
                var value = this.httpHeaders[property];

                if (typeof value === "undefined") {
                  continue;
                }

                xhr.setRequestHeader(property, value);
              }

              if (this.isHttp && "begin" in args && "end" in args) {
                xhr.setRequestHeader("Range", "bytes=".concat(args.begin, "-").concat(args.end - 1));
                pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
              } else {
                pendingRequest.expectedStatus = OK_RESPONSE;
              }

              xhr.responseType = "arraybuffer";

              if (args.onError) {
                xhr.onerror = function (evt) {
                  args.onError(xhr.status);
                };
              }

              xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
              xhr.onprogress = this.onProgress.bind(this, xhrId);
              pendingRequest.onHeadersReceived = args.onHeadersReceived;
              pendingRequest.onDone = args.onDone;
              pendingRequest.onError = args.onError;
              pendingRequest.onProgress = args.onProgress;
              xhr.send(null);
              return xhrId;
            }
          }, {
            key: "onProgress",
            value: function onProgress(xhrId, evt) {
              var _pendingRequest$onPro;

              var pendingRequest = this.pendingRequests[xhrId];

              if (!pendingRequest) {
                return;
              }

              (_pendingRequest$onPro = pendingRequest.onProgress) === null || _pendingRequest$onPro === void 0 ? void 0 : _pendingRequest$onPro.call(pendingRequest, evt);
            }
          }, {
            key: "onStateChange",
            value: function onStateChange(xhrId, evt) {
              var pendingRequest = this.pendingRequests[xhrId];

              if (!pendingRequest) {
                return;
              }

              var xhr = pendingRequest.xhr;

              if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
                pendingRequest.onHeadersReceived();
                delete pendingRequest.onHeadersReceived;
              }

              if (xhr.readyState !== 4) {
                return;
              }

              if (!(xhrId in this.pendingRequests)) {
                return;
              }

              delete this.pendingRequests[xhrId];

              if (xhr.status === 0 && this.isHttp) {
                var _pendingRequest$onErr;

                (_pendingRequest$onErr = pendingRequest.onError) === null || _pendingRequest$onErr === void 0 ? void 0 : _pendingRequest$onErr.call(pendingRequest, xhr.status);
                return;
              }

              var xhrStatus = xhr.status || OK_RESPONSE;
              var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;

              if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
                var _pendingRequest$onErr2;

                (_pendingRequest$onErr2 = pendingRequest.onError) === null || _pendingRequest$onErr2 === void 0 ? void 0 : _pendingRequest$onErr2.call(pendingRequest, xhr.status);
                return;
              }

              var chunk = getArrayBuffer(xhr);

              if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
                var rangeHeader = xhr.getResponseHeader("Content-Range");
                var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
                pendingRequest.onDone({
                  begin: parseInt(matches[1], 10),
                  chunk: chunk
                });
              } else if (chunk) {
                pendingRequest.onDone({
                  begin: 0,
                  chunk: chunk
                });
              } else {
                var _pendingRequest$onErr3;

                (_pendingRequest$onErr3 = pendingRequest.onError) === null || _pendingRequest$onErr3 === void 0 ? void 0 : _pendingRequest$onErr3.call(pendingRequest, xhr.status);
              }
            }
          }, {
            key: "getRequestXhr",
            value: function getRequestXhr(xhrId) {
              return this.pendingRequests[xhrId].xhr;
            }
          }, {
            key: "isPendingRequest",
            value: function isPendingRequest(xhrId) {
              return xhrId in this.pendingRequests;
            }
          }, {
            key: "abortRequest",
            value: function abortRequest(xhrId) {
              var xhr = this.pendingRequests[xhrId].xhr;
              delete this.pendingRequests[xhrId];
              xhr.abort();
            }
          }]);

          return NetworkManager;
        }();

        var PDFNetworkStream = /*#__PURE__*/function () {
          function PDFNetworkStream(source) {
            _classCallCheck(this, PDFNetworkStream);

            this._source = source;
            this._manager = new NetworkManager(source.url, {
              httpHeaders: source.httpHeaders,
              withCredentials: source.withCredentials
            });
            this._rangeChunkSize = source.rangeChunkSize;
            this._fullRequestReader = null;
            this._rangeRequestReaders = [];
          }

          _createClass(PDFNetworkStream, [{
            key: "_onRangeRequestReaderClosed",
            value: function _onRangeRequestReaderClosed(reader) {
              var i = this._rangeRequestReaders.indexOf(reader);

              if (i >= 0) {
                this._rangeRequestReaders.splice(i, 1);
              }
            }
          }, {
            key: "getFullReader",
            value: function getFullReader() {
              (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
              this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
              return this._fullRequestReader;
            }
          }, {
            key: "getRangeReader",
            value: function getRangeReader(begin, end) {
              var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
              reader.onClosed = this._onRangeRequestReaderClosed.bind(this);

              this._rangeRequestReaders.push(reader);

              return reader;
            }
          }, {
            key: "cancelAllRequests",
            value: function cancelAllRequests(reason) {
              var _this$_fullRequestRea5;

              (_this$_fullRequestRea5 = this._fullRequestReader) === null || _this$_fullRequestRea5 === void 0 ? void 0 : _this$_fullRequestRea5.cancel(reason);

              var _iterator79 = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),
                  _step79;

              try {
                for (_iterator79.s(); !(_step79 = _iterator79.n()).done;) {
                  var reader = _step79.value;
                  reader.cancel(reason);
                }
              } catch (err) {
                _iterator79.e(err);
              } finally {
                _iterator79.f();
              }
            }
          }]);

          return PDFNetworkStream;
        }();

        exports.PDFNetworkStream = PDFNetworkStream;

        var PDFNetworkStreamFullRequestReader = /*#__PURE__*/function () {
          function PDFNetworkStreamFullRequestReader(manager, source) {
            _classCallCheck(this, PDFNetworkStreamFullRequestReader);

            this._manager = manager;
            var args = {
              onHeadersReceived: this._onHeadersReceived.bind(this),
              onDone: this._onDone.bind(this),
              onError: this._onError.bind(this),
              onProgress: this._onProgress.bind(this)
            };
            this._url = source.url;
            this._fullRequestId = manager.requestFull(args);
            this._headersReceivedCapability = (0, _util.createPromiseCapability)();
            this._disableRange = source.disableRange || false;
            this._contentLength = source.length;
            this._rangeChunkSize = source.rangeChunkSize;

            if (!this._rangeChunkSize && !this._disableRange) {
              this._disableRange = true;
            }

            this._isStreamingSupported = false;
            this._isRangeSupported = false;
            this._cachedChunks = [];
            this._requests = [];
            this._done = false;
            this._storedError = undefined;
            this._filename = null;
            this.onProgress = null;
          }

          _createClass(PDFNetworkStreamFullRequestReader, [{
            key: "_onHeadersReceived",
            value: function _onHeadersReceived() {
              var fullRequestXhrId = this._fullRequestId;

              var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);

              var getResponseHeader = function getResponseHeader(name) {
                return fullRequestXhr.getResponseHeader(name);
              };

              var _ref60 = (0, _network_utils.validateRangeRequestCapabilities)({
                getResponseHeader: getResponseHeader,
                isHttp: this._manager.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              }),
                  allowRangeRequests = _ref60.allowRangeRequests,
                  suggestedLength = _ref60.suggestedLength;

              if (allowRangeRequests) {
                this._isRangeSupported = true;
              }

              this._contentLength = suggestedLength || this._contentLength;
              this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

              if (this._isRangeSupported) {
                this._manager.abortRequest(fullRequestXhrId);
              }

              this._headersReceivedCapability.resolve();
            }
          }, {
            key: "_onDone",
            value: function _onDone(data) {
              if (data) {
                if (this._requests.length > 0) {
                  var requestCapability = this._requests.shift();

                  requestCapability.resolve({
                    value: data.chunk,
                    done: false
                  });
                } else {
                  this._cachedChunks.push(data.chunk);
                }
              }

              this._done = true;

              if (this._cachedChunks.length > 0) {
                return;
              }

              var _iterator80 = _createForOfIteratorHelper(this._requests),
                  _step80;

              try {
                for (_iterator80.s(); !(_step80 = _iterator80.n()).done;) {
                  var _requestCapability = _step80.value;

                  _requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                }
              } catch (err) {
                _iterator80.e(err);
              } finally {
                _iterator80.f();
              }

              this._requests.length = 0;
            }
          }, {
            key: "_onError",
            value: function _onError(status) {
              this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

              this._headersReceivedCapability.reject(this._storedError);

              var _iterator81 = _createForOfIteratorHelper(this._requests),
                  _step81;

              try {
                for (_iterator81.s(); !(_step81 = _iterator81.n()).done;) {
                  var requestCapability = _step81.value;
                  requestCapability.reject(this._storedError);
                }
              } catch (err) {
                _iterator81.e(err);
              } finally {
                _iterator81.f();
              }

              this._requests.length = 0;
              this._cachedChunks.length = 0;
            }
          }, {
            key: "_onProgress",
            value: function _onProgress(evt) {
              var _this$onProgress;

              (_this$onProgress = this.onProgress) === null || _this$onProgress === void 0 ? void 0 : _this$onProgress.call(this, {
                loaded: evt.loaded,
                total: evt.lengthComputable ? evt.total : this._contentLength
              });
            }
          }, {
            key: "filename",
            get: function get() {
              return this._filename;
            }
          }, {
            key: "isRangeSupported",
            get: function get() {
              return this._isRangeSupported;
            }
          }, {
            key: "isStreamingSupported",
            get: function get() {
              return this._isStreamingSupported;
            }
          }, {
            key: "contentLength",
            get: function get() {
              return this._contentLength;
            }
          }, {
            key: "headersReady",
            get: function get() {
              return this._headersReceivedCapability.promise;
            }
          }, {
            key: "read",
            value: function () {
              var _read5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
                var chunk, requestCapability;
                return _regeneratorRuntime().wrap(function _callee16$(_context16) {
                  while (1) {
                    switch (_context16.prev = _context16.next) {
                      case 0:
                        if (!this._storedError) {
                          _context16.next = 2;
                          break;
                        }

                        throw this._storedError;

                      case 2:
                        if (!(this._cachedChunks.length > 0)) {
                          _context16.next = 5;
                          break;
                        }

                        chunk = this._cachedChunks.shift();
                        return _context16.abrupt("return", {
                          value: chunk,
                          done: false
                        });

                      case 5:
                        if (!this._done) {
                          _context16.next = 7;
                          break;
                        }

                        return _context16.abrupt("return", {
                          value: undefined,
                          done: true
                        });

                      case 7:
                        requestCapability = (0, _util.createPromiseCapability)();

                        this._requests.push(requestCapability);

                        return _context16.abrupt("return", requestCapability.promise);

                      case 10:
                      case "end":
                        return _context16.stop();
                    }
                  }
                }, _callee16, this);
              }));

              function read() {
                return _read5.apply(this, arguments);
              }

              return read;
            }()
          }, {
            key: "cancel",
            value: function cancel(reason) {
              this._done = true;

              this._headersReceivedCapability.reject(reason);

              var _iterator82 = _createForOfIteratorHelper(this._requests),
                  _step82;

              try {
                for (_iterator82.s(); !(_step82 = _iterator82.n()).done;) {
                  var requestCapability = _step82.value;
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                }
              } catch (err) {
                _iterator82.e(err);
              } finally {
                _iterator82.f();
              }

              this._requests.length = 0;

              if (this._manager.isPendingRequest(this._fullRequestId)) {
                this._manager.abortRequest(this._fullRequestId);
              }

              this._fullRequestReader = null;
            }
          }]);

          return PDFNetworkStreamFullRequestReader;
        }();

        var PDFNetworkStreamRangeRequestReader = /*#__PURE__*/function () {
          function PDFNetworkStreamRangeRequestReader(manager, begin, end) {
            _classCallCheck(this, PDFNetworkStreamRangeRequestReader);

            this._manager = manager;
            var args = {
              onDone: this._onDone.bind(this),
              onError: this._onError.bind(this),
              onProgress: this._onProgress.bind(this)
            };
            this._url = manager.url;
            this._requestId = manager.requestRange(begin, end, args);
            this._requests = [];
            this._queuedChunk = null;
            this._done = false;
            this._storedError = undefined;
            this.onProgress = null;
            this.onClosed = null;
          }

          _createClass(PDFNetworkStreamRangeRequestReader, [{
            key: "_close",
            value: function _close() {
              var _this$onClosed;

              (_this$onClosed = this.onClosed) === null || _this$onClosed === void 0 ? void 0 : _this$onClosed.call(this, this);
            }
          }, {
            key: "_onDone",
            value: function _onDone(data) {
              var chunk = data.chunk;

              if (this._requests.length > 0) {
                var requestCapability = this._requests.shift();

                requestCapability.resolve({
                  value: chunk,
                  done: false
                });
              } else {
                this._queuedChunk = chunk;
              }

              this._done = true;

              var _iterator83 = _createForOfIteratorHelper(this._requests),
                  _step83;

              try {
                for (_iterator83.s(); !(_step83 = _iterator83.n()).done;) {
                  var _requestCapability2 = _step83.value;

                  _requestCapability2.resolve({
                    value: undefined,
                    done: true
                  });
                }
              } catch (err) {
                _iterator83.e(err);
              } finally {
                _iterator83.f();
              }

              this._requests.length = 0;

              this._close();
            }
          }, {
            key: "_onError",
            value: function _onError(status) {
              this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);

              var _iterator84 = _createForOfIteratorHelper(this._requests),
                  _step84;

              try {
                for (_iterator84.s(); !(_step84 = _iterator84.n()).done;) {
                  var requestCapability = _step84.value;
                  requestCapability.reject(this._storedError);
                }
              } catch (err) {
                _iterator84.e(err);
              } finally {
                _iterator84.f();
              }

              this._requests.length = 0;
              this._queuedChunk = null;
            }
          }, {
            key: "_onProgress",
            value: function _onProgress(evt) {
              if (!this.isStreamingSupported) {
                var _this$onProgress2;

                (_this$onProgress2 = this.onProgress) === null || _this$onProgress2 === void 0 ? void 0 : _this$onProgress2.call(this, {
                  loaded: evt.loaded
                });
              }
            }
          }, {
            key: "isStreamingSupported",
            get: function get() {
              return false;
            }
          }, {
            key: "read",
            value: function () {
              var _read6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
                var chunk, requestCapability;
                return _regeneratorRuntime().wrap(function _callee17$(_context17) {
                  while (1) {
                    switch (_context17.prev = _context17.next) {
                      case 0:
                        if (!this._storedError) {
                          _context17.next = 2;
                          break;
                        }

                        throw this._storedError;

                      case 2:
                        if (!(this._queuedChunk !== null)) {
                          _context17.next = 6;
                          break;
                        }

                        chunk = this._queuedChunk;
                        this._queuedChunk = null;
                        return _context17.abrupt("return", {
                          value: chunk,
                          done: false
                        });

                      case 6:
                        if (!this._done) {
                          _context17.next = 8;
                          break;
                        }

                        return _context17.abrupt("return", {
                          value: undefined,
                          done: true
                        });

                      case 8:
                        requestCapability = (0, _util.createPromiseCapability)();

                        this._requests.push(requestCapability);

                        return _context17.abrupt("return", requestCapability.promise);

                      case 11:
                      case "end":
                        return _context17.stop();
                    }
                  }
                }, _callee17, this);
              }));

              function read() {
                return _read6.apply(this, arguments);
              }

              return read;
            }()
          }, {
            key: "cancel",
            value: function cancel(reason) {
              this._done = true;

              var _iterator85 = _createForOfIteratorHelper(this._requests),
                  _step85;

              try {
                for (_iterator85.s(); !(_step85 = _iterator85.n()).done;) {
                  var requestCapability = _step85.value;
                  requestCapability.resolve({
                    value: undefined,
                    done: true
                  });
                }
              } catch (err) {
                _iterator85.e(err);
              } finally {
                _iterator85.f();
              }

              this._requests.length = 0;

              if (this._manager.isPendingRequest(this._requestId)) {
                this._manager.abortRequest(this._requestId);
              }

              this._close();
            }
          }]);

          return PDFNetworkStreamRangeRequestReader;
        }();
        /***/

      },
      /* 27 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFFetchStream = void 0;

        var _util = __w_pdfjs_require__(2);

        var _network_utils = __w_pdfjs_require__(24);

        ;

        function createFetchOptions(headers, withCredentials, abortController) {
          return {
            method: "GET",
            headers: headers,
            signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal,
            mode: "cors",
            credentials: withCredentials ? "include" : "same-origin",
            redirect: "follow"
          };
        }

        function createHeaders(httpHeaders) {
          var headers = new Headers();

          for (var property in httpHeaders) {
            var value = httpHeaders[property];

            if (typeof value === "undefined") {
              continue;
            }

            headers.append(property, value);
          }

          return headers;
        }

        var PDFFetchStream = /*#__PURE__*/function () {
          function PDFFetchStream(source) {
            _classCallCheck(this, PDFFetchStream);

            this.source = source;
            this.isHttp = /^https?:/i.test(source.url);
            this.httpHeaders = this.isHttp && source.httpHeaders || {};
            this._fullRequestReader = null;
            this._rangeRequestReaders = [];
          }

          _createClass(PDFFetchStream, [{
            key: "_progressiveDataLength",
            get: function get() {
              var _this$_fullRequestRea6, _this$_fullRequestRea7;

              return (_this$_fullRequestRea6 = (_this$_fullRequestRea7 = this._fullRequestReader) === null || _this$_fullRequestRea7 === void 0 ? void 0 : _this$_fullRequestRea7._loaded) !== null && _this$_fullRequestRea6 !== void 0 ? _this$_fullRequestRea6 : 0;
            }
          }, {
            key: "getFullReader",
            value: function getFullReader() {
              (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
              this._fullRequestReader = new PDFFetchStreamReader(this);
              return this._fullRequestReader;
            }
          }, {
            key: "getRangeReader",
            value: function getRangeReader(begin, end) {
              if (end <= this._progressiveDataLength) {
                return null;
              }

              var reader = new PDFFetchStreamRangeReader(this, begin, end);

              this._rangeRequestReaders.push(reader);

              return reader;
            }
          }, {
            key: "cancelAllRequests",
            value: function cancelAllRequests(reason) {
              if (this._fullRequestReader) {
                this._fullRequestReader.cancel(reason);
              }

              var _iterator86 = _createForOfIteratorHelper(this._rangeRequestReaders.slice(0)),
                  _step86;

              try {
                for (_iterator86.s(); !(_step86 = _iterator86.n()).done;) {
                  var reader = _step86.value;
                  reader.cancel(reason);
                }
              } catch (err) {
                _iterator86.e(err);
              } finally {
                _iterator86.f();
              }
            }
          }]);

          return PDFFetchStream;
        }();

        exports.PDFFetchStream = PDFFetchStream;

        var PDFFetchStreamReader = /*#__PURE__*/function () {
          function PDFFetchStreamReader(stream) {
            var _this56 = this;

            _classCallCheck(this, PDFFetchStreamReader);

            this._stream = stream;
            this._reader = null;
            this._loaded = 0;
            this._filename = null;
            var source = stream.source;
            this._withCredentials = source.withCredentials || false;
            this._contentLength = source.length;
            this._headersCapability = (0, _util.createPromiseCapability)();
            this._disableRange = source.disableRange || false;
            this._rangeChunkSize = source.rangeChunkSize;

            if (!this._rangeChunkSize && !this._disableRange) {
              this._disableRange = true;
            }

            if (typeof AbortController !== "undefined") {
              this._abortController = new AbortController();
            }

            this._isStreamingSupported = !source.disableStream;
            this._isRangeSupported = !source.disableRange;
            this._headers = createHeaders(this._stream.httpHeaders);
            var url = source.url;
            fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {
              if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                throw (0, _network_utils.createResponseStatusError)(response.status, url);
              }

              _this56._reader = response.body.getReader();

              _this56._headersCapability.resolve();

              var getResponseHeader = function getResponseHeader(name) {
                return response.headers.get(name);
              };

              var _ref61 = (0, _network_utils.validateRangeRequestCapabilities)({
                getResponseHeader: getResponseHeader,
                isHttp: _this56._stream.isHttp,
                rangeChunkSize: _this56._rangeChunkSize,
                disableRange: _this56._disableRange
              }),
                  allowRangeRequests = _ref61.allowRangeRequests,
                  suggestedLength = _ref61.suggestedLength;

              _this56._isRangeSupported = allowRangeRequests;
              _this56._contentLength = suggestedLength || _this56._contentLength;
              _this56._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);

              if (!_this56._isStreamingSupported && _this56._isRangeSupported) {
                _this56.cancel(new _util.AbortException("Streaming is disabled."));
              }
            })["catch"](this._headersCapability.reject);
            this.onProgress = null;
          }

          _createClass(PDFFetchStreamReader, [{
            key: "headersReady",
            get: function get() {
              return this._headersCapability.promise;
            }
          }, {
            key: "filename",
            get: function get() {
              return this._filename;
            }
          }, {
            key: "contentLength",
            get: function get() {
              return this._contentLength;
            }
          }, {
            key: "isRangeSupported",
            get: function get() {
              return this._isRangeSupported;
            }
          }, {
            key: "isStreamingSupported",
            get: function get() {
              return this._isStreamingSupported;
            }
          }, {
            key: "read",
            value: function () {
              var _read7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
                var _yield$this$_reader$r, value, done, buffer;

                return _regeneratorRuntime().wrap(function _callee18$(_context18) {
                  while (1) {
                    switch (_context18.prev = _context18.next) {
                      case 0:
                        _context18.next = 2;
                        return this._headersCapability.promise;

                      case 2:
                        _context18.next = 4;
                        return this._reader.read();

                      case 4:
                        _yield$this$_reader$r = _context18.sent;
                        value = _yield$this$_reader$r.value;
                        done = _yield$this$_reader$r.done;

                        if (!done) {
                          _context18.next = 9;
                          break;
                        }

                        return _context18.abrupt("return", {
                          value: value,
                          done: done
                        });

                      case 9:
                        this._loaded += value.byteLength;

                        if (this.onProgress) {
                          this.onProgress({
                            loaded: this._loaded,
                            total: this._contentLength
                          });
                        }

                        buffer = new Uint8Array(value).buffer;
                        return _context18.abrupt("return", {
                          value: buffer,
                          done: false
                        });

                      case 13:
                      case "end":
                        return _context18.stop();
                    }
                  }
                }, _callee18, this);
              }));

              function read() {
                return _read7.apply(this, arguments);
              }

              return read;
            }()
          }, {
            key: "cancel",
            value: function cancel(reason) {
              if (this._reader) {
                this._reader.cancel(reason);
              }

              if (this._abortController) {
                this._abortController.abort();
              }
            }
          }]);

          return PDFFetchStreamReader;
        }();

        var PDFFetchStreamRangeReader = /*#__PURE__*/function () {
          function PDFFetchStreamRangeReader(stream, begin, end) {
            var _this57 = this;

            _classCallCheck(this, PDFFetchStreamRangeReader);

            this._stream = stream;
            this._reader = null;
            this._loaded = 0;
            var source = stream.source;
            this._withCredentials = source.withCredentials || false;
            this._readCapability = (0, _util.createPromiseCapability)();
            this._isStreamingSupported = !source.disableStream;

            if (typeof AbortController !== "undefined") {
              this._abortController = new AbortController();
            }

            this._headers = createHeaders(this._stream.httpHeaders);

            this._headers.append("Range", "bytes=".concat(begin, "-").concat(end - 1));

            var url = source.url;
            fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {
              if (!(0, _network_utils.validateResponseStatus)(response.status)) {
                throw (0, _network_utils.createResponseStatusError)(response.status, url);
              }

              _this57._readCapability.resolve();

              _this57._reader = response.body.getReader();
            })["catch"](this._readCapability.reject);
            this.onProgress = null;
          }

          _createClass(PDFFetchStreamRangeReader, [{
            key: "isStreamingSupported",
            get: function get() {
              return this._isStreamingSupported;
            }
          }, {
            key: "read",
            value: function () {
              var _read8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
                var _yield$this$_reader$r2, value, done, buffer;

                return _regeneratorRuntime().wrap(function _callee19$(_context19) {
                  while (1) {
                    switch (_context19.prev = _context19.next) {
                      case 0:
                        _context19.next = 2;
                        return this._readCapability.promise;

                      case 2:
                        _context19.next = 4;
                        return this._reader.read();

                      case 4:
                        _yield$this$_reader$r2 = _context19.sent;
                        value = _yield$this$_reader$r2.value;
                        done = _yield$this$_reader$r2.done;

                        if (!done) {
                          _context19.next = 9;
                          break;
                        }

                        return _context19.abrupt("return", {
                          value: value,
                          done: done
                        });

                      case 9:
                        this._loaded += value.byteLength;

                        if (this.onProgress) {
                          this.onProgress({
                            loaded: this._loaded
                          });
                        }

                        buffer = new Uint8Array(value).buffer;
                        return _context19.abrupt("return", {
                          value: buffer,
                          done: false
                        });

                      case 13:
                      case "end":
                        return _context19.stop();
                    }
                  }
                }, _callee19, this);
              }));

              function read() {
                return _read8.apply(this, arguments);
              }

              return read;
            }()
          }, {
            key: "cancel",
            value: function cancel(reason) {
              if (this._reader) {
                this._reader.cancel(reason);
              }

              if (this._abortController) {
                this._abortController.abort();
              }
            }
          }]);

          return PDFFetchStreamRangeReader;
        }();
        /***/

      }
      /******/
      ];
      /************************************************************************/

      /******/
      // The module cache

      /******/

      var __webpack_module_cache__ = {};
      /******/

      /******/
      // The require function

      /******/

      function __w_pdfjs_require__(moduleId) {
        /******/
        // Check if module is in cache

        /******/
        var cachedModule = __webpack_module_cache__[moduleId];
        /******/

        if (cachedModule !== undefined) {
          /******/
          return cachedModule.exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed

          /******/
          // no module.loaded needed

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
        /******/

        /******/
        // Return the exports of the module

        /******/


        return module.exports;
        /******/
      }
      /******/

      /************************************************************************/


      var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.

      (function () {
        var exports = __webpack_exports__;
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        Object.defineProperty(exports, "addLinkAttributes", {
          enumerable: true,
          get: function get() {
            return _display_utils.addLinkAttributes;
          }
        });
        Object.defineProperty(exports, "getFilenameFromUrl", {
          enumerable: true,
          get: function get() {
            return _display_utils.getFilenameFromUrl;
          }
        });
        Object.defineProperty(exports, "getPdfFilenameFromUrl", {
          enumerable: true,
          get: function get() {
            return _display_utils.getPdfFilenameFromUrl;
          }
        });
        Object.defineProperty(exports, "getXfaPageViewport", {
          enumerable: true,
          get: function get() {
            return _display_utils.getXfaPageViewport;
          }
        });
        Object.defineProperty(exports, "isPdfFile", {
          enumerable: true,
          get: function get() {
            return _display_utils.isPdfFile;
          }
        });
        Object.defineProperty(exports, "LinkTarget", {
          enumerable: true,
          get: function get() {
            return _display_utils.LinkTarget;
          }
        });
        Object.defineProperty(exports, "loadScript", {
          enumerable: true,
          get: function get() {
            return _display_utils.loadScript;
          }
        });
        Object.defineProperty(exports, "PDFDateString", {
          enumerable: true,
          get: function get() {
            return _display_utils.PDFDateString;
          }
        });
        Object.defineProperty(exports, "PixelsPerInch", {
          enumerable: true,
          get: function get() {
            return _display_utils.PixelsPerInch;
          }
        });
        Object.defineProperty(exports, "RenderingCancelledException", {
          enumerable: true,
          get: function get() {
            return _display_utils.RenderingCancelledException;
          }
        });
        Object.defineProperty(exports, "AnnotationMode", {
          enumerable: true,
          get: function get() {
            return _util.AnnotationMode;
          }
        });
        Object.defineProperty(exports, "CMapCompressionType", {
          enumerable: true,
          get: function get() {
            return _util.CMapCompressionType;
          }
        });
        Object.defineProperty(exports, "createObjectURL", {
          enumerable: true,
          get: function get() {
            return _util.createObjectURL;
          }
        });
        Object.defineProperty(exports, "createPromiseCapability", {
          enumerable: true,
          get: function get() {
            return _util.createPromiseCapability;
          }
        });
        Object.defineProperty(exports, "createValidAbsoluteUrl", {
          enumerable: true,
          get: function get() {
            return _util.createValidAbsoluteUrl;
          }
        });
        Object.defineProperty(exports, "InvalidPDFException", {
          enumerable: true,
          get: function get() {
            return _util.InvalidPDFException;
          }
        });
        Object.defineProperty(exports, "MissingPDFException", {
          enumerable: true,
          get: function get() {
            return _util.MissingPDFException;
          }
        });
        Object.defineProperty(exports, "OPS", {
          enumerable: true,
          get: function get() {
            return _util.OPS;
          }
        });
        Object.defineProperty(exports, "PasswordResponses", {
          enumerable: true,
          get: function get() {
            return _util.PasswordResponses;
          }
        });
        Object.defineProperty(exports, "PermissionFlag", {
          enumerable: true,
          get: function get() {
            return _util.PermissionFlag;
          }
        });
        Object.defineProperty(exports, "removeNullCharacters", {
          enumerable: true,
          get: function get() {
            return _util.removeNullCharacters;
          }
        });
        Object.defineProperty(exports, "shadow", {
          enumerable: true,
          get: function get() {
            return _util.shadow;
          }
        });
        Object.defineProperty(exports, "UnexpectedResponseException", {
          enumerable: true,
          get: function get() {
            return _util.UnexpectedResponseException;
          }
        });
        Object.defineProperty(exports, "UNSUPPORTED_FEATURES", {
          enumerable: true,
          get: function get() {
            return _util.UNSUPPORTED_FEATURES;
          }
        });
        Object.defineProperty(exports, "Util", {
          enumerable: true,
          get: function get() {
            return _util.Util;
          }
        });
        Object.defineProperty(exports, "VerbosityLevel", {
          enumerable: true,
          get: function get() {
            return _util.VerbosityLevel;
          }
        });
        Object.defineProperty(exports, "build", {
          enumerable: true,
          get: function get() {
            return _api.build;
          }
        });
        Object.defineProperty(exports, "getDocument", {
          enumerable: true,
          get: function get() {
            return _api.getDocument;
          }
        });
        Object.defineProperty(exports, "LoopbackPort", {
          enumerable: true,
          get: function get() {
            return _api.LoopbackPort;
          }
        });
        Object.defineProperty(exports, "PDFDataRangeTransport", {
          enumerable: true,
          get: function get() {
            return _api.PDFDataRangeTransport;
          }
        });
        Object.defineProperty(exports, "PDFWorker", {
          enumerable: true,
          get: function get() {
            return _api.PDFWorker;
          }
        });
        Object.defineProperty(exports, "version", {
          enumerable: true,
          get: function get() {
            return _api.version;
          }
        });
        Object.defineProperty(exports, "AnnotationLayer", {
          enumerable: true,
          get: function get() {
            return _annotation_layer.AnnotationLayer;
          }
        });
        Object.defineProperty(exports, "GlobalWorkerOptions", {
          enumerable: true,
          get: function get() {
            return _worker_options.GlobalWorkerOptions;
          }
        });
        Object.defineProperty(exports, "renderTextLayer", {
          enumerable: true,
          get: function get() {
            return _text_layer.renderTextLayer;
          }
        });
        Object.defineProperty(exports, "SVGGraphics", {
          enumerable: true,
          get: function get() {
            return _svg.SVGGraphics;
          }
        });
        Object.defineProperty(exports, "XfaLayer", {
          enumerable: true,
          get: function get() {
            return _xfa_layer.XfaLayer;
          }
        });

        var _display_utils = __w_pdfjs_require__(1);

        var _util = __w_pdfjs_require__(2);

        var _api = __w_pdfjs_require__(6);

        var _annotation_layer = __w_pdfjs_require__(18);

        var _worker_options = __w_pdfjs_require__(12);

        var _is_node = __w_pdfjs_require__(4);

        var _text_layer = __w_pdfjs_require__(20);

        var _svg = __w_pdfjs_require__(21);

        var _xfa_layer = __w_pdfjs_require__(22);

        var pdfjsVersion = '2.11.338';
        var pdfjsBuild = 'dedff3c98';
        {
          if (_is_node.isNodeJS) {
            var _w_pdfjs_require__ = __w_pdfjs_require__(23),
                PDFNodeStream = _w_pdfjs_require__.PDFNodeStream;

            (0, _api.setPDFNetworkStreamFactory)(function (params) {
              return new PDFNodeStream(params);
            });
          } else {
            var _w_pdfjs_require__2 = __w_pdfjs_require__(26),
                PDFNetworkStream = _w_pdfjs_require__2.PDFNetworkStream;

            var _w_pdfjs_require__3 = __w_pdfjs_require__(27),
                PDFFetchStream = _w_pdfjs_require__3.PDFFetchStream;

            (0, _api.setPDFNetworkStreamFactory)(function (params) {
              if ((0, _display_utils.isValidFetchUrl)(params.url)) {
                return new PDFFetchStream(params);
              }

              return new PDFNetworkStream(params);
            });
          }
        }
      })();
      /******/


      return __webpack_exports__;
      /******/
    }()
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(10), __webpack_require__(11).Buffer, __webpack_require__(16)(module)))

/***/ }),
/* 10 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(13)
var ieee754 = __webpack_require__(14)
var isArray = __webpack_require__(15)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))

/***/ }),
/* 12 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 14 */
/***/ (function(module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 15 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 16 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 17 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 18 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 19 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 20 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 21 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 22 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _get2() { if (typeof Reflect !== "undefined" && Reflect.get) { _get2 = Reflect.get.bind(); } else { _get2 = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get2.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * @licstart The following is the entire license notice for the
 * Javascript code in this page
 *
 * Copyright 2021 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * Javascript code in this page
 */
(function webpackUniversalModuleDefinition(root, factory) {
  if (( false ? undefined : _typeof(exports)) === 'object' && ( false ? undefined : _typeof(module)) === 'object') module.exports = factory();else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else {}
})(this, function () {
  return (
    /******/
    function () {
      // webpackBootstrap

      /******/
      "use strict";
      /******/

      var __webpack_modules__ = [
        /* 0 */
      ,
      /* 1 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.DefaultAnnotationLayerFactory = exports.AnnotationLayerBuilder = void 0;

        var _pdfjsLib = __w_pdfjs_require__(2);

        var _l10n_utils = __w_pdfjs_require__(3);

        var _pdf_link_service = __w_pdfjs_require__(4);

        var AnnotationLayerBuilder = /*#__PURE__*/function () {
          function AnnotationLayerBuilder(_ref) {
            var pageDiv = _ref.pageDiv,
                pdfPage = _ref.pdfPage,
                linkService = _ref.linkService,
                downloadManager = _ref.downloadManager,
                _ref$annotationStorag = _ref.annotationStorage,
                annotationStorage = _ref$annotationStorag === void 0 ? null : _ref$annotationStorag,
                _ref$imageResourcesPa = _ref.imageResourcesPath,
                imageResourcesPath = _ref$imageResourcesPa === void 0 ? "" : _ref$imageResourcesPa,
                _ref$renderForms = _ref.renderForms,
                renderForms = _ref$renderForms === void 0 ? true : _ref$renderForms,
                _ref$l10n = _ref.l10n,
                l10n = _ref$l10n === void 0 ? _l10n_utils.NullL10n : _ref$l10n,
                _ref$enableScripting = _ref.enableScripting,
                enableScripting = _ref$enableScripting === void 0 ? false : _ref$enableScripting,
                _ref$hasJSActionsProm = _ref.hasJSActionsPromise,
                hasJSActionsPromise = _ref$hasJSActionsProm === void 0 ? null : _ref$hasJSActionsProm,
                _ref$fieldObjectsProm = _ref.fieldObjectsPromise,
                fieldObjectsPromise = _ref$fieldObjectsProm === void 0 ? null : _ref$fieldObjectsProm,
                _ref$mouseState = _ref.mouseState,
                mouseState = _ref$mouseState === void 0 ? null : _ref$mouseState;

            _classCallCheck(this, AnnotationLayerBuilder);

            this.pageDiv = pageDiv;
            this.pdfPage = pdfPage;
            this.linkService = linkService;
            this.downloadManager = downloadManager;
            this.imageResourcesPath = imageResourcesPath;
            this.renderForms = renderForms;
            this.l10n = l10n;
            this.annotationStorage = annotationStorage;
            this.enableScripting = enableScripting;
            this._hasJSActionsPromise = hasJSActionsPromise;
            this._fieldObjectsPromise = fieldObjectsPromise;
            this._mouseState = mouseState;
            this.div = null;
            this._cancelled = false;
          }

          _createClass(AnnotationLayerBuilder, [{
            key: "render",
            value: function () {
              var _render = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(viewport) {
                var intent,
                    _yield$Promise$all,
                    _yield$Promise$all2,
                    annotations,
                    _yield$Promise$all2$,
                    hasJSActions,
                    _yield$Promise$all2$2,
                    fieldObjects,
                    parameters,
                    _args = arguments;

                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        intent = _args.length > 1 && _args[1] !== undefined ? _args[1] : "display";
                        _context.next = 3;
                        return Promise.all([this.pdfPage.getAnnotations({
                          intent: intent
                        }), this._hasJSActionsPromise, this._fieldObjectsPromise]);

                      case 3:
                        _yield$Promise$all = _context.sent;
                        _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 3);
                        annotations = _yield$Promise$all2[0];
                        _yield$Promise$all2$ = _yield$Promise$all2[1];
                        hasJSActions = _yield$Promise$all2$ === void 0 ? false : _yield$Promise$all2$;
                        _yield$Promise$all2$2 = _yield$Promise$all2[2];
                        fieldObjects = _yield$Promise$all2$2 === void 0 ? null : _yield$Promise$all2$2;

                        if (!(this._cancelled || annotations.length === 0)) {
                          _context.next = 12;
                          break;
                        }

                        return _context.abrupt("return");

                      case 12:
                        parameters = {
                          viewport: viewport.clone({
                            dontFlip: true
                          }),
                          div: this.div,
                          annotations: annotations,
                          page: this.pdfPage,
                          imageResourcesPath: this.imageResourcesPath,
                          renderForms: this.renderForms,
                          linkService: this.linkService,
                          downloadManager: this.downloadManager,
                          annotationStorage: this.annotationStorage,
                          enableScripting: this.enableScripting,
                          hasJSActions: hasJSActions,
                          fieldObjects: fieldObjects,
                          mouseState: this._mouseState
                        };

                        if (this.div) {
                          _pdfjsLib.AnnotationLayer.update(parameters);
                        } else {
                          this.div = document.createElement("div");
                          this.div.className = "annotationLayer";
                          this.pageDiv.appendChild(this.div);
                          parameters.div = this.div;

                          _pdfjsLib.AnnotationLayer.render(parameters);

                          this.l10n.translate(this.div);
                        }

                      case 14:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, this);
              }));

              function render(_x) {
                return _render.apply(this, arguments);
              }

              return render;
            }()
          }, {
            key: "cancel",
            value: function cancel() {
              this._cancelled = true;
            }
          }, {
            key: "hide",
            value: function hide() {
              if (!this.div) {
                return;
              }

              this.div.hidden = true;
            }
          }]);

          return AnnotationLayerBuilder;
        }();

        exports.AnnotationLayerBuilder = AnnotationLayerBuilder;

        var DefaultAnnotationLayerFactory = /*#__PURE__*/function () {
          function DefaultAnnotationLayerFactory() {
            _classCallCheck(this, DefaultAnnotationLayerFactory);
          }

          _createClass(DefaultAnnotationLayerFactory, [{
            key: "createAnnotationLayerBuilder",
            value: function createAnnotationLayerBuilder(pageDiv, pdfPage) {
              var annotationStorage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              var imageResourcesPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
              var renderForms = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
              var l10n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _l10n_utils.NullL10n;
              var enableScripting = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
              var hasJSActionsPromise = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
              var mouseState = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
              var fieldObjectsPromise = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
              return new AnnotationLayerBuilder({
                pageDiv: pageDiv,
                pdfPage: pdfPage,
                imageResourcesPath: imageResourcesPath,
                renderForms: renderForms,
                linkService: new _pdf_link_service.SimpleLinkService(),
                l10n: l10n,
                annotationStorage: annotationStorage,
                enableScripting: enableScripting,
                hasJSActionsPromise: hasJSActionsPromise,
                fieldObjectsPromise: fieldObjectsPromise,
                mouseState: mouseState
              });
            }
          }]);

          return DefaultAnnotationLayerFactory;
        }();

        exports.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;
        /***/
      },
      /* 2 */

      /***/
      function (module) {
        var pdfjsLib;

        if (typeof window !== "undefined" && window["pdfjs-dist/build/pdf"]) {
          pdfjsLib = window["pdfjs-dist/build/pdf"];
        } else {
          pdfjsLib = __webpack_require__(9);
        }

        module.exports = pdfjsLib;
        /***/
      },
      /* 3 */

      /***/
      function (__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.fixupLangCode = fixupLangCode;
        exports.getL10nFallback = getL10nFallback;
        exports.NullL10n = void 0;
        var DEFAULT_L10N_STRINGS = {
          of_pages: "of {{pagesCount}}",
          page_of_pages: "({{pageNumber}} of {{pagesCount}})",
          document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
          document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
          document_properties_date_string: "{{date}}, {{time}}",
          document_properties_page_size_unit_inches: "in",
          document_properties_page_size_unit_millimeters: "mm",
          document_properties_page_size_orientation_portrait: "portrait",
          document_properties_page_size_orientation_landscape: "landscape",
          document_properties_page_size_name_a3: "A3",
          document_properties_page_size_name_a4: "A4",
          document_properties_page_size_name_letter: "Letter",
          document_properties_page_size_name_legal: "Legal",
          document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
          document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
          document_properties_linearized_yes: "Yes",
          document_properties_linearized_no: "No",
          print_progress_percent: "{{progress}}%",
          "toggle_sidebar.title": "Toggle Sidebar",
          "toggle_sidebar_notification2.title": "Toggle Sidebar (document contains outline/attachments/layers)",
          additional_layers: "Additional Layers",
          page_landmark: "Page {{page}}",
          thumb_page_title: "Page {{page}}",
          thumb_page_canvas: "Thumbnail of Page {{page}}",
          find_reached_top: "Reached top of document, continued from bottom",
          find_reached_bottom: "Reached end of document, continued from top",
          "find_match_count[one]": "{{current}} of {{total}} match",
          "find_match_count[other]": "{{current}} of {{total}} matches",
          "find_match_count_limit[one]": "More than {{limit}} match",
          "find_match_count_limit[other]": "More than {{limit}} matches",
          find_not_found: "Phrase not found",
          error_version_info: "PDF.js v{{version}} (build: {{build}})",
          error_message: "Message: {{message}}",
          error_stack: "Stack: {{stack}}",
          error_file: "File: {{file}}",
          error_line: "Line: {{line}}",
          rendering_error: "An error occurred while rendering the page.",
          page_scale_width: "Page Width",
          page_scale_fit: "Page Fit",
          page_scale_auto: "Automatic Zoom",
          page_scale_actual: "Actual Size",
          page_scale_percent: "{{scale}}%",
          loading: "Loading…",
          loading_error: "An error occurred while loading the PDF.",
          invalid_file_error: "Invalid or corrupted PDF file.",
          missing_file_error: "Missing PDF file.",
          unexpected_response_error: "Unexpected server response.",
          printing_not_supported: "Warning: Printing is not fully supported by this browser.",
          printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
          web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts."
        };

        function getL10nFallback(key, args) {
          switch (key) {
            case "find_match_count":
              key = "find_match_count[".concat(args.total === 1 ? "one" : "other", "]");
              break;

            case "find_match_count_limit":
              key = "find_match_count_limit[".concat(args.limit === 1 ? "one" : "other", "]");
              break;
          }

          return DEFAULT_L10N_STRINGS[key] || "";
        }

        var PARTIAL_LANG_CODES = {
          en: "en-US",
          es: "es-ES",
          fy: "fy-NL",
          ga: "ga-IE",
          gu: "gu-IN",
          hi: "hi-IN",
          hy: "hy-AM",
          nb: "nb-NO",
          ne: "ne-NP",
          nn: "nn-NO",
          pa: "pa-IN",
          pt: "pt-PT",
          sv: "sv-SE",
          zh: "zh-CN"
        };

        function fixupLangCode(langCode) {
          return PARTIAL_LANG_CODES[langCode === null || langCode === void 0 ? void 0 : langCode.toLowerCase()] || langCode;
        }

        function formatL10nValue(text, args) {
          if (!args) {
            return text;
          }

          return text.replace(/\{\{\s*(\w+)\s*\}\}/g, function (all, name) {
            return name in args ? args[name] : "{{" + name + "}}";
          });
        }

        var NullL10n = {
          getLanguage: function getLanguage() {
            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
              return _regeneratorRuntime().wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      return _context2.abrupt("return", "en-us");

                    case 1:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }))();
          },
          getDirection: function getDirection() {
            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
              return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      return _context3.abrupt("return", "ltr");

                    case 1:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3);
            }))();
          },
          get: function get(key) {
            var _arguments = arguments;
            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
              var args, fallback;
              return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      args = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : null;
                      fallback = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : getL10nFallback(key, args);
                      return _context4.abrupt("return", formatL10nValue(fallback, args));

                    case 3:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }))();
          },
          translate: function translate(element) {
            return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
              return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5);
            }))();
          }
        };
        exports.NullL10n = NullL10n;
        /***/
      },
      /* 4 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.SimpleLinkService = exports.PDFLinkService = void 0;

        var _pdfjsLib = __w_pdfjs_require__(2);

        var _ui_utils = __w_pdfjs_require__(5);

        var PDFLinkService = /*#__PURE__*/function () {
          function PDFLinkService() {
            var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                eventBus = _ref2.eventBus,
                _ref2$externalLinkTar = _ref2.externalLinkTarget,
                externalLinkTarget = _ref2$externalLinkTar === void 0 ? null : _ref2$externalLinkTar,
                _ref2$externalLinkRel = _ref2.externalLinkRel,
                externalLinkRel = _ref2$externalLinkRel === void 0 ? null : _ref2$externalLinkRel,
                _ref2$ignoreDestinati = _ref2.ignoreDestinationZoom,
                ignoreDestinationZoom = _ref2$ignoreDestinati === void 0 ? false : _ref2$ignoreDestinati;

            _classCallCheck(this, PDFLinkService);

            this.eventBus = eventBus;
            this.externalLinkTarget = externalLinkTarget;
            this.externalLinkRel = externalLinkRel;
            this.externalLinkEnabled = true;
            this._ignoreDestinationZoom = ignoreDestinationZoom;
            this.baseUrl = null;
            this.pdfDocument = null;
            this.pdfViewer = null;
            this.pdfHistory = null;
            this._pagesRefCache = null;
          }

          _createClass(PDFLinkService, [{
            key: "setDocument",
            value: function setDocument(pdfDocument) {
              var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              this.baseUrl = baseUrl;
              this.pdfDocument = pdfDocument;
              this._pagesRefCache = Object.create(null);
            }
          }, {
            key: "setViewer",
            value: function setViewer(pdfViewer) {
              this.pdfViewer = pdfViewer;
            }
          }, {
            key: "setHistory",
            value: function setHistory(pdfHistory) {
              this.pdfHistory = pdfHistory;
            }
          }, {
            key: "pagesCount",
            get: function get() {
              return this.pdfDocument ? this.pdfDocument.numPages : 0;
            }
          }, {
            key: "page",
            get: function get() {
              return this.pdfViewer.currentPageNumber;
            },
            set: function set(value) {
              this.pdfViewer.currentPageNumber = value;
            }
          }, {
            key: "rotation",
            get: function get() {
              return this.pdfViewer.pagesRotation;
            },
            set: function set(value) {
              this.pdfViewer.pagesRotation = value;
            }
          }, {
            key: "_goToDestinationHelper",
            value: function _goToDestinationHelper(rawDest) {
              var _this = this;

              var namedDest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
              var explicitDest = arguments.length > 2 ? arguments[2] : undefined;
              var destRef = explicitDest[0];
              var pageNumber;

              if (_typeof(destRef) === "object" && destRef !== null) {
                pageNumber = this._cachedPageNumber(destRef);

                if (pageNumber === null) {
                  this.pdfDocument.getPageIndex(destRef).then(function (pageIndex) {
                    _this.cachePageRef(pageIndex + 1, destRef);

                    _this._goToDestinationHelper(rawDest, namedDest, explicitDest);
                  })["catch"](function () {
                    console.error("PDFLinkService._goToDestinationHelper: \"".concat(destRef, "\" is not ") + "a valid page reference, for dest=\"".concat(rawDest, "\"."));
                  });
                  return;
                }
              } else if (Number.isInteger(destRef)) {
                pageNumber = destRef + 1;
              } else {
                console.error("PDFLinkService._goToDestinationHelper: \"".concat(destRef, "\" is not ") + "a valid destination reference, for dest=\"".concat(rawDest, "\"."));
                return;
              }

              if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) {
                console.error("PDFLinkService._goToDestinationHelper: \"".concat(pageNumber, "\" is not ") + "a valid page number, for dest=\"".concat(rawDest, "\"."));
                return;
              }

              if (this.pdfHistory) {
                this.pdfHistory.pushCurrentPosition();
                this.pdfHistory.push({
                  namedDest: namedDest,
                  explicitDest: explicitDest,
                  pageNumber: pageNumber
                });
              }

              this.pdfViewer.scrollPageIntoView({
                pageNumber: pageNumber,
                destArray: explicitDest,
                ignoreDestinationZoom: this._ignoreDestinationZoom
              });
            }
          }, {
            key: "goToDestination",
            value: function () {
              var _goToDestination = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(dest) {
                var namedDest, explicitDest;
                return _regeneratorRuntime().wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        if (this.pdfDocument) {
                          _context6.next = 2;
                          break;
                        }

                        return _context6.abrupt("return");

                      case 2:
                        if (!(typeof dest === "string")) {
                          _context6.next = 9;
                          break;
                        }

                        namedDest = dest;
                        _context6.next = 6;
                        return this.pdfDocument.getDestination(dest);

                      case 6:
                        explicitDest = _context6.sent;
                        _context6.next = 13;
                        break;

                      case 9:
                        namedDest = null;
                        _context6.next = 12;
                        return dest;

                      case 12:
                        explicitDest = _context6.sent;

                      case 13:
                        if (Array.isArray(explicitDest)) {
                          _context6.next = 16;
                          break;
                        }

                        console.error("PDFLinkService.goToDestination: \"".concat(explicitDest, "\" is not ") + "a valid destination array, for dest=\"".concat(dest, "\"."));
                        return _context6.abrupt("return");

                      case 16:
                        this._goToDestinationHelper(dest, namedDest, explicitDest);

                      case 17:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6, this);
              }));

              function goToDestination(_x2) {
                return _goToDestination.apply(this, arguments);
              }

              return goToDestination;
            }()
          }, {
            key: "goToPage",
            value: function goToPage(val) {
              if (!this.pdfDocument) {
                return;
              }

              var pageNumber = typeof val === "string" && this.pdfViewer.pageLabelToPageNumber(val) || val | 0;

              if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
                console.error("PDFLinkService.goToPage: \"".concat(val, "\" is not a valid page."));
                return;
              }

              if (this.pdfHistory) {
                this.pdfHistory.pushCurrentPosition();
                this.pdfHistory.pushPage(pageNumber);
              }

              this.pdfViewer.scrollPageIntoView({
                pageNumber: pageNumber
              });
            }
          }, {
            key: "addLinkAttributes",
            value: function addLinkAttributes(link, url) {
              var newWindow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
              (0, _pdfjsLib.addLinkAttributes)(link, {
                url: url,
                target: newWindow ? _pdfjsLib.LinkTarget.BLANK : this.externalLinkTarget,
                rel: this.externalLinkRel,
                enabled: this.externalLinkEnabled
              });
            }
          }, {
            key: "getDestinationHash",
            value: function getDestinationHash(dest) {
              if (typeof dest === "string") {
                if (dest.length > 0) {
                  return this.getAnchorUrl("#" + escape(dest));
                }
              } else if (Array.isArray(dest)) {
                var str = JSON.stringify(dest);

                if (str.length > 0) {
                  return this.getAnchorUrl("#" + escape(str));
                }
              }

              return this.getAnchorUrl("");
            }
          }, {
            key: "getAnchorUrl",
            value: function getAnchorUrl(anchor) {
              return (this.baseUrl || "") + anchor;
            }
          }, {
            key: "setHash",
            value: function setHash(hash) {
              if (!this.pdfDocument) {
                return;
              }

              var pageNumber, dest;

              if (hash.includes("=")) {
                var params = (0, _ui_utils.parseQueryString)(hash);

                if (params.has("search")) {
                  this.eventBus.dispatch("findfromurlhash", {
                    source: this,
                    query: params.get("search").replace(/"/g, ""),
                    phraseSearch: params.get("phrase") === "true"
                  });
                }

                if (params.has("page")) {
                  pageNumber = params.get("page") | 0 || 1;
                }

                if (params.has("zoom")) {
                  var zoomArgs = params.get("zoom").split(",");
                  var zoomArg = zoomArgs[0];
                  var zoomArgNumber = parseFloat(zoomArg);

                  if (!zoomArg.includes("Fit")) {
                    dest = [null, {
                      name: "XYZ"
                    }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];
                  } else {
                    if (zoomArg === "Fit" || zoomArg === "FitB") {
                      dest = [null, {
                        name: zoomArg
                      }];
                    } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") {
                      dest = [null, {
                        name: zoomArg
                      }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];
                    } else if (zoomArg === "FitR") {
                      if (zoomArgs.length !== 5) {
                        console.error('PDFLinkService.setHash: Not enough parameters for "FitR".');
                      } else {
                        dest = [null, {
                          name: zoomArg
                        }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];
                      }
                    } else {
                      console.error("PDFLinkService.setHash: \"".concat(zoomArg, "\" is not ") + "a valid zoom value.");
                    }
                  }
                }

                if (dest) {
                  this.pdfViewer.scrollPageIntoView({
                    pageNumber: pageNumber || this.page,
                    destArray: dest,
                    allowNegativeOffset: true
                  });
                } else if (pageNumber) {
                  this.page = pageNumber;
                }

                if (params.has("pagemode")) {
                  this.eventBus.dispatch("pagemode", {
                    source: this,
                    mode: params.get("pagemode")
                  });
                }

                if (params.has("nameddest")) {
                  this.goToDestination(params.get("nameddest"));
                }
              } else {
                dest = unescape(hash);

                try {
                  dest = JSON.parse(dest);

                  if (!Array.isArray(dest)) {
                    dest = dest.toString();
                  }
                } catch (ex) {}

                if (typeof dest === "string" || isValidExplicitDestination(dest)) {
                  this.goToDestination(dest);
                  return;
                }

                console.error("PDFLinkService.setHash: \"".concat(unescape(hash), "\" is not ") + "a valid destination.");
              }
            }
          }, {
            key: "executeNamedAction",
            value: function executeNamedAction(action) {
              var _this$pdfHistory, _this$pdfHistory2;

              switch (action) {
                case "GoBack":
                  (_this$pdfHistory = this.pdfHistory) === null || _this$pdfHistory === void 0 ? void 0 : _this$pdfHistory.back();
                  break;

                case "GoForward":
                  (_this$pdfHistory2 = this.pdfHistory) === null || _this$pdfHistory2 === void 0 ? void 0 : _this$pdfHistory2.forward();
                  break;

                case "NextPage":
                  this.pdfViewer.nextPage();
                  break;

                case "PrevPage":
                  this.pdfViewer.previousPage();
                  break;

                case "LastPage":
                  this.page = this.pagesCount;
                  break;

                case "FirstPage":
                  this.page = 1;
                  break;

                default:
                  break;
              }

              this.eventBus.dispatch("namedaction", {
                source: this,
                action: action
              });
            }
          }, {
            key: "cachePageRef",
            value: function cachePageRef(pageNum, pageRef) {
              if (!pageRef) {
                return;
              }

              var refStr = pageRef.gen === 0 ? "".concat(pageRef.num, "R") : "".concat(pageRef.num, "R").concat(pageRef.gen);
              this._pagesRefCache[refStr] = pageNum;
            }
          }, {
            key: "_cachedPageNumber",
            value: function _cachedPageNumber(pageRef) {
              var _this$_pagesRefCache;

              var refStr = pageRef.gen === 0 ? "".concat(pageRef.num, "R") : "".concat(pageRef.num, "R").concat(pageRef.gen);
              return ((_this$_pagesRefCache = this._pagesRefCache) === null || _this$_pagesRefCache === void 0 ? void 0 : _this$_pagesRefCache[refStr]) || null;
            }
          }, {
            key: "isPageVisible",
            value: function isPageVisible(pageNumber) {
              return this.pdfViewer.isPageVisible(pageNumber);
            }
          }, {
            key: "isPageCached",
            value: function isPageCached(pageNumber) {
              return this.pdfViewer.isPageCached(pageNumber);
            }
          }]);

          return PDFLinkService;
        }();

        exports.PDFLinkService = PDFLinkService;

        function isValidExplicitDestination(dest) {
          if (!Array.isArray(dest)) {
            return false;
          }

          var destLength = dest.length;

          if (destLength < 2) {
            return false;
          }

          var page = dest[0];

          if (!(_typeof(page) === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {
            return false;
          }

          var zoom = dest[1];

          if (!(_typeof(zoom) === "object" && typeof zoom.name === "string")) {
            return false;
          }

          var allowNull = true;

          switch (zoom.name) {
            case "XYZ":
              if (destLength !== 5) {
                return false;
              }

              break;

            case "Fit":
            case "FitB":
              return destLength === 2;

            case "FitH":
            case "FitBH":
            case "FitV":
            case "FitBV":
              if (destLength !== 3) {
                return false;
              }

              break;

            case "FitR":
              if (destLength !== 6) {
                return false;
              }

              allowNull = false;
              break;

            default:
              return false;
          }

          for (var i = 2; i < destLength; i++) {
            var param = dest[i];

            if (!(typeof param === "number" || allowNull && param === null)) {
              return false;
            }
          }

          return true;
        }

        var SimpleLinkService = /*#__PURE__*/function () {
          function SimpleLinkService() {
            _classCallCheck(this, SimpleLinkService);

            this.externalLinkEnabled = true;
          }

          _createClass(SimpleLinkService, [{
            key: "pagesCount",
            get: function get() {
              return 0;
            }
          }, {
            key: "page",
            get: function get() {
              return 0;
            },
            set: function set(value) {}
          }, {
            key: "rotation",
            get: function get() {
              return 0;
            },
            set: function set(value) {}
          }, {
            key: "goToDestination",
            value: function () {
              var _goToDestination2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(dest) {
                return _regeneratorRuntime().wrap(function _callee7$(_context7) {
                  while (1) {
                    switch (_context7.prev = _context7.next) {
                      case 0:
                      case "end":
                        return _context7.stop();
                    }
                  }
                }, _callee7);
              }));

              function goToDestination(_x3) {
                return _goToDestination2.apply(this, arguments);
              }

              return goToDestination;
            }()
          }, {
            key: "goToPage",
            value: function goToPage(val) {}
          }, {
            key: "addLinkAttributes",
            value: function addLinkAttributes(link, url) {
              var newWindow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
              (0, _pdfjsLib.addLinkAttributes)(link, {
                url: url,
                enabled: this.externalLinkEnabled
              });
            }
          }, {
            key: "getDestinationHash",
            value: function getDestinationHash(dest) {
              return "#";
            }
          }, {
            key: "getAnchorUrl",
            value: function getAnchorUrl(hash) {
              return "#";
            }
          }, {
            key: "setHash",
            value: function setHash(hash) {}
          }, {
            key: "executeNamedAction",
            value: function executeNamedAction(action) {}
          }, {
            key: "cachePageRef",
            value: function cachePageRef(pageNum, pageRef) {}
          }, {
            key: "isPageVisible",
            value: function isPageVisible(pageNumber) {
              return true;
            }
          }, {
            key: "isPageCached",
            value: function isPageCached(pageNumber) {
              return true;
            }
          }]);

          return SimpleLinkService;
        }();

        exports.SimpleLinkService = SimpleLinkService;
        /***/
      },
      /* 5 */

      /***/
      function (__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.apiPageLayoutToSpreadMode = apiPageLayoutToSpreadMode;
        exports.apiPageModeToSidebarView = apiPageModeToSidebarView;
        exports.approximateFraction = approximateFraction;
        exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;
        exports.binarySearchFirstItem = binarySearchFirstItem;
        exports.getActiveOrFocusedElement = getActiveOrFocusedElement;
        exports.getOutputScale = getOutputScale;
        exports.getPageSizeInches = getPageSizeInches;
        exports.getVisibleElements = getVisibleElements;
        exports.isPortraitOrientation = isPortraitOrientation;
        exports.isValidRotation = isValidRotation;
        exports.isValidScrollMode = isValidScrollMode;
        exports.isValidSpreadMode = isValidSpreadMode;
        exports.moveToEndOfArray = moveToEndOfArray;
        exports.noContextMenuHandler = noContextMenuHandler;
        exports.normalizeWheelEventDelta = normalizeWheelEventDelta;
        exports.normalizeWheelEventDirection = normalizeWheelEventDirection;
        exports.parseQueryString = parseQueryString;
        exports.roundToDivide = roundToDivide;
        exports.scrollIntoView = scrollIntoView;
        exports.waitOnEventOrTimeout = waitOnEventOrTimeout;
        exports.watchScroll = watchScroll;
        exports.WaitOnType = exports.VERTICAL_PADDING = exports.UNKNOWN_SCALE = exports.TextLayerMode = exports.SpreadMode = exports.SidebarView = exports.ScrollMode = exports.SCROLLBAR_PADDING = exports.RendererType = exports.ProgressBar = exports.PresentationModeState = exports.MIN_SCALE = exports.MAX_SCALE = exports.MAX_AUTO_SCALE = exports.EventBus = exports.DEFAULT_SCALE_VALUE = exports.DEFAULT_SCALE_DELTA = exports.DEFAULT_SCALE = exports.AutoPrintRegExp = exports.AutomationEventBus = exports.animationStarted = void 0;
        var DEFAULT_SCALE_VALUE = "auto";
        exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;
        var DEFAULT_SCALE = 1.0;
        exports.DEFAULT_SCALE = DEFAULT_SCALE;
        var DEFAULT_SCALE_DELTA = 1.1;
        exports.DEFAULT_SCALE_DELTA = DEFAULT_SCALE_DELTA;
        var MIN_SCALE = 0.1;
        exports.MIN_SCALE = MIN_SCALE;
        var MAX_SCALE = 10.0;
        exports.MAX_SCALE = MAX_SCALE;
        var UNKNOWN_SCALE = 0;
        exports.UNKNOWN_SCALE = UNKNOWN_SCALE;
        var MAX_AUTO_SCALE = 1.25;
        exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE;
        var SCROLLBAR_PADDING = 40;
        exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING;
        var VERTICAL_PADDING = 5;
        exports.VERTICAL_PADDING = VERTICAL_PADDING;
        var LOADINGBAR_END_OFFSET_VAR = "--loadingBar-end-offset";
        var PresentationModeState = {
          UNKNOWN: 0,
          NORMAL: 1,
          CHANGING: 2,
          FULLSCREEN: 3
        };
        exports.PresentationModeState = PresentationModeState;
        var SidebarView = {
          UNKNOWN: -1,
          NONE: 0,
          THUMBS: 1,
          OUTLINE: 2,
          ATTACHMENTS: 3,
          LAYERS: 4
        };
        exports.SidebarView = SidebarView;
        var RendererType = {
          CANVAS: "canvas",
          SVG: "svg"
        };
        exports.RendererType = RendererType;
        var TextLayerMode = {
          DISABLE: 0,
          ENABLE: 1,
          ENABLE_ENHANCE: 2
        };
        exports.TextLayerMode = TextLayerMode;
        var ScrollMode = {
          UNKNOWN: -1,
          VERTICAL: 0,
          HORIZONTAL: 1,
          WRAPPED: 2
        };
        exports.ScrollMode = ScrollMode;
        var SpreadMode = {
          UNKNOWN: -1,
          NONE: 0,
          ODD: 1,
          EVEN: 2
        };
        exports.SpreadMode = SpreadMode;
        var AutoPrintRegExp = /\bprint\s*\(/;
        exports.AutoPrintRegExp = AutoPrintRegExp;

        function getOutputScale(ctx) {
          var devicePixelRatio = window.devicePixelRatio || 1;
          var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
          var pixelRatio = devicePixelRatio / backingStoreRatio;
          return {
            sx: pixelRatio,
            sy: pixelRatio,
            scaled: pixelRatio !== 1
          };
        }

        function scrollIntoView(element, spot) {
          var scrollMatches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
          var parent = element.offsetParent;

          if (!parent) {
            console.error("offsetParent is not set -- cannot scroll");
            return;
          }

          var offsetY = element.offsetTop + element.clientTop;
          var offsetX = element.offsetLeft + element.clientLeft;

          while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || scrollMatches && (parent.classList.contains("markedContent") || getComputedStyle(parent).overflow === "hidden")) {
            offsetY += parent.offsetTop;
            offsetX += parent.offsetLeft;
            parent = parent.offsetParent;

            if (!parent) {
              return;
            }
          }

          if (spot) {
            if (spot.top !== undefined) {
              offsetY += spot.top;
            }

            if (spot.left !== undefined) {
              offsetX += spot.left;
              parent.scrollLeft = offsetX;
            }
          }

          parent.scrollTop = offsetY;
        }

        function watchScroll(viewAreaElement, callback) {
          var debounceScroll = function debounceScroll(evt) {
            if (rAF) {
              return;
            }

            rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
              rAF = null;
              var currentX = viewAreaElement.scrollLeft;
              var lastX = state.lastX;

              if (currentX !== lastX) {
                state.right = currentX > lastX;
              }

              state.lastX = currentX;
              var currentY = viewAreaElement.scrollTop;
              var lastY = state.lastY;

              if (currentY !== lastY) {
                state.down = currentY > lastY;
              }

              state.lastY = currentY;
              callback(state);
            });
          };

          var state = {
            right: true,
            down: true,
            lastX: viewAreaElement.scrollLeft,
            lastY: viewAreaElement.scrollTop,
            _eventHandler: debounceScroll
          };
          var rAF = null;
          viewAreaElement.addEventListener("scroll", debounceScroll, true);
          return state;
        }

        function parseQueryString(query) {
          var params = new Map();

          var _iterator = _createForOfIteratorHelper(query.split("&")),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var part = _step.value;
              var param = part.split("="),
                  key = param[0].toLowerCase(),
                  value = param.length > 1 ? param[1] : "";
              params.set(decodeURIComponent(key), decodeURIComponent(value));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          return params;
        }

        function binarySearchFirstItem(items, condition) {
          var minIndex = 0;
          var maxIndex = items.length - 1;

          if (maxIndex < 0 || !condition(items[maxIndex])) {
            return items.length;
          }

          if (condition(items[minIndex])) {
            return minIndex;
          }

          while (minIndex < maxIndex) {
            var currentIndex = minIndex + maxIndex >> 1;
            var currentItem = items[currentIndex];

            if (condition(currentItem)) {
              maxIndex = currentIndex;
            } else {
              minIndex = currentIndex + 1;
            }
          }

          return minIndex;
        }

        function approximateFraction(x) {
          if (Math.floor(x) === x) {
            return [x, 1];
          }

          var xinv = 1 / x;
          var limit = 8;

          if (xinv > limit) {
            return [1, limit];
          } else if (Math.floor(xinv) === xinv) {
            return [1, xinv];
          }

          var x_ = x > 1 ? xinv : x;
          var a = 0,
              b = 1,
              c = 1,
              d = 1;

          while (true) {
            var p = a + c,
                q = b + d;

            if (q > limit) {
              break;
            }

            if (x_ <= p / q) {
              c = p;
              d = q;
            } else {
              a = p;
              b = q;
            }
          }

          var result;

          if (x_ - a / b < c / d - x_) {
            result = x_ === x ? [a, b] : [b, a];
          } else {
            result = x_ === x ? [c, d] : [d, c];
          }

          return result;
        }

        function roundToDivide(x, div) {
          var r = x % div;
          return r === 0 ? x : Math.round(x - r + div);
        }

        function getPageSizeInches(_ref3) {
          var view = _ref3.view,
              userUnit = _ref3.userUnit,
              rotate = _ref3.rotate;

          var _view = _slicedToArray(view, 4),
              x1 = _view[0],
              y1 = _view[1],
              x2 = _view[2],
              y2 = _view[3];

          var changeOrientation = rotate % 180 !== 0;
          var width = (x2 - x1) / 72 * userUnit;
          var height = (y2 - y1) / 72 * userUnit;
          return {
            width: changeOrientation ? height : width,
            height: changeOrientation ? width : height
          };
        }

        function backtrackBeforeAllVisibleElements(index, views, top) {
          if (index < 2) {
            return index;
          }

          var elt = views[index].div;
          var pageTop = elt.offsetTop + elt.clientTop;

          if (pageTop >= top) {
            elt = views[index - 1].div;
            pageTop = elt.offsetTop + elt.clientTop;
          }

          for (var i = index - 2; i >= 0; --i) {
            elt = views[i].div;

            if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {
              break;
            }

            index = i;
          }

          return index;
        }

        function getVisibleElements(_ref4) {
          var scrollEl = _ref4.scrollEl,
              views = _ref4.views,
              _ref4$sortByVisibilit = _ref4.sortByVisibility,
              sortByVisibility = _ref4$sortByVisibilit === void 0 ? false : _ref4$sortByVisibilit,
              _ref4$horizontal = _ref4.horizontal,
              horizontal = _ref4$horizontal === void 0 ? false : _ref4$horizontal,
              _ref4$rtl = _ref4.rtl,
              rtl = _ref4$rtl === void 0 ? false : _ref4$rtl;
          var top = scrollEl.scrollTop,
              bottom = top + scrollEl.clientHeight;
          var left = scrollEl.scrollLeft,
              right = left + scrollEl.clientWidth;

          function isElementBottomAfterViewTop(view) {
            var element = view.div;
            var elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
            return elementBottom > top;
          }

          function isElementNextAfterViewHorizontally(view) {
            var element = view.div;
            var elementLeft = element.offsetLeft + element.clientLeft;
            var elementRight = elementLeft + element.clientWidth;
            return rtl ? elementLeft < right : elementRight > left;
          }

          var visible = [],
              numViews = views.length;
          var firstVisibleElementInd = binarySearchFirstItem(views, horizontal ? isElementNextAfterViewHorizontally : isElementBottomAfterViewTop);

          if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {
            firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);
          }

          var lastEdge = horizontal ? right : -1;

          for (var i = firstVisibleElementInd; i < numViews; i++) {
            var view = views[i],
                element = view.div;
            var currentWidth = element.offsetLeft + element.clientLeft;
            var currentHeight = element.offsetTop + element.clientTop;
            var viewWidth = element.clientWidth,
                viewHeight = element.clientHeight;
            var viewRight = currentWidth + viewWidth;
            var viewBottom = currentHeight + viewHeight;

            if (lastEdge === -1) {
              if (viewBottom >= bottom) {
                lastEdge = viewBottom;
              }
            } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {
              break;
            }

            if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {
              continue;
            }

            var hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);
            var hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);
            var fractionHeight = (viewHeight - hiddenHeight) / viewHeight,
                fractionWidth = (viewWidth - hiddenWidth) / viewWidth;
            var percent = fractionHeight * fractionWidth * 100 | 0;
            visible.push({
              id: view.id,
              x: currentWidth,
              y: currentHeight,
              view: view,
              percent: percent,
              widthPercent: fractionWidth * 100 | 0
            });
          }

          var first = visible[0],
              last = visible[visible.length - 1];

          if (sortByVisibility) {
            visible.sort(function (a, b) {
              var pc = a.percent - b.percent;

              if (Math.abs(pc) > 0.001) {
                return -pc;
              }

              return a.id - b.id;
            });
          }

          return {
            first: first,
            last: last,
            views: visible
          };
        }

        function noContextMenuHandler(evt) {
          evt.preventDefault();
        }

        function normalizeWheelEventDirection(evt) {
          var delta = Math.hypot(evt.deltaX, evt.deltaY);
          var angle = Math.atan2(evt.deltaY, evt.deltaX);

          if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {
            delta = -delta;
          }

          return delta;
        }

        function normalizeWheelEventDelta(evt) {
          var delta = normalizeWheelEventDirection(evt);
          var MOUSE_DOM_DELTA_PIXEL_MODE = 0;
          var MOUSE_DOM_DELTA_LINE_MODE = 1;
          var MOUSE_PIXELS_PER_LINE = 30;
          var MOUSE_LINES_PER_PAGE = 30;

          if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {
            delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;
          } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {
            delta /= MOUSE_LINES_PER_PAGE;
          }

          return delta;
        }

        function isValidRotation(angle) {
          return Number.isInteger(angle) && angle % 90 === 0;
        }

        function isValidScrollMode(mode) {
          return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;
        }

        function isValidSpreadMode(mode) {
          return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;
        }

        function isPortraitOrientation(size) {
          return size.width <= size.height;
        }

        var WaitOnType = {
          EVENT: "event",
          TIMEOUT: "timeout"
        };
        exports.WaitOnType = WaitOnType;

        function waitOnEventOrTimeout(_ref5) {
          var target = _ref5.target,
              name = _ref5.name,
              _ref5$delay = _ref5.delay,
              delay = _ref5$delay === void 0 ? 0 : _ref5$delay;
          return new Promise(function (resolve, reject) {
            if (_typeof(target) !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) {
              throw new Error("waitOnEventOrTimeout - invalid parameters.");
            }

            function handler(type) {
              if (target instanceof EventBus) {
                target._off(name, eventHandler);
              } else {
                target.removeEventListener(name, eventHandler);
              }

              if (timeout) {
                clearTimeout(timeout);
              }

              resolve(type);
            }

            var eventHandler = handler.bind(null, WaitOnType.EVENT);

            if (target instanceof EventBus) {
              target._on(name, eventHandler);
            } else {
              target.addEventListener(name, eventHandler);
            }

            var timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);
            var timeout = setTimeout(timeoutHandler, delay);
          });
        }

        var animationStarted = new Promise(function (resolve) {
          window.requestAnimationFrame(resolve);
        });
        exports.animationStarted = animationStarted;

        var EventBus = /*#__PURE__*/function () {
          function EventBus() {
            _classCallCheck(this, EventBus);

            this._listeners = Object.create(null);
          }

          _createClass(EventBus, [{
            key: "on",
            value: function on(eventName, listener) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

              this._on(eventName, listener, {
                external: true,
                once: options === null || options === void 0 ? void 0 : options.once
              });
            }
          }, {
            key: "off",
            value: function off(eventName, listener) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

              this._off(eventName, listener, {
                external: true,
                once: options === null || options === void 0 ? void 0 : options.once
              });
            }
          }, {
            key: "dispatch",
            value: function dispatch(eventName, data) {
              var eventListeners = this._listeners[eventName];

              if (!eventListeners || eventListeners.length === 0) {
                return;
              }

              var externalListeners;

              var _iterator2 = _createForOfIteratorHelper(eventListeners.slice(0)),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var _step2$value = _step2.value,
                      _listener = _step2$value.listener,
                      external = _step2$value.external,
                      once = _step2$value.once;

                  if (once) {
                    this._off(eventName, _listener);
                  }

                  if (external) {
                    (externalListeners || (externalListeners = [])).push(_listener);
                    continue;
                  }

                  _listener(data);
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }

              if (externalListeners) {
                var _iterator3 = _createForOfIteratorHelper(externalListeners),
                    _step3;

                try {
                  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                    var listener = _step3.value;
                    listener(data);
                  }
                } catch (err) {
                  _iterator3.e(err);
                } finally {
                  _iterator3.f();
                }

                externalListeners = null;
              }
            }
          }, {
            key: "_on",
            value: function _on(eventName, listener) {
              var _this$_listeners;

              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              var eventListeners = (_this$_listeners = this._listeners)[eventName] || (_this$_listeners[eventName] = []);
              eventListeners.push({
                listener: listener,
                external: (options === null || options === void 0 ? void 0 : options.external) === true,
                once: (options === null || options === void 0 ? void 0 : options.once) === true
              });
            }
          }, {
            key: "_off",
            value: function _off(eventName, listener) {
              var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              var eventListeners = this._listeners[eventName];

              if (!eventListeners) {
                return;
              }

              for (var i = 0, ii = eventListeners.length; i < ii; i++) {
                if (eventListeners[i].listener === listener) {
                  eventListeners.splice(i, 1);
                  return;
                }
              }
            }
          }]);

          return EventBus;
        }();

        exports.EventBus = EventBus;

        var AutomationEventBus = /*#__PURE__*/function (_EventBus) {
          _inherits(AutomationEventBus, _EventBus);

          var _super = _createSuper(AutomationEventBus);

          function AutomationEventBus() {
            _classCallCheck(this, AutomationEventBus);

            return _super.apply(this, arguments);
          }

          _createClass(AutomationEventBus, [{
            key: "dispatch",
            value: function dispatch(eventName, data) {
              throw new Error("Not implemented: AutomationEventBus.dispatch");
            }
          }]);

          return AutomationEventBus;
        }(EventBus);

        exports.AutomationEventBus = AutomationEventBus;

        function clamp(v, min, max) {
          return Math.min(Math.max(v, min), max);
        }

        var ProgressBar = /*#__PURE__*/function () {
          function ProgressBar(id) {
            var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
                height = _ref6.height,
                width = _ref6.width,
                units = _ref6.units;

            _classCallCheck(this, ProgressBar);

            this.visible = true;
            this.div = document.querySelector(id + " .progress");
            this.bar = this.div.parentNode;
            this.height = height || 100;
            this.width = width || 100;
            this.units = units || "%";
            this.div.style.height = this.height + this.units;
            this.percent = 0;
          }

          _createClass(ProgressBar, [{
            key: "_updateBar",
            value: function _updateBar() {
              if (this._indeterminate) {
                this.div.classList.add("indeterminate");
                this.div.style.width = this.width + this.units;
                return;
              }

              this.div.classList.remove("indeterminate");
              var progressSize = this.width * this._percent / 100;
              this.div.style.width = progressSize + this.units;
            }
          }, {
            key: "percent",
            get: function get() {
              return this._percent;
            },
            set: function set(val) {
              this._indeterminate = isNaN(val);
              this._percent = clamp(val, 0, 100);

              this._updateBar();
            }
          }, {
            key: "setWidth",
            value: function setWidth(viewer) {
              if (!viewer) {
                return;
              }

              var container = viewer.parentNode;
              var scrollbarWidth = container.offsetWidth - viewer.offsetWidth;

              if (scrollbarWidth > 0) {
                var doc = document.documentElement;
                doc.style.setProperty(LOADINGBAR_END_OFFSET_VAR, "".concat(scrollbarWidth, "px"));
              }
            }
          }, {
            key: "hide",
            value: function hide() {
              if (!this.visible) {
                return;
              }

              this.visible = false;
              this.bar.classList.add("hidden");
            }
          }, {
            key: "show",
            value: function show() {
              if (this.visible) {
                return;
              }

              this.visible = true;
              this.bar.classList.remove("hidden");
            }
          }]);

          return ProgressBar;
        }();

        exports.ProgressBar = ProgressBar;

        function moveToEndOfArray(arr, condition) {
          var moved = [],
              len = arr.length;
          var write = 0;

          for (var read = 0; read < len; ++read) {
            if (condition(arr[read])) {
              moved.push(arr[read]);
            } else {
              arr[write] = arr[read];
              ++write;
            }
          }

          for (var _read = 0; write < len; ++_read, ++write) {
            arr[write] = moved[_read];
          }
        }

        function getActiveOrFocusedElement() {
          var curRoot = document;
          var curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");

          while ((_curActiveOrFocused = curActiveOrFocused) !== null && _curActiveOrFocused !== void 0 && _curActiveOrFocused.shadowRoot) {
            var _curActiveOrFocused;

            curRoot = curActiveOrFocused.shadowRoot;
            curActiveOrFocused = curRoot.activeElement || curRoot.querySelector(":focus");
          }

          return curActiveOrFocused;
        }

        function apiPageLayoutToSpreadMode(layout) {
          switch (layout) {
            case "SinglePage":
            case "OneColumn":
              return SpreadMode.NONE;

            case "TwoColumnLeft":
            case "TwoPageLeft":
              return SpreadMode.ODD;

            case "TwoColumnRight":
            case "TwoPageRight":
              return SpreadMode.EVEN;
          }

          return SpreadMode.NONE;
        }

        function apiPageModeToSidebarView(mode) {
          switch (mode) {
            case "UseNone":
              return SidebarView.NONE;

            case "UseThumbs":
              return SidebarView.THUMBS;

            case "UseOutlines":
              return SidebarView.OUTLINE;

            case "UseAttachments":
              return SidebarView.ATTACHMENTS;

            case "UseOC":
              return SidebarView.LAYERS;
          }

          return SidebarView.NONE;
        }
        /***/

      },
      /* 6 */

      /***/
      function (__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.StructTreeLayerBuilder = exports.DefaultStructTreeLayerFactory = void 0;
        var PDF_ROLE_TO_HTML_ROLE = {
          Document: null,
          DocumentFragment: null,
          Part: "group",
          Sect: "group",
          Div: "group",
          Aside: "note",
          NonStruct: "none",
          P: null,
          H: "heading",
          Title: null,
          FENote: "note",
          Sub: "group",
          Lbl: null,
          Span: null,
          Em: null,
          Strong: null,
          Link: "link",
          Annot: "note",
          Form: "form",
          Ruby: null,
          RB: null,
          RT: null,
          RP: null,
          Warichu: null,
          WT: null,
          WP: null,
          L: "list",
          LI: "listitem",
          LBody: null,
          Table: "table",
          TR: "row",
          TH: "columnheader",
          TD: "cell",
          THead: "columnheader",
          TBody: null,
          TFoot: null,
          Caption: null,
          Figure: "figure",
          Formula: null,
          Artifact: null
        };
        var HEADING_PATTERN = /^H(\d+)$/;

        var StructTreeLayerBuilder = /*#__PURE__*/function () {
          function StructTreeLayerBuilder(_ref7) {
            var pdfPage = _ref7.pdfPage;

            _classCallCheck(this, StructTreeLayerBuilder);

            this.pdfPage = pdfPage;
          }

          _createClass(StructTreeLayerBuilder, [{
            key: "render",
            value: function render(structTree) {
              return this._walk(structTree);
            }
          }, {
            key: "_setAttributes",
            value: function _setAttributes(structElement, htmlElement) {
              if (structElement.alt !== undefined) {
                htmlElement.setAttribute("aria-label", structElement.alt);
              }

              if (structElement.id !== undefined) {
                htmlElement.setAttribute("aria-owns", structElement.id);
              }
            }
          }, {
            key: "_walk",
            value: function _walk(node) {
              if (!node) {
                return null;
              }

              var element = document.createElement("span");

              if ("role" in node) {
                var role = node.role;
                var match = role.match(HEADING_PATTERN);

                if (match) {
                  element.setAttribute("role", "heading");
                  element.setAttribute("aria-level", match[1]);
                } else if (PDF_ROLE_TO_HTML_ROLE[role]) {
                  element.setAttribute("role", PDF_ROLE_TO_HTML_ROLE[role]);
                }
              }

              this._setAttributes(node, element);

              if (node.children) {
                if (node.children.length === 1 && "id" in node.children[0]) {
                  this._setAttributes(node.children[0], element);
                } else {
                  var _iterator4 = _createForOfIteratorHelper(node.children),
                      _step4;

                  try {
                    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                      var kid = _step4.value;
                      element.appendChild(this._walk(kid));
                    }
                  } catch (err) {
                    _iterator4.e(err);
                  } finally {
                    _iterator4.f();
                  }
                }
              }

              return element;
            }
          }]);

          return StructTreeLayerBuilder;
        }();

        exports.StructTreeLayerBuilder = StructTreeLayerBuilder;

        var DefaultStructTreeLayerFactory = /*#__PURE__*/function () {
          function DefaultStructTreeLayerFactory() {
            _classCallCheck(this, DefaultStructTreeLayerFactory);
          }

          _createClass(DefaultStructTreeLayerFactory, [{
            key: "createStructTreeLayerBuilder",
            value: function createStructTreeLayerBuilder(pdfPage) {
              return new StructTreeLayerBuilder({
                pdfPage: pdfPage
              });
            }
          }]);

          return DefaultStructTreeLayerFactory;
        }();

        exports.DefaultStructTreeLayerFactory = DefaultStructTreeLayerFactory;
        /***/
      },
      /* 7 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.TextLayerBuilder = exports.DefaultTextLayerFactory = void 0;

        var _pdfjsLib = __w_pdfjs_require__(2);

        var EXPAND_DIVS_TIMEOUT = 300;

        var TextLayerBuilder = /*#__PURE__*/function () {
          function TextLayerBuilder(_ref8) {
            var textLayerDiv = _ref8.textLayerDiv,
                eventBus = _ref8.eventBus,
                pageIndex = _ref8.pageIndex,
                viewport = _ref8.viewport,
                _ref8$highlighter = _ref8.highlighter,
                highlighter = _ref8$highlighter === void 0 ? null : _ref8$highlighter,
                _ref8$enhanceTextSele = _ref8.enhanceTextSelection,
                enhanceTextSelection = _ref8$enhanceTextSele === void 0 ? false : _ref8$enhanceTextSele;

            _classCallCheck(this, TextLayerBuilder);

            this.textLayerDiv = textLayerDiv;
            this.eventBus = eventBus;
            this.textContent = null;
            this.textContentItemsStr = [];
            this.textContentStream = null;
            this.renderingDone = false;
            this.pageNumber = pageIndex + 1;
            this.viewport = viewport;
            this.textDivs = [];
            this.textLayerRenderTask = null;
            this.highlighter = highlighter;
            this.enhanceTextSelection = enhanceTextSelection;

            this._bindMouse();
          }

          _createClass(TextLayerBuilder, [{
            key: "_finishRendering",
            value: function _finishRendering() {
              this.renderingDone = true;

              if (!this.enhanceTextSelection) {
                var endOfContent = document.createElement("div");
                endOfContent.className = "endOfContent";
                this.textLayerDiv.appendChild(endOfContent);
              }

              this.eventBus.dispatch("textlayerrendered", {
                source: this,
                pageNumber: this.pageNumber,
                numTextDivs: this.textDivs.length
              });
            }
          }, {
            key: "render",
            value: function render() {
              var _this$highlighter,
                  _this2 = this;

              var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

              if (!(this.textContent || this.textContentStream) || this.renderingDone) {
                return;
              }

              this.cancel();
              this.textDivs.length = 0;
              (_this$highlighter = this.highlighter) === null || _this$highlighter === void 0 ? void 0 : _this$highlighter.setTextMapping(this.textDivs, this.textContentItemsStr);
              var textLayerFrag = document.createDocumentFragment();
              this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({
                textContent: this.textContent,
                textContentStream: this.textContentStream,
                container: textLayerFrag,
                viewport: this.viewport,
                textDivs: this.textDivs,
                textContentItemsStr: this.textContentItemsStr,
                timeout: timeout,
                enhanceTextSelection: this.enhanceTextSelection
              });
              this.textLayerRenderTask.promise.then(function () {
                var _this2$highlighter;

                _this2.textLayerDiv.appendChild(textLayerFrag);

                _this2._finishRendering();

                (_this2$highlighter = _this2.highlighter) === null || _this2$highlighter === void 0 ? void 0 : _this2$highlighter.enable();
              }, function (reason) {});
            }
          }, {
            key: "cancel",
            value: function cancel() {
              var _this$highlighter2;

              if (this.textLayerRenderTask) {
                this.textLayerRenderTask.cancel();
                this.textLayerRenderTask = null;
              }

              (_this$highlighter2 = this.highlighter) === null || _this$highlighter2 === void 0 ? void 0 : _this$highlighter2.disable();
            }
          }, {
            key: "setTextContentStream",
            value: function setTextContentStream(readableStream) {
              this.cancel();
              this.textContentStream = readableStream;
            }
          }, {
            key: "setTextContent",
            value: function setTextContent(textContent) {
              this.cancel();
              this.textContent = textContent;
            }
          }, {
            key: "_bindMouse",
            value: function _bindMouse() {
              var _this3 = this;

              var div = this.textLayerDiv;
              var expandDivsTimer = null;
              div.addEventListener("mousedown", function (evt) {
                if (_this3.enhanceTextSelection && _this3.textLayerRenderTask) {
                  _this3.textLayerRenderTask.expandTextDivs(true);

                  if (expandDivsTimer) {
                    clearTimeout(expandDivsTimer);
                    expandDivsTimer = null;
                  }

                  return;
                }

                var end = div.querySelector(".endOfContent");

                if (!end) {
                  return;
                }

                var adjustTop = evt.target !== div;
                adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none";

                if (adjustTop) {
                  var divBounds = div.getBoundingClientRect();
                  var r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);
                  end.style.top = (r * 100).toFixed(2) + "%";
                }

                end.classList.add("active");
              });
              div.addEventListener("mouseup", function () {
                if (_this3.enhanceTextSelection && _this3.textLayerRenderTask) {
                  expandDivsTimer = setTimeout(function () {
                    if (_this3.textLayerRenderTask) {
                      _this3.textLayerRenderTask.expandTextDivs(false);
                    }

                    expandDivsTimer = null;
                  }, EXPAND_DIVS_TIMEOUT);
                  return;
                }

                var end = div.querySelector(".endOfContent");

                if (!end) {
                  return;
                }

                end.style.top = "";
                end.classList.remove("active");
              });
            }
          }]);

          return TextLayerBuilder;
        }();

        exports.TextLayerBuilder = TextLayerBuilder;

        var DefaultTextLayerFactory = /*#__PURE__*/function () {
          function DefaultTextLayerFactory() {
            _classCallCheck(this, DefaultTextLayerFactory);
          }

          _createClass(DefaultTextLayerFactory, [{
            key: "createTextLayerBuilder",
            value: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) {
              var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
              var eventBus = arguments.length > 4 ? arguments[4] : undefined;
              var highlighter = arguments.length > 5 ? arguments[5] : undefined;
              return new TextLayerBuilder({
                textLayerDiv: textLayerDiv,
                pageIndex: pageIndex,
                viewport: viewport,
                enhanceTextSelection: enhanceTextSelection,
                eventBus: eventBus,
                highlighter: highlighter
              });
            }
          }]);

          return DefaultTextLayerFactory;
        }();

        exports.DefaultTextLayerFactory = DefaultTextLayerFactory;
        /***/
      },
      /* 8 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.XfaLayerBuilder = exports.DefaultXfaLayerFactory = void 0;

        var _pdf_link_service = __w_pdfjs_require__(4);

        var _pdfjsLib = __w_pdfjs_require__(2);

        var XfaLayerBuilder = /*#__PURE__*/function () {
          function XfaLayerBuilder(_ref9) {
            var pageDiv = _ref9.pageDiv,
                pdfPage = _ref9.pdfPage,
                annotationStorage = _ref9.annotationStorage,
                linkService = _ref9.linkService,
                xfaHtml = _ref9.xfaHtml;

            _classCallCheck(this, XfaLayerBuilder);

            this.pageDiv = pageDiv;
            this.pdfPage = pdfPage;
            this.annotationStorage = annotationStorage;
            this.linkService = linkService;
            this.xfaHtml = xfaHtml;
            this.div = null;
            this._cancelled = false;
          }

          _createClass(XfaLayerBuilder, [{
            key: "render",
            value: function render(viewport) {
              var _this4 = this;

              var intent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "display";

              if (intent === "print") {
                var parameters = {
                  viewport: viewport.clone({
                    dontFlip: true
                  }),
                  div: this.div,
                  xfa: this.xfaHtml,
                  page: null,
                  annotationStorage: this.annotationStorage,
                  linkService: this.linkService,
                  intent: intent
                };
                var div = document.createElement("div");
                this.pageDiv.appendChild(div);
                parameters.div = div;

                var result = _pdfjsLib.XfaLayer.render(parameters);

                return Promise.resolve(result);
              }

              return this.pdfPage.getXfa().then(function (xfa) {
                if (_this4._cancelled || !xfa) {
                  return {
                    textDivs: []
                  };
                }

                var parameters = {
                  viewport: viewport.clone({
                    dontFlip: true
                  }),
                  div: _this4.div,
                  xfa: xfa,
                  page: _this4.pdfPage,
                  annotationStorage: _this4.annotationStorage,
                  linkService: _this4.linkService,
                  intent: intent
                };

                if (_this4.div) {
                  return _pdfjsLib.XfaLayer.update(parameters);
                }

                _this4.div = document.createElement("div");

                _this4.pageDiv.appendChild(_this4.div);

                parameters.div = _this4.div;
                return _pdfjsLib.XfaLayer.render(parameters);
              })["catch"](function (error) {
                console.error(error);
              });
            }
          }, {
            key: "cancel",
            value: function cancel() {
              this._cancelled = true;
            }
          }, {
            key: "hide",
            value: function hide() {
              if (!this.div) {
                return;
              }

              this.div.hidden = true;
            }
          }]);

          return XfaLayerBuilder;
        }();

        exports.XfaLayerBuilder = XfaLayerBuilder;

        var DefaultXfaLayerFactory = /*#__PURE__*/function () {
          function DefaultXfaLayerFactory() {
            _classCallCheck(this, DefaultXfaLayerFactory);
          }

          _createClass(DefaultXfaLayerFactory, [{
            key: "createXfaLayerBuilder",
            value: function createXfaLayerBuilder(pageDiv, pdfPage) {
              var annotationStorage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              var xfaHtml = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
              return new XfaLayerBuilder({
                pageDiv: pageDiv,
                pdfPage: pdfPage,
                annotationStorage: annotationStorage,
                linkService: new _pdf_link_service.SimpleLinkService(),
                xfaHtml: xfaHtml
              });
            }
          }]);

          return DefaultXfaLayerFactory;
        }();

        exports.DefaultXfaLayerFactory = DefaultXfaLayerFactory;
        /***/
      },
      /* 9 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.DownloadManager = void 0;

        var _pdfjsLib = __w_pdfjs_require__(2);

        var _app_options = __w_pdfjs_require__(10);

        ;

        function _download(blobUrl, filename) {
          var a = document.createElement("a");

          if (!a.click) {
            throw new Error('DownloadManager: "a.click()" is not supported.');
          }

          a.href = blobUrl;
          a.target = "_parent";

          if ("download" in a) {
            a.download = filename;
          }

          (document.body || document.documentElement).appendChild(a);
          a.click();
          a.remove();
        }

        var DownloadManager = /*#__PURE__*/function () {
          function DownloadManager() {
            _classCallCheck(this, DownloadManager);

            this._openBlobUrls = new WeakMap();
          }

          _createClass(DownloadManager, [{
            key: "downloadUrl",
            value: function downloadUrl(url, filename) {
              if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, "http://example.com")) {
                console.error("downloadUrl - not a valid URL: ".concat(url));
                return;
              }

              _download(url + "#pdfjs.action=download", filename);
            }
          }, {
            key: "downloadData",
            value: function downloadData(data, filename, contentType) {
              var blobUrl = (0, _pdfjsLib.createObjectURL)(data, contentType, _app_options.compatibilityParams.disableCreateObjectURL);

              _download(blobUrl, filename);
            }
          }, {
            key: "openOrDownloadData",
            value: function openOrDownloadData(element, data, filename) {
              var isPdfData = (0, _pdfjsLib.isPdfFile)(filename);
              var contentType = isPdfData ? "application/pdf" : "";

              if (isPdfData && !_app_options.compatibilityParams.disableCreateObjectURL) {
                var blobUrl = this._openBlobUrls.get(element);

                if (!blobUrl) {
                  blobUrl = URL.createObjectURL(new Blob([data], {
                    type: contentType
                  }));

                  this._openBlobUrls.set(element, blobUrl);
                }

                var viewerUrl;
                viewerUrl = "?file=" + encodeURIComponent(blobUrl + "#" + filename);

                try {
                  window.open(viewerUrl);
                  return true;
                } catch (ex) {
                  console.error("openOrDownloadData: ".concat(ex));
                  URL.revokeObjectURL(blobUrl);

                  this._openBlobUrls["delete"](element);
                }
              }

              this.downloadData(data, filename, contentType);
              return false;
            }
          }, {
            key: "download",
            value: function download(blob, url, filename) {
              var sourceEventType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "download";

              if (_app_options.compatibilityParams.disableCreateObjectURL) {
                this.downloadUrl(url, filename);
                return;
              }

              var blobUrl = URL.createObjectURL(blob);

              _download(blobUrl, filename);
            }
          }]);

          return DownloadManager;
        }();

        exports.DownloadManager = DownloadManager;
        /***/
      },
      /* 10 */

      /***/
      function (__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.OptionKind = exports.compatibilityParams = exports.AppOptions = void 0;
        var compatibilityParams = Object.create(null);
        exports.compatibilityParams = compatibilityParams;
        {
          var userAgent = typeof navigator !== "undefined" && navigator.userAgent || "";
          var platform = typeof navigator !== "undefined" && navigator.platform || "";
          var maxTouchPoints = typeof navigator !== "undefined" && navigator.maxTouchPoints || 1;
          var isAndroid = /Android/.test(userAgent);
          var isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1;
          var isIOSChrome = /CriOS/.test(userAgent);

          (function checkOnBlobSupport() {
            if (isIOSChrome) {
              compatibilityParams.disableCreateObjectURL = true;
            }
          })();

          (function checkCanvasSizeLimitation() {
            if (isIOS || isAndroid) {
              compatibilityParams.maxCanvasPixels = 5242880;
            }
          })();
        }
        var OptionKind = {
          VIEWER: 0x02,
          API: 0x04,
          WORKER: 0x08,
          PREFERENCE: 0x80
        };
        exports.OptionKind = OptionKind;
        var defaultOptions = {
          annotationMode: {
            value: 2,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          cursorToolOnLoad: {
            value: 0,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          defaultUrl: {
            value: "compressed.tracemonkey-pldi-09.pdf",
            kind: OptionKind.VIEWER
          },
          defaultZoomValue: {
            value: "",
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          disableHistory: {
            value: false,
            kind: OptionKind.VIEWER
          },
          disablePageLabels: {
            value: false,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          enablePermissions: {
            value: false,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          enablePrintAutoRotate: {
            value: true,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          enableScripting: {
            value: true,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          externalLinkRel: {
            value: "noopener noreferrer nofollow",
            kind: OptionKind.VIEWER
          },
          externalLinkTarget: {
            value: 0,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          historyUpdateUrl: {
            value: false,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          ignoreDestinationZoom: {
            value: false,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          imageResourcesPath: {
            value: "./images/",
            kind: OptionKind.VIEWER
          },
          maxCanvasPixels: {
            value: 16777216,
            compatibility: compatibilityParams.maxCanvasPixels,
            kind: OptionKind.VIEWER
          },
          pdfBugEnabled: {
            value: false,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          printResolution: {
            value: 150,
            kind: OptionKind.VIEWER
          },
          renderer: {
            value: "canvas",
            kind: OptionKind.VIEWER
          },
          sidebarViewOnLoad: {
            value: -1,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          scrollModeOnLoad: {
            value: -1,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          spreadModeOnLoad: {
            value: -1,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          textLayerMode: {
            value: 1,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          useOnlyCssZoom: {
            value: false,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          viewerCssTheme: {
            value: 0,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          viewOnLoad: {
            value: 0,
            kind: OptionKind.VIEWER + OptionKind.PREFERENCE
          },
          cMapPacked: {
            value: true,
            kind: OptionKind.API
          },
          cMapUrl: {
            value: "../web/cmaps/",
            kind: OptionKind.API
          },
          disableAutoFetch: {
            value: false,
            kind: OptionKind.API + OptionKind.PREFERENCE
          },
          disableFontFace: {
            value: false,
            kind: OptionKind.API + OptionKind.PREFERENCE
          },
          disableRange: {
            value: false,
            kind: OptionKind.API + OptionKind.PREFERENCE
          },
          disableStream: {
            value: false,
            kind: OptionKind.API + OptionKind.PREFERENCE
          },
          docBaseUrl: {
            value: "",
            kind: OptionKind.API
          },
          enableXfa: {
            value: true,
            kind: OptionKind.API + OptionKind.PREFERENCE
          },
          fontExtraProperties: {
            value: false,
            kind: OptionKind.API
          },
          isEvalSupported: {
            value: true,
            kind: OptionKind.API
          },
          maxImageSize: {
            value: -1,
            kind: OptionKind.API
          },
          pdfBug: {
            value: false,
            kind: OptionKind.API
          },
          standardFontDataUrl: {
            value: "../web/standard_fonts/",
            kind: OptionKind.API
          },
          verbosity: {
            value: 1,
            kind: OptionKind.API
          },
          workerPort: {
            value: null,
            kind: OptionKind.WORKER
          },
          workerSrc: {
            value: "../build/pdf.worker.js",
            kind: OptionKind.WORKER
          }
        };
        {
          defaultOptions.disablePreferences = {
            value: false,
            kind: OptionKind.VIEWER
          };
          defaultOptions.locale = {
            value: typeof navigator !== "undefined" ? navigator.language : "en-US",
            kind: OptionKind.VIEWER
          };
          defaultOptions.sandboxBundleSrc = {
            value: "../build/pdf.sandbox.js",
            kind: OptionKind.VIEWER
          };
          defaultOptions.renderer.kind += OptionKind.PREFERENCE;
        }
        var userOptions = Object.create(null);

        var AppOptions = /*#__PURE__*/function () {
          function AppOptions() {
            _classCallCheck(this, AppOptions);

            throw new Error("Cannot initialize AppOptions.");
          }

          _createClass(AppOptions, null, [{
            key: "get",
            value: function get(name) {
              var userOption = userOptions[name];

              if (userOption !== undefined) {
                return userOption;
              }

              var defaultOption = defaultOptions[name];

              if (defaultOption !== undefined) {
                var _defaultOption$compat;

                return (_defaultOption$compat = defaultOption.compatibility) !== null && _defaultOption$compat !== void 0 ? _defaultOption$compat : defaultOption.value;
              }

              return undefined;
            }
          }, {
            key: "getAll",
            value: function getAll() {
              var kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
              var options = Object.create(null);

              for (var name in defaultOptions) {
                var _defaultOption$compat2;

                var defaultOption = defaultOptions[name];

                if (kind) {
                  if ((kind & defaultOption.kind) === 0) {
                    continue;
                  }

                  if (kind === OptionKind.PREFERENCE) {
                    var value = defaultOption.value,
                        valueType = _typeof(value);

                    if (valueType === "boolean" || valueType === "string" || valueType === "number" && Number.isInteger(value)) {
                      options[name] = value;
                      continue;
                    }

                    throw new Error("Invalid type for preference: ".concat(name));
                  }
                }

                var userOption = userOptions[name];
                options[name] = userOption !== undefined ? userOption : (_defaultOption$compat2 = defaultOption.compatibility) !== null && _defaultOption$compat2 !== void 0 ? _defaultOption$compat2 : defaultOption.value;
              }

              return options;
            }
          }, {
            key: "set",
            value: function set(name, value) {
              userOptions[name] = value;
            }
          }, {
            key: "setAll",
            value: function setAll(options) {
              for (var name in options) {
                userOptions[name] = options[name];
              }
            }
          }, {
            key: "remove",
            value: function remove(name) {
              delete userOptions[name];
            }
          }, {
            key: "_hasUserOptions",
            value: function _hasUserOptions() {
              return Object.keys(userOptions).length > 0;
            }
          }]);

          return AppOptions;
        }();

        exports.AppOptions = AppOptions;
        /***/
      },
      /* 11 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.GenericL10n = void 0;

        __w_pdfjs_require__(12);

        var _l10n_utils = __w_pdfjs_require__(3);

        var webL10n = document.webL10n;

        var GenericL10n = /*#__PURE__*/function () {
          function GenericL10n(lang) {
            _classCallCheck(this, GenericL10n);

            this._lang = lang;
            this._ready = new Promise(function (resolve, reject) {
              webL10n.setLanguage((0, _l10n_utils.fixupLangCode)(lang), function () {
                resolve(webL10n);
              });
            });
          }

          _createClass(GenericL10n, [{
            key: "getLanguage",
            value: function () {
              var _getLanguage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
                var l10n;
                return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                  while (1) {
                    switch (_context8.prev = _context8.next) {
                      case 0:
                        _context8.next = 2;
                        return this._ready;

                      case 2:
                        l10n = _context8.sent;
                        return _context8.abrupt("return", l10n.getLanguage());

                      case 4:
                      case "end":
                        return _context8.stop();
                    }
                  }
                }, _callee8, this);
              }));

              function getLanguage() {
                return _getLanguage.apply(this, arguments);
              }

              return getLanguage;
            }()
          }, {
            key: "getDirection",
            value: function () {
              var _getDirection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
                var l10n;
                return _regeneratorRuntime().wrap(function _callee9$(_context9) {
                  while (1) {
                    switch (_context9.prev = _context9.next) {
                      case 0:
                        _context9.next = 2;
                        return this._ready;

                      case 2:
                        l10n = _context9.sent;
                        return _context9.abrupt("return", l10n.getDirection());

                      case 4:
                      case "end":
                        return _context9.stop();
                    }
                  }
                }, _callee9, this);
              }));

              function getDirection() {
                return _getDirection.apply(this, arguments);
              }

              return getDirection;
            }()
          }, {
            key: "get",
            value: function () {
              var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(key) {
                var args,
                    fallback,
                    l10n,
                    _args10 = arguments;
                return _regeneratorRuntime().wrap(function _callee10$(_context10) {
                  while (1) {
                    switch (_context10.prev = _context10.next) {
                      case 0:
                        args = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : null;
                        fallback = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : (0, _l10n_utils.getL10nFallback)(key, args);
                        _context10.next = 4;
                        return this._ready;

                      case 4:
                        l10n = _context10.sent;
                        return _context10.abrupt("return", l10n.get(key, args, fallback));

                      case 6:
                      case "end":
                        return _context10.stop();
                    }
                  }
                }, _callee10, this);
              }));

              function get(_x4) {
                return _get.apply(this, arguments);
              }

              return get;
            }()
          }, {
            key: "translate",
            value: function () {
              var _translate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(element) {
                var l10n;
                return _regeneratorRuntime().wrap(function _callee11$(_context11) {
                  while (1) {
                    switch (_context11.prev = _context11.next) {
                      case 0:
                        _context11.next = 2;
                        return this._ready;

                      case 2:
                        l10n = _context11.sent;
                        return _context11.abrupt("return", l10n.translate(element));

                      case 4:
                      case "end":
                        return _context11.stop();
                    }
                  }
                }, _callee11, this);
              }));

              function translate(_x5) {
                return _translate.apply(this, arguments);
              }

              return translate;
            }()
          }]);

          return GenericL10n;
        }();

        exports.GenericL10n = GenericL10n;
        /***/
      },
      /* 12 */

      /***/
      function () {
        document.webL10n = function (window, document, undefined) {
          var gL10nData = {};
          var gTextData = '';
          var gTextProp = 'textContent';
          var gLanguage = '';
          var gMacros = {};
          var gReadyState = 'loading';
          var gAsyncResourceLoading = true;

          function getL10nResourceLinks() {
            return document.querySelectorAll('link[type="application/l10n"]');
          }

          function getL10nDictionary() {
            var script = document.querySelector('script[type="application/l10n"]');
            return script ? JSON.parse(script.innerHTML) : null;
          }

          function getTranslatableChildren(element) {
            return element ? element.querySelectorAll('*[data-l10n-id]') : [];
          }

          function getL10nAttributes(element) {
            if (!element) return {};
            var l10nId = element.getAttribute('data-l10n-id');
            var l10nArgs = element.getAttribute('data-l10n-args');
            var args = {};

            if (l10nArgs) {
              try {
                args = JSON.parse(l10nArgs);
              } catch (e) {
                console.warn('could not parse arguments for #' + l10nId);
              }
            }

            return {
              id: l10nId,
              args: args
            };
          }

          function xhrLoadText(url, onSuccess, onFailure) {
            onSuccess = onSuccess || function _onSuccess(data) {};

            onFailure = onFailure || function _onFailure() {};

            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, gAsyncResourceLoading);

            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=utf-8');
            }

            xhr.onreadystatechange = function () {
              if (xhr.readyState == 4) {
                if (xhr.status == 200 || xhr.status === 0) {
                  onSuccess(xhr.responseText);
                } else {
                  onFailure();
                }
              }
            };

            xhr.onerror = onFailure;
            xhr.ontimeout = onFailure;

            try {
              xhr.send(null);
            } catch (e) {
              onFailure();
            }
          }

          function parseResource(href, lang, successCallback, failureCallback) {
            var baseURL = href.replace(/[^\/]*$/, '') || './';

            function evalString(text) {
              if (text.lastIndexOf('\\') < 0) return text;
              return text.replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\b/g, '\b').replace(/\\f/g, '\f').replace(/\\{/g, '{').replace(/\\}/g, '}').replace(/\\"/g, '"').replace(/\\'/g, "'");
            }

            function parseProperties(text, parsedPropertiesCallback) {
              var dictionary = {};
              var reBlank = /^\s*|\s*$/;
              var reComment = /^\s*#|^\s*$/;
              var reSection = /^\s*\[(.*)\]\s*$/;
              var reImport = /^\s*@import\s+url\((.*)\)\s*$/i;
              var reSplit = /^([^=\s]*)\s*=\s*(.+)$/;

              function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {
                var entries = rawText.replace(reBlank, '').split(/[\r\n]+/);
                var currentLang = '*';
                var genericLang = lang.split('-', 1)[0];
                var skipLang = false;
                var match = '';

                function nextEntry() {
                  while (true) {
                    if (!entries.length) {
                      parsedRawLinesCallback();
                      return;
                    }

                    var line = entries.shift();
                    if (reComment.test(line)) continue;

                    if (extendedSyntax) {
                      match = reSection.exec(line);

                      if (match) {
                        currentLang = match[1].toLowerCase();
                        skipLang = currentLang !== '*' && currentLang !== lang && currentLang !== genericLang;
                        continue;
                      } else if (skipLang) {
                        continue;
                      }

                      match = reImport.exec(line);

                      if (match) {
                        loadImport(baseURL + match[1], nextEntry);
                        return;
                      }
                    }

                    var tmp = line.match(reSplit);

                    if (tmp && tmp.length == 3) {
                      dictionary[tmp[1]] = evalString(tmp[2]);
                    }
                  }
                }

                nextEntry();
              }

              function loadImport(url, callback) {
                xhrLoadText(url, function (content) {
                  parseRawLines(content, false, callback);
                }, function () {
                  console.warn(url + ' not found.');
                  callback();
                });
              }

              parseRawLines(text, true, function () {
                parsedPropertiesCallback(dictionary);
              });
            }

            xhrLoadText(href, function (response) {
              gTextData += response;
              parseProperties(response, function (data) {
                for (var key in data) {
                  var id,
                      prop,
                      index = key.lastIndexOf('.');

                  if (index > 0) {
                    id = key.substring(0, index);
                    prop = key.substring(index + 1);
                  } else {
                    id = key;
                    prop = gTextProp;
                  }

                  if (!gL10nData[id]) {
                    gL10nData[id] = {};
                  }

                  gL10nData[id][prop] = data[key];
                }

                if (successCallback) {
                  successCallback();
                }
              });
            }, failureCallback);
          }

          function loadLocale(lang, callback) {
            if (lang) {
              lang = lang.toLowerCase();
            }

            callback = callback || function _callback() {};

            clear();
            gLanguage = lang;
            var langLinks = getL10nResourceLinks();
            var langCount = langLinks.length;

            if (langCount === 0) {
              var dict = getL10nDictionary();

              if (dict && dict.locales && dict.default_locale) {
                console.log('using the embedded JSON directory, early way out');
                gL10nData = dict.locales[lang];

                if (!gL10nData) {
                  var defaultLocale = dict.default_locale.toLowerCase();

                  for (var anyCaseLang in dict.locales) {
                    anyCaseLang = anyCaseLang.toLowerCase();

                    if (anyCaseLang === lang) {
                      gL10nData = dict.locales[lang];
                      break;
                    } else if (anyCaseLang === defaultLocale) {
                      gL10nData = dict.locales[defaultLocale];
                    }
                  }
                }

                callback();
              } else {
                console.log('no resource to load, early way out');
              }

              gReadyState = 'complete';
              return;
            }

            var onResourceLoaded = null;
            var gResourceCount = 0;

            onResourceLoaded = function onResourceLoaded() {
              gResourceCount++;

              if (gResourceCount >= langCount) {
                callback();
                gReadyState = 'complete';
              }
            };

            function L10nResourceLink(link) {
              var href = link.href;

              this.load = function (lang, callback) {
                parseResource(href, lang, callback, function () {
                  console.warn(href + ' not found.');
                  console.warn('"' + lang + '" resource not found');
                  gLanguage = '';
                  callback();
                });
              };
            }

            for (var i = 0; i < langCount; i++) {
              var resource = new L10nResourceLink(langLinks[i]);
              resource.load(lang, onResourceLoaded);
            }
          }

          function clear() {
            gL10nData = {};
            gTextData = '';
            gLanguage = '';
          }

          function getPluralRules(lang) {
            var locales2rules = {
              'af': 3,
              'ak': 4,
              'am': 4,
              'ar': 1,
              'asa': 3,
              'az': 0,
              'be': 11,
              'bem': 3,
              'bez': 3,
              'bg': 3,
              'bh': 4,
              'bm': 0,
              'bn': 3,
              'bo': 0,
              'br': 20,
              'brx': 3,
              'bs': 11,
              'ca': 3,
              'cgg': 3,
              'chr': 3,
              'cs': 12,
              'cy': 17,
              'da': 3,
              'de': 3,
              'dv': 3,
              'dz': 0,
              'ee': 3,
              'el': 3,
              'en': 3,
              'eo': 3,
              'es': 3,
              'et': 3,
              'eu': 3,
              'fa': 0,
              'ff': 5,
              'fi': 3,
              'fil': 4,
              'fo': 3,
              'fr': 5,
              'fur': 3,
              'fy': 3,
              'ga': 8,
              'gd': 24,
              'gl': 3,
              'gsw': 3,
              'gu': 3,
              'guw': 4,
              'gv': 23,
              'ha': 3,
              'haw': 3,
              'he': 2,
              'hi': 4,
              'hr': 11,
              'hu': 0,
              'id': 0,
              'ig': 0,
              'ii': 0,
              'is': 3,
              'it': 3,
              'iu': 7,
              'ja': 0,
              'jmc': 3,
              'jv': 0,
              'ka': 0,
              'kab': 5,
              'kaj': 3,
              'kcg': 3,
              'kde': 0,
              'kea': 0,
              'kk': 3,
              'kl': 3,
              'km': 0,
              'kn': 0,
              'ko': 0,
              'ksb': 3,
              'ksh': 21,
              'ku': 3,
              'kw': 7,
              'lag': 18,
              'lb': 3,
              'lg': 3,
              'ln': 4,
              'lo': 0,
              'lt': 10,
              'lv': 6,
              'mas': 3,
              'mg': 4,
              'mk': 16,
              'ml': 3,
              'mn': 3,
              'mo': 9,
              'mr': 3,
              'ms': 0,
              'mt': 15,
              'my': 0,
              'nah': 3,
              'naq': 7,
              'nb': 3,
              'nd': 3,
              'ne': 3,
              'nl': 3,
              'nn': 3,
              'no': 3,
              'nr': 3,
              'nso': 4,
              'ny': 3,
              'nyn': 3,
              'om': 3,
              'or': 3,
              'pa': 3,
              'pap': 3,
              'pl': 13,
              'ps': 3,
              'pt': 3,
              'rm': 3,
              'ro': 9,
              'rof': 3,
              'ru': 11,
              'rwk': 3,
              'sah': 0,
              'saq': 3,
              'se': 7,
              'seh': 3,
              'ses': 0,
              'sg': 0,
              'sh': 11,
              'shi': 19,
              'sk': 12,
              'sl': 14,
              'sma': 7,
              'smi': 7,
              'smj': 7,
              'smn': 7,
              'sms': 7,
              'sn': 3,
              'so': 3,
              'sq': 3,
              'sr': 11,
              'ss': 3,
              'ssy': 3,
              'st': 3,
              'sv': 3,
              'sw': 3,
              'syr': 3,
              'ta': 3,
              'te': 3,
              'teo': 3,
              'th': 0,
              'ti': 4,
              'tig': 3,
              'tk': 3,
              'tl': 4,
              'tn': 3,
              'to': 0,
              'tr': 0,
              'ts': 3,
              'tzm': 22,
              'uk': 11,
              'ur': 3,
              've': 3,
              'vi': 0,
              'vun': 3,
              'wa': 4,
              'wae': 3,
              'wo': 0,
              'xh': 3,
              'xog': 3,
              'yo': 0,
              'zh': 0,
              'zu': 3
            };

            function isIn(n, list) {
              return list.indexOf(n) !== -1;
            }

            function isBetween(n, start, end) {
              return start <= n && n <= end;
            }

            var pluralRules = {
              '0': function _(n) {
                return 'other';
              },
              '1': function _(n) {
                if (isBetween(n % 100, 3, 10)) return 'few';
                if (n === 0) return 'zero';
                if (isBetween(n % 100, 11, 99)) return 'many';
                if (n == 2) return 'two';
                if (n == 1) return 'one';
                return 'other';
              },
              '2': function _(n) {
                if (n !== 0 && n % 10 === 0) return 'many';
                if (n == 2) return 'two';
                if (n == 1) return 'one';
                return 'other';
              },
              '3': function _(n) {
                if (n == 1) return 'one';
                return 'other';
              },
              '4': function _(n) {
                if (isBetween(n, 0, 1)) return 'one';
                return 'other';
              },
              '5': function _(n) {
                if (isBetween(n, 0, 2) && n != 2) return 'one';
                return 'other';
              },
              '6': function _(n) {
                if (n === 0) return 'zero';
                if (n % 10 == 1 && n % 100 != 11) return 'one';
                return 'other';
              },
              '7': function _(n) {
                if (n == 2) return 'two';
                if (n == 1) return 'one';
                return 'other';
              },
              '8': function _(n) {
                if (isBetween(n, 3, 6)) return 'few';
                if (isBetween(n, 7, 10)) return 'many';
                if (n == 2) return 'two';
                if (n == 1) return 'one';
                return 'other';
              },
              '9': function _(n) {
                if (n === 0 || n != 1 && isBetween(n % 100, 1, 19)) return 'few';
                if (n == 1) return 'one';
                return 'other';
              },
              '10': function _(n) {
                if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19)) return 'few';
                if (n % 10 == 1 && !isBetween(n % 100, 11, 19)) return 'one';
                return 'other';
              },
              '11': function _(n) {
                if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
                if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return 'many';
                if (n % 10 == 1 && n % 100 != 11) return 'one';
                return 'other';
              },
              '12': function _(n) {
                if (isBetween(n, 2, 4)) return 'few';
                if (n == 1) return 'one';
                return 'other';
              },
              '13': function _(n) {
                if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';
                if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return 'many';
                if (n == 1) return 'one';
                return 'other';
              },
              '14': function _(n) {
                if (isBetween(n % 100, 3, 4)) return 'few';
                if (n % 100 == 2) return 'two';
                if (n % 100 == 1) return 'one';
                return 'other';
              },
              '15': function _(n) {
                if (n === 0 || isBetween(n % 100, 2, 10)) return 'few';
                if (isBetween(n % 100, 11, 19)) return 'many';
                if (n == 1) return 'one';
                return 'other';
              },
              '16': function _(n) {
                if (n % 10 == 1 && n != 11) return 'one';
                return 'other';
              },
              '17': function _(n) {
                if (n == 3) return 'few';
                if (n === 0) return 'zero';
                if (n == 6) return 'many';
                if (n == 2) return 'two';
                if (n == 1) return 'one';
                return 'other';
              },
              '18': function _(n) {
                if (n === 0) return 'zero';
                if (isBetween(n, 0, 2) && n !== 0 && n != 2) return 'one';
                return 'other';
              },
              '19': function _(n) {
                if (isBetween(n, 2, 10)) return 'few';
                if (isBetween(n, 0, 1)) return 'one';
                return 'other';
              },
              '20': function _(n) {
                if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return 'few';
                if (n % 1000000 === 0 && n !== 0) return 'many';
                if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92])) return 'two';
                if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91])) return 'one';
                return 'other';
              },
              '21': function _(n) {
                if (n === 0) return 'zero';
                if (n == 1) return 'one';
                return 'other';
              },
              '22': function _(n) {
                if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return 'one';
                return 'other';
              },
              '23': function _(n) {
                if (isBetween(n % 10, 1, 2) || n % 20 === 0) return 'one';
                return 'other';
              },
              '24': function _(n) {
                if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return 'few';
                if (isIn(n, [2, 12])) return 'two';
                if (isIn(n, [1, 11])) return 'one';
                return 'other';
              }
            };
            var index = locales2rules[lang.replace(/-.*$/, '')];

            if (!(index in pluralRules)) {
              console.warn('plural form unknown for [' + lang + ']');
              return function () {
                return 'other';
              };
            }

            return pluralRules[index];
          }

          gMacros.plural = function (str, param, key, prop) {
            var n = parseFloat(param);
            if (isNaN(n)) return str;
            if (prop != gTextProp) return str;

            if (!gMacros._pluralRules) {
              gMacros._pluralRules = getPluralRules(gLanguage);
            }

            var index = '[' + gMacros._pluralRules(n) + ']';

            if (n === 0 && key + '[zero]' in gL10nData) {
              str = gL10nData[key + '[zero]'][prop];
            } else if (n == 1 && key + '[one]' in gL10nData) {
              str = gL10nData[key + '[one]'][prop];
            } else if (n == 2 && key + '[two]' in gL10nData) {
              str = gL10nData[key + '[two]'][prop];
            } else if (key + index in gL10nData) {
              str = gL10nData[key + index][prop];
            } else if (key + '[other]' in gL10nData) {
              str = gL10nData[key + '[other]'][prop];
            }

            return str;
          };

          function getL10nData(key, args, fallback) {
            var data = gL10nData[key];

            if (!data) {
              console.warn('#' + key + ' is undefined.');

              if (!fallback) {
                return null;
              }

              data = fallback;
            }

            var rv = {};

            for (var prop in data) {
              var str = data[prop];
              str = substIndexes(str, args, key, prop);
              str = substArguments(str, args, key);
              rv[prop] = str;
            }

            return rv;
          }

          function substIndexes(str, args, key, prop) {
            var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/;
            var reMatch = reIndex.exec(str);
            if (!reMatch || !reMatch.length) return str;
            var macroName = reMatch[1];
            var paramName = reMatch[2];
            var param;

            if (args && paramName in args) {
              param = args[paramName];
            } else if (paramName in gL10nData) {
              param = gL10nData[paramName];
            }

            if (macroName in gMacros) {
              var macro = gMacros[macroName];
              str = macro(str, param, key, prop);
            }

            return str;
          }

          function substArguments(str, args, key) {
            var reArgs = /\{\{\s*(.+?)\s*\}\}/g;
            return str.replace(reArgs, function (matched_text, arg) {
              if (args && arg in args) {
                return args[arg];
              }

              if (arg in gL10nData) {
                return gL10nData[arg];
              }

              console.log('argument {{' + arg + '}} for #' + key + ' is undefined.');
              return matched_text;
            });
          }

          function translateElement(element) {
            var l10n = getL10nAttributes(element);
            if (!l10n.id) return;
            var data = getL10nData(l10n.id, l10n.args);

            if (!data) {
              console.warn('#' + l10n.id + ' is undefined.');
              return;
            }

            if (data[gTextProp]) {
              if (getChildElementCount(element) === 0) {
                element[gTextProp] = data[gTextProp];
              } else {
                var children = element.childNodes;
                var found = false;

                for (var i = 0, l = children.length; i < l; i++) {
                  if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) {
                    if (found) {
                      children[i].nodeValue = '';
                    } else {
                      children[i].nodeValue = data[gTextProp];
                      found = true;
                    }
                  }
                }

                if (!found) {
                  var textNode = document.createTextNode(data[gTextProp]);
                  element.insertBefore(textNode, element.firstChild);
                }
              }

              delete data[gTextProp];
            }

            for (var k in data) {
              element[k] = data[k];
            }
          }

          function getChildElementCount(element) {
            if (element.children) {
              return element.children.length;
            }

            if (typeof element.childElementCount !== 'undefined') {
              return element.childElementCount;
            }

            var count = 0;

            for (var i = 0; i < element.childNodes.length; i++) {
              count += element.nodeType === 1 ? 1 : 0;
            }

            return count;
          }

          function translateFragment(element) {
            element = element || document.documentElement;
            var children = getTranslatableChildren(element);
            var elementCount = children.length;

            for (var i = 0; i < elementCount; i++) {
              translateElement(children[i]);
            }

            translateElement(element);
          }

          return {
            get: function get(key, args, fallbackString) {
              var index = key.lastIndexOf('.');
              var prop = gTextProp;

              if (index > 0) {
                prop = key.substring(index + 1);
                key = key.substring(0, index);
              }

              var fallback;

              if (fallbackString) {
                fallback = {};
                fallback[prop] = fallbackString;
              }

              var data = getL10nData(key, args, fallback);

              if (data && prop in data) {
                return data[prop];
              }

              return '{{' + key + '}}';
            },
            getData: function getData() {
              return gL10nData;
            },
            getText: function getText() {
              return gTextData;
            },
            getLanguage: function getLanguage() {
              return gLanguage;
            },
            setLanguage: function setLanguage(lang, callback) {
              loadLocale(lang, function () {
                if (callback) callback();
              });
            },
            getDirection: function getDirection() {
              var rtlList = ['ar', 'he', 'fa', 'ps', 'ur'];
              var shortCode = gLanguage.split('-', 1)[0];
              return rtlList.indexOf(shortCode) >= 0 ? 'rtl' : 'ltr';
            },
            translate: translateFragment,
            getReadyState: function getReadyState() {
              return gReadyState;
            },
            ready: function ready(callback) {
              if (!callback) {
                return;
              } else if (gReadyState == 'complete' || gReadyState == 'interactive') {
                window.setTimeout(function () {
                  callback();
                });
              } else if (document.addEventListener) {
                document.addEventListener('localized', function once() {
                  document.removeEventListener('localized', once);
                  callback();
                });
              }
            }
          };
        }(window, document);
        /***/

      },
      /* 13 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFFindController = exports.FindState = void 0;

        var _pdfjsLib = __w_pdfjs_require__(2);

        var _pdf_find_utils = __w_pdfjs_require__(14);

        var _ui_utils = __w_pdfjs_require__(5);

        var FindState = {
          FOUND: 0,
          NOT_FOUND: 1,
          WRAPPED: 2,
          PENDING: 3
        };
        exports.FindState = FindState;
        var FIND_TIMEOUT = 250;
        var MATCH_SCROLL_OFFSET_TOP = -50;
        var MATCH_SCROLL_OFFSET_LEFT = -400;
        var CHARACTERS_TO_NORMALIZE = {
          "\u2010": "-",
          "\u2018": "'",
          "\u2019": "'",
          "\u201A": "'",
          "\u201B": "'",
          "\u201C": '"',
          "\u201D": '"',
          "\u201E": '"',
          "\u201F": '"',
          "\xBC": "1/4",
          "\xBD": "1/2",
          "\xBE": "3/4"
        };
        var normalizationRegex = null;

        function normalize(text) {
          if (!normalizationRegex) {
            var replace = Object.keys(CHARACTERS_TO_NORMALIZE).join("");
            normalizationRegex = new RegExp("[".concat(replace, "]"), "g");
          }

          var diffs = null;
          var normalizedText = text.replace(normalizationRegex, function (ch, index) {
            var normalizedCh = CHARACTERS_TO_NORMALIZE[ch],
                diff = normalizedCh.length - ch.length;

            if (diff !== 0) {
              (diffs || (diffs = [])).push([index, diff]);
            }

            return normalizedCh;
          });
          return [normalizedText, diffs];
        }

        function getOriginalIndex(matchIndex) {
          var diffs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (!diffs) {
            return matchIndex;
          }

          var totalDiff = 0;

          var _iterator5 = _createForOfIteratorHelper(diffs),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var _step5$value = _slicedToArray(_step5.value, 2),
                  index = _step5$value[0],
                  diff = _step5$value[1];

              var currentIndex = index + totalDiff;

              if (currentIndex >= matchIndex) {
                break;
              }

              if (currentIndex + diff > matchIndex) {
                totalDiff += matchIndex - currentIndex;
                break;
              }

              totalDiff += diff;
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          return matchIndex - totalDiff;
        }

        var PDFFindController = /*#__PURE__*/function () {
          function PDFFindController(_ref10) {
            var linkService = _ref10.linkService,
                eventBus = _ref10.eventBus;

            _classCallCheck(this, PDFFindController);

            this._linkService = linkService;
            this._eventBus = eventBus;

            this._reset();

            eventBus._on("findbarclose", this._onFindBarClose.bind(this));
          }

          _createClass(PDFFindController, [{
            key: "highlightMatches",
            get: function get() {
              return this._highlightMatches;
            }
          }, {
            key: "pageMatches",
            get: function get() {
              return this._pageMatches;
            }
          }, {
            key: "pageMatchesLength",
            get: function get() {
              return this._pageMatchesLength;
            }
          }, {
            key: "selected",
            get: function get() {
              return this._selected;
            }
          }, {
            key: "state",
            get: function get() {
              return this._state;
            }
          }, {
            key: "setDocument",
            value: function setDocument(pdfDocument) {
              if (this._pdfDocument) {
                this._reset();
              }

              if (!pdfDocument) {
                return;
              }

              this._pdfDocument = pdfDocument;

              this._firstPageCapability.resolve();
            }
          }, {
            key: "executeCommand",
            value: function executeCommand(cmd, state) {
              var _this5 = this;

              if (!state) {
                return;
              }

              var pdfDocument = this._pdfDocument;

              if (this._state === null || this._shouldDirtyMatch(cmd, state)) {
                this._dirtyMatch = true;
              }

              this._state = state;

              if (cmd !== "findhighlightallchange") {
                this._updateUIState(FindState.PENDING);
              }

              this._firstPageCapability.promise.then(function () {
                if (!_this5._pdfDocument || pdfDocument && _this5._pdfDocument !== pdfDocument) {
                  return;
                }

                _this5._extractText();

                var findbarClosed = !_this5._highlightMatches;
                var pendingTimeout = !!_this5._findTimeout;

                if (_this5._findTimeout) {
                  clearTimeout(_this5._findTimeout);
                  _this5._findTimeout = null;
                }

                if (cmd === "find") {
                  _this5._findTimeout = setTimeout(function () {
                    _this5._nextMatch();

                    _this5._findTimeout = null;
                  }, FIND_TIMEOUT);
                } else if (_this5._dirtyMatch) {
                  _this5._nextMatch();
                } else if (cmd === "findagain") {
                  _this5._nextMatch();

                  if (findbarClosed && _this5._state.highlightAll) {
                    _this5._updateAllPages();
                  }
                } else if (cmd === "findhighlightallchange") {
                  if (pendingTimeout) {
                    _this5._nextMatch();
                  } else {
                    _this5._highlightMatches = true;
                  }

                  _this5._updateAllPages();
                } else {
                  _this5._nextMatch();
                }
              });
            }
          }, {
            key: "scrollMatchIntoView",
            value: function scrollMatchIntoView(_ref11) {
              var _ref11$element = _ref11.element,
                  element = _ref11$element === void 0 ? null : _ref11$element,
                  _ref11$selectedLeft = _ref11.selectedLeft,
                  selectedLeft = _ref11$selectedLeft === void 0 ? 0 : _ref11$selectedLeft,
                  _ref11$pageIndex = _ref11.pageIndex,
                  pageIndex = _ref11$pageIndex === void 0 ? -1 : _ref11$pageIndex,
                  _ref11$matchIndex = _ref11.matchIndex,
                  matchIndex = _ref11$matchIndex === void 0 ? -1 : _ref11$matchIndex;

              if (!this._scrollMatches || !element) {
                return;
              } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {
                return;
              } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {
                return;
              }

              this._scrollMatches = false;
              var spot = {
                top: MATCH_SCROLL_OFFSET_TOP,
                left: selectedLeft + MATCH_SCROLL_OFFSET_LEFT
              };
              (0, _ui_utils.scrollIntoView)(element, spot, true);
            }
          }, {
            key: "_reset",
            value: function _reset() {
              this._highlightMatches = false;
              this._scrollMatches = false;
              this._pdfDocument = null;
              this._pageMatches = [];
              this._pageMatchesLength = [];
              this._state = null;
              this._selected = {
                pageIdx: -1,
                matchIdx: -1
              };
              this._offset = {
                pageIdx: null,
                matchIdx: null,
                wrapped: false
              };
              this._extractTextPromises = [];
              this._pageContents = [];
              this._pageDiffs = [];
              this._matchesCountTotal = 0;
              this._pagesToSearch = null;
              this._pendingFindMatches = new Set();
              this._resumePageIdx = null;
              this._dirtyMatch = false;
              clearTimeout(this._findTimeout);
              this._findTimeout = null;
              this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
            }
          }, {
            key: "_query",
            get: function get() {
              if (this._state.query !== this._rawQuery) {
                this._rawQuery = this._state.query;

                var _normalize = normalize(this._state.query);

                var _normalize2 = _slicedToArray(_normalize, 1);

                this._normalizedQuery = _normalize2[0];
              }

              return this._normalizedQuery;
            }
          }, {
            key: "_shouldDirtyMatch",
            value: function _shouldDirtyMatch(cmd, state) {
              if (state.query !== this._state.query) {
                return true;
              }

              switch (cmd) {
                case "findagain":
                  var pageNumber = this._selected.pageIdx + 1;
                  var linkService = this._linkService;

                  if (pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !linkService.isPageVisible(pageNumber)) {
                    return true;
                  }

                  return false;

                case "findhighlightallchange":
                  return false;
              }

              return true;
            }
          }, {
            key: "_prepareMatches",
            value: function _prepareMatches(matchesWithLength, matches, matchesLength) {
              function isSubTerm(currentIndex) {
                var currentElem = matchesWithLength[currentIndex];
                var nextElem = matchesWithLength[currentIndex + 1];

                if (currentIndex < matchesWithLength.length - 1 && currentElem.match === nextElem.match) {
                  currentElem.skipped = true;
                  return true;
                }

                for (var i = currentIndex - 1; i >= 0; i--) {
                  var prevElem = matchesWithLength[i];

                  if (prevElem.skipped) {
                    continue;
                  }

                  if (prevElem.match + prevElem.matchLength < currentElem.match) {
                    break;
                  }

                  if (prevElem.match + prevElem.matchLength >= currentElem.match + currentElem.matchLength) {
                    currentElem.skipped = true;
                    return true;
                  }
                }

                return false;
              }

              matchesWithLength.sort(function (a, b) {
                return a.match === b.match ? a.matchLength - b.matchLength : a.match - b.match;
              });

              for (var i = 0, len = matchesWithLength.length; i < len; i++) {
                if (isSubTerm(i)) {
                  continue;
                }

                matches.push(matchesWithLength[i].match);
                matchesLength.push(matchesWithLength[i].matchLength);
              }
            }
          }, {
            key: "_isEntireWord",
            value: function _isEntireWord(content, startIdx, length) {
              if (startIdx > 0) {
                var first = content.charCodeAt(startIdx);
                var limit = content.charCodeAt(startIdx - 1);

                if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) {
                  return false;
                }
              }

              var endIdx = startIdx + length - 1;

              if (endIdx < content.length - 1) {
                var last = content.charCodeAt(endIdx);

                var _limit = content.charCodeAt(endIdx + 1);

                if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(_limit)) {
                  return false;
                }
              }

              return true;
            }
          }, {
            key: "_calculatePhraseMatch",
            value: function _calculatePhraseMatch(query, pageIndex, pageContent, pageDiffs, entireWord) {
              var matches = [],
                  matchesLength = [];
              var queryLen = query.length;
              var matchIdx = -queryLen;

              while (true) {
                matchIdx = pageContent.indexOf(query, matchIdx + queryLen);

                if (matchIdx === -1) {
                  break;
                }

                if (entireWord && !this._isEntireWord(pageContent, matchIdx, queryLen)) {
                  continue;
                }

                var originalMatchIdx = getOriginalIndex(matchIdx, pageDiffs),
                    matchEnd = matchIdx + queryLen - 1,
                    originalQueryLen = getOriginalIndex(matchEnd, pageDiffs) - originalMatchIdx + 1;
                matches.push(originalMatchIdx);
                matchesLength.push(originalQueryLen);
              }

              this._pageMatches[pageIndex] = matches;
              this._pageMatchesLength[pageIndex] = matchesLength;
            }
          }, {
            key: "_calculateWordMatch",
            value: function _calculateWordMatch(query, pageIndex, pageContent, pageDiffs, entireWord) {
              var matchesWithLength = [];
              var queryArray = query.match(/\S+/g);

              for (var i = 0, len = queryArray.length; i < len; i++) {
                var subquery = queryArray[i];
                var subqueryLen = subquery.length;
                var matchIdx = -subqueryLen;

                while (true) {
                  matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen);

                  if (matchIdx === -1) {
                    break;
                  }

                  if (entireWord && !this._isEntireWord(pageContent, matchIdx, subqueryLen)) {
                    continue;
                  }

                  var originalMatchIdx = getOriginalIndex(matchIdx, pageDiffs),
                      matchEnd = matchIdx + subqueryLen - 1,
                      originalQueryLen = getOriginalIndex(matchEnd, pageDiffs) - originalMatchIdx + 1;
                  matchesWithLength.push({
                    match: originalMatchIdx,
                    matchLength: originalQueryLen,
                    skipped: false
                  });
                }
              }

              this._pageMatchesLength[pageIndex] = [];
              this._pageMatches[pageIndex] = [];

              this._prepareMatches(matchesWithLength, this._pageMatches[pageIndex], this._pageMatchesLength[pageIndex]);
            }
          }, {
            key: "_calculateMatch",
            value: function _calculateMatch(pageIndex) {
              var pageContent = this._pageContents[pageIndex];
              var pageDiffs = this._pageDiffs[pageIndex];
              var query = this._query;
              var _this$_state = this._state,
                  caseSensitive = _this$_state.caseSensitive,
                  entireWord = _this$_state.entireWord,
                  phraseSearch = _this$_state.phraseSearch;

              if (query.length === 0) {
                return;
              }

              if (!caseSensitive) {
                pageContent = pageContent.toLowerCase();
                query = query.toLowerCase();
              }

              if (phraseSearch) {
                this._calculatePhraseMatch(query, pageIndex, pageContent, pageDiffs, entireWord);
              } else {
                this._calculateWordMatch(query, pageIndex, pageContent, pageDiffs, entireWord);
              }

              if (this._state.highlightAll) {
                this._updatePage(pageIndex);
              }

              if (this._resumePageIdx === pageIndex) {
                this._resumePageIdx = null;

                this._nextPageMatch();
              }

              var pageMatchesCount = this._pageMatches[pageIndex].length;

              if (pageMatchesCount > 0) {
                this._matchesCountTotal += pageMatchesCount;

                this._updateUIResultsCount();
              }
            }
          }, {
            key: "_extractText",
            value: function _extractText() {
              var _this6 = this;

              if (this._extractTextPromises.length > 0) {
                return;
              }

              var promise = Promise.resolve();

              var _loop = function _loop(i, ii) {
                var extractTextCapability = (0, _pdfjsLib.createPromiseCapability)();
                _this6._extractTextPromises[i] = extractTextCapability.promise;
                promise = promise.then(function () {
                  return _this6._pdfDocument.getPage(i + 1).then(function (pdfPage) {
                    return pdfPage.getTextContent({
                      normalizeWhitespace: true
                    });
                  }).then(function (textContent) {
                    var textItems = textContent.items;
                    var strBuf = [];

                    for (var j = 0, jj = textItems.length; j < jj; j++) {
                      strBuf.push(textItems[j].str);
                    }

                    var _normalize3 = normalize(strBuf.join(""));

                    var _normalize4 = _slicedToArray(_normalize3, 2);

                    _this6._pageContents[i] = _normalize4[0];
                    _this6._pageDiffs[i] = _normalize4[1];
                    extractTextCapability.resolve(i);
                  }, function (reason) {
                    console.error("Unable to get text content for page ".concat(i + 1), reason);
                    _this6._pageContents[i] = "";
                    _this6._pageDiffs[i] = null;
                    extractTextCapability.resolve(i);
                  });
                });
              };

              for (var i = 0, ii = this._linkService.pagesCount; i < ii; i++) {
                _loop(i, ii);
              }
            }
          }, {
            key: "_updatePage",
            value: function _updatePage(index) {
              if (this._scrollMatches && this._selected.pageIdx === index) {
                this._linkService.page = index + 1;
              }

              this._eventBus.dispatch("updatetextlayermatches", {
                source: this,
                pageIndex: index
              });
            }
          }, {
            key: "_updateAllPages",
            value: function _updateAllPages() {
              this._eventBus.dispatch("updatetextlayermatches", {
                source: this,
                pageIndex: -1
              });
            }
          }, {
            key: "_nextMatch",
            value: function _nextMatch() {
              var _this7 = this;

              var previous = this._state.findPrevious;
              var currentPageIndex = this._linkService.page - 1;
              var numPages = this._linkService.pagesCount;
              this._highlightMatches = true;

              if (this._dirtyMatch) {
                this._dirtyMatch = false;
                this._selected.pageIdx = this._selected.matchIdx = -1;
                this._offset.pageIdx = currentPageIndex;
                this._offset.matchIdx = null;
                this._offset.wrapped = false;
                this._resumePageIdx = null;
                this._pageMatches.length = 0;
                this._pageMatchesLength.length = 0;
                this._matchesCountTotal = 0;

                this._updateAllPages();

                for (var i = 0; i < numPages; i++) {
                  if (this._pendingFindMatches.has(i)) {
                    continue;
                  }

                  this._pendingFindMatches.add(i);

                  this._extractTextPromises[i].then(function (pageIdx) {
                    _this7._pendingFindMatches["delete"](pageIdx);

                    _this7._calculateMatch(pageIdx);
                  });
                }
              }

              if (this._query === "") {
                this._updateUIState(FindState.FOUND);

                return;
              }

              if (this._resumePageIdx) {
                return;
              }

              var offset = this._offset;
              this._pagesToSearch = numPages;

              if (offset.matchIdx !== null) {
                var numPageMatches = this._pageMatches[offset.pageIdx].length;

                if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {
                  offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;

                  this._updateMatch(true);

                  return;
                }

                this._advanceOffsetPage(previous);
              }

              this._nextPageMatch();
            }
          }, {
            key: "_matchesReady",
            value: function _matchesReady(matches) {
              var offset = this._offset;
              var numMatches = matches.length;
              var previous = this._state.findPrevious;

              if (numMatches) {
                offset.matchIdx = previous ? numMatches - 1 : 0;

                this._updateMatch(true);

                return true;
              }

              this._advanceOffsetPage(previous);

              if (offset.wrapped) {
                offset.matchIdx = null;

                if (this._pagesToSearch < 0) {
                  this._updateMatch(false);

                  return true;
                }
              }

              return false;
            }
          }, {
            key: "_nextPageMatch",
            value: function _nextPageMatch() {
              if (this._resumePageIdx !== null) {
                console.error("There can only be one pending page.");
              }

              var matches = null;

              do {
                var pageIdx = this._offset.pageIdx;
                matches = this._pageMatches[pageIdx];

                if (!matches) {
                  this._resumePageIdx = pageIdx;
                  break;
                }
              } while (!this._matchesReady(matches));
            }
          }, {
            key: "_advanceOffsetPage",
            value: function _advanceOffsetPage(previous) {
              var offset = this._offset;
              var numPages = this._linkService.pagesCount;
              offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;
              offset.matchIdx = null;
              this._pagesToSearch--;

              if (offset.pageIdx >= numPages || offset.pageIdx < 0) {
                offset.pageIdx = previous ? numPages - 1 : 0;
                offset.wrapped = true;
              }
            }
          }, {
            key: "_updateMatch",
            value: function _updateMatch() {
              var found = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              var state = FindState.NOT_FOUND;
              var wrapped = this._offset.wrapped;
              this._offset.wrapped = false;

              if (found) {
                var previousPage = this._selected.pageIdx;
                this._selected.pageIdx = this._offset.pageIdx;
                this._selected.matchIdx = this._offset.matchIdx;
                state = wrapped ? FindState.WRAPPED : FindState.FOUND;

                if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {
                  this._updatePage(previousPage);
                }
              }

              this._updateUIState(state, this._state.findPrevious);

              if (this._selected.pageIdx !== -1) {
                this._scrollMatches = true;

                this._updatePage(this._selected.pageIdx);
              }
            }
          }, {
            key: "_onFindBarClose",
            value: function _onFindBarClose(evt) {
              var _this8 = this;

              var pdfDocument = this._pdfDocument;

              this._firstPageCapability.promise.then(function () {
                if (!_this8._pdfDocument || pdfDocument && _this8._pdfDocument !== pdfDocument) {
                  return;
                }

                if (_this8._findTimeout) {
                  clearTimeout(_this8._findTimeout);
                  _this8._findTimeout = null;
                }

                if (_this8._resumePageIdx) {
                  _this8._resumePageIdx = null;
                  _this8._dirtyMatch = true;
                }

                _this8._updateUIState(FindState.FOUND);

                _this8._highlightMatches = false;

                _this8._updateAllPages();
              });
            }
          }, {
            key: "_requestMatchesCount",
            value: function _requestMatchesCount() {
              var _this$_selected = this._selected,
                  pageIdx = _this$_selected.pageIdx,
                  matchIdx = _this$_selected.matchIdx;
              var current = 0,
                  total = this._matchesCountTotal;

              if (matchIdx !== -1) {
                for (var i = 0; i < pageIdx; i++) {
                  var _this$_pageMatches$i;

                  current += ((_this$_pageMatches$i = this._pageMatches[i]) === null || _this$_pageMatches$i === void 0 ? void 0 : _this$_pageMatches$i.length) || 0;
                }

                current += matchIdx + 1;
              }

              if (current < 1 || current > total) {
                current = total = 0;
              }

              return {
                current: current,
                total: total
              };
            }
          }, {
            key: "_updateUIResultsCount",
            value: function _updateUIResultsCount() {
              this._eventBus.dispatch("updatefindmatchescount", {
                source: this,
                matchesCount: this._requestMatchesCount()
              });
            }
          }, {
            key: "_updateUIState",
            value: function _updateUIState(state, previous) {
              var _this$_state$query, _this$_state2;

              this._eventBus.dispatch("updatefindcontrolstate", {
                source: this,
                state: state,
                previous: previous,
                matchesCount: this._requestMatchesCount(),
                rawQuery: (_this$_state$query = (_this$_state2 = this._state) === null || _this$_state2 === void 0 ? void 0 : _this$_state2.query) !== null && _this$_state$query !== void 0 ? _this$_state$query : null
              });
            }
          }]);

          return PDFFindController;
        }();

        exports.PDFFindController = PDFFindController;
        /***/
      },
      /* 14 */

      /***/
      function (__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.getCharacterType = getCharacterType;
        exports.CharacterType = void 0;
        var CharacterType = {
          SPACE: 0,
          ALPHA_LETTER: 1,
          PUNCT: 2,
          HAN_LETTER: 3,
          KATAKANA_LETTER: 4,
          HIRAGANA_LETTER: 5,
          HALFWIDTH_KATAKANA_LETTER: 6,
          THAI_LETTER: 7
        };
        exports.CharacterType = CharacterType;

        function isAlphabeticalScript(charCode) {
          return charCode < 0x2e80;
        }

        function isAscii(charCode) {
          return (charCode & 0xff80) === 0;
        }

        function isAsciiAlpha(charCode) {
          return charCode >= 0x61 && charCode <= 0x7a || charCode >= 0x41 && charCode <= 0x5a;
        }

        function isAsciiDigit(charCode) {
          return charCode >= 0x30 && charCode <= 0x39;
        }

        function isAsciiSpace(charCode) {
          return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a;
        }

        function isHan(charCode) {
          return charCode >= 0x3400 && charCode <= 0x9fff || charCode >= 0xf900 && charCode <= 0xfaff;
        }

        function isKatakana(charCode) {
          return charCode >= 0x30a0 && charCode <= 0x30ff;
        }

        function isHiragana(charCode) {
          return charCode >= 0x3040 && charCode <= 0x309f;
        }

        function isHalfwidthKatakana(charCode) {
          return charCode >= 0xff60 && charCode <= 0xff9f;
        }

        function isThai(charCode) {
          return (charCode & 0xff80) === 0x0e00;
        }

        function getCharacterType(charCode) {
          if (isAlphabeticalScript(charCode)) {
            if (isAscii(charCode)) {
              if (isAsciiSpace(charCode)) {
                return CharacterType.SPACE;
              } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) {
                return CharacterType.ALPHA_LETTER;
              }

              return CharacterType.PUNCT;
            } else if (isThai(charCode)) {
              return CharacterType.THAI_LETTER;
            } else if (charCode === 0xa0) {
              return CharacterType.SPACE;
            }

            return CharacterType.ALPHA_LETTER;
          }

          if (isHan(charCode)) {
            return CharacterType.HAN_LETTER;
          } else if (isKatakana(charCode)) {
            return CharacterType.KATAKANA_LETTER;
          } else if (isHiragana(charCode)) {
            return CharacterType.HIRAGANA_LETTER;
          } else if (isHalfwidthKatakana(charCode)) {
            return CharacterType.HALFWIDTH_KATAKANA_LETTER;
          }

          return CharacterType.ALPHA_LETTER;
        }
        /***/

      },
      /* 15 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.isDestArraysEqual = isDestArraysEqual;
        exports.isDestHashesEqual = isDestHashesEqual;
        exports.PDFHistory = void 0;

        var _ui_utils = __w_pdfjs_require__(5);

        var HASH_CHANGE_TIMEOUT = 1000;
        var POSITION_UPDATED_THRESHOLD = 50;
        var UPDATE_VIEWAREA_TIMEOUT = 1000;

        function getCurrentHash() {
          return document.location.hash;
        }

        var PDFHistory = /*#__PURE__*/function () {
          function PDFHistory(_ref12) {
            var _this9 = this;

            var linkService = _ref12.linkService,
                eventBus = _ref12.eventBus;

            _classCallCheck(this, PDFHistory);

            this.linkService = linkService;
            this.eventBus = eventBus;
            this._initialized = false;
            this._fingerprint = "";
            this.reset();
            this._boundEvents = null;
            this._isViewerInPresentationMode = false;

            this.eventBus._on("presentationmodechanged", function (evt) {
              _this9._isViewerInPresentationMode = evt.state !== _ui_utils.PresentationModeState.NORMAL;
            });

            this.eventBus._on("pagesinit", function () {
              _this9._isPagesLoaded = false;

              _this9.eventBus._on("pagesloaded", function (evt) {
                _this9._isPagesLoaded = !!evt.pagesCount;
              }, {
                once: true
              });
            });
          }

          _createClass(PDFHistory, [{
            key: "initialize",
            value: function initialize(_ref13) {
              var fingerprint = _ref13.fingerprint,
                  _ref13$resetHistory = _ref13.resetHistory,
                  resetHistory = _ref13$resetHistory === void 0 ? false : _ref13$resetHistory,
                  _ref13$updateUrl = _ref13.updateUrl,
                  updateUrl = _ref13$updateUrl === void 0 ? false : _ref13$updateUrl;

              if (!fingerprint || typeof fingerprint !== "string") {
                console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.');
                return;
              }

              if (this._initialized) {
                this.reset();
              }

              var reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint;
              this._fingerprint = fingerprint;
              this._updateUrl = updateUrl === true;
              this._initialized = true;

              this._bindEvents();

              var state = window.history.state;
              this._popStateInProgress = false;
              this._blockHashChange = 0;
              this._currentHash = getCurrentHash();
              this._numPositionUpdates = 0;
              this._uid = this._maxUid = 0;
              this._destination = null;
              this._position = null;

              if (!this._isValidState(state, true) || resetHistory) {
                var _this$_parseCurrentHa = this._parseCurrentHash(true),
                    hash = _this$_parseCurrentHa.hash,
                    page = _this$_parseCurrentHa.page,
                    rotation = _this$_parseCurrentHa.rotation;

                if (!hash || reInitialized || resetHistory) {
                  this._pushOrReplaceState(null, true);

                  return;
                }

                this._pushOrReplaceState({
                  hash: hash,
                  page: page,
                  rotation: rotation
                }, true);

                return;
              }

              var destination = state.destination;

              this._updateInternalState(destination, state.uid, true);

              if (destination.rotation !== undefined) {
                this._initialRotation = destination.rotation;
              }

              if (destination.dest) {
                this._initialBookmark = JSON.stringify(destination.dest);
                this._destination.page = null;
              } else if (destination.hash) {
                this._initialBookmark = destination.hash;
              } else if (destination.page) {
                this._initialBookmark = "page=".concat(destination.page);
              }
            }
          }, {
            key: "reset",
            value: function reset() {
              if (this._initialized) {
                this._pageHide();

                this._initialized = false;

                this._unbindEvents();
              }

              if (this._updateViewareaTimeout) {
                clearTimeout(this._updateViewareaTimeout);
                this._updateViewareaTimeout = null;
              }

              this._initialBookmark = null;
              this._initialRotation = null;
            }
          }, {
            key: "push",
            value: function push(_ref14) {
              var _this10 = this;

              var _ref14$namedDest = _ref14.namedDest,
                  namedDest = _ref14$namedDest === void 0 ? null : _ref14$namedDest,
                  explicitDest = _ref14.explicitDest,
                  pageNumber = _ref14.pageNumber;

              if (!this._initialized) {
                return;
              }

              if (namedDest && typeof namedDest !== "string") {
                console.error("PDFHistory.push: " + "\"".concat(namedDest, "\" is not a valid namedDest parameter."));
                return;
              } else if (!Array.isArray(explicitDest)) {
                console.error("PDFHistory.push: " + "\"".concat(explicitDest, "\" is not a valid explicitDest parameter."));
                return;
              } else if (!this._isValidPage(pageNumber)) {
                if (pageNumber !== null || this._destination) {
                  console.error("PDFHistory.push: " + "\"".concat(pageNumber, "\" is not a valid pageNumber parameter."));
                  return;
                }
              }

              var hash = namedDest || JSON.stringify(explicitDest);

              if (!hash) {
                return;
              }

              var forceReplace = false;

              if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {
                if (this._destination.page) {
                  return;
                }

                forceReplace = true;
              }

              if (this._popStateInProgress && !forceReplace) {
                return;
              }

              this._pushOrReplaceState({
                dest: explicitDest,
                hash: hash,
                page: pageNumber,
                rotation: this.linkService.rotation
              }, forceReplace);

              if (!this._popStateInProgress) {
                this._popStateInProgress = true;
                Promise.resolve().then(function () {
                  _this10._popStateInProgress = false;
                });
              }
            }
          }, {
            key: "pushPage",
            value: function pushPage(pageNumber) {
              var _this$_destination,
                  _this11 = this;

              if (!this._initialized) {
                return;
              }

              if (!this._isValidPage(pageNumber)) {
                console.error("PDFHistory.pushPage: \"".concat(pageNumber, "\" is not a valid page number."));
                return;
              }

              if (((_this$_destination = this._destination) === null || _this$_destination === void 0 ? void 0 : _this$_destination.page) === pageNumber) {
                return;
              }

              if (this._popStateInProgress) {
                return;
              }

              this._pushOrReplaceState({
                dest: null,
                hash: "page=".concat(pageNumber),
                page: pageNumber,
                rotation: this.linkService.rotation
              });

              if (!this._popStateInProgress) {
                this._popStateInProgress = true;
                Promise.resolve().then(function () {
                  _this11._popStateInProgress = false;
                });
              }
            }
          }, {
            key: "pushCurrentPosition",
            value: function pushCurrentPosition() {
              if (!this._initialized || this._popStateInProgress) {
                return;
              }

              this._tryPushCurrentPosition();
            }
          }, {
            key: "back",
            value: function back() {
              if (!this._initialized || this._popStateInProgress) {
                return;
              }

              var state = window.history.state;

              if (this._isValidState(state) && state.uid > 0) {
                window.history.back();
              }
            }
          }, {
            key: "forward",
            value: function forward() {
              if (!this._initialized || this._popStateInProgress) {
                return;
              }

              var state = window.history.state;

              if (this._isValidState(state) && state.uid < this._maxUid) {
                window.history.forward();
              }
            }
          }, {
            key: "popStateInProgress",
            get: function get() {
              return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);
            }
          }, {
            key: "initialBookmark",
            get: function get() {
              return this._initialized ? this._initialBookmark : null;
            }
          }, {
            key: "initialRotation",
            get: function get() {
              return this._initialized ? this._initialRotation : null;
            }
          }, {
            key: "_pushOrReplaceState",
            value: function _pushOrReplaceState(destination) {
              var forceReplace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var shouldReplace = forceReplace || !this._destination;
              var newState = {
                fingerprint: this._fingerprint,
                uid: shouldReplace ? this._uid : this._uid + 1,
                destination: destination
              };

              this._updateInternalState(destination, newState.uid);

              var newUrl;

              if (this._updateUrl && destination !== null && destination !== void 0 && destination.hash) {
                var baseUrl = document.location.href.split("#")[0];

                if (!baseUrl.startsWith("file://")) {
                  newUrl = "".concat(baseUrl, "#").concat(destination.hash);
                }
              }

              if (shouldReplace) {
                window.history.replaceState(newState, "", newUrl);
              } else {
                window.history.pushState(newState, "", newUrl);
              }
            }
          }, {
            key: "_tryPushCurrentPosition",
            value: function _tryPushCurrentPosition() {
              var temporary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

              if (!this._position) {
                return;
              }

              var position = this._position;

              if (temporary) {
                position = Object.assign(Object.create(null), this._position);
                position.temporary = true;
              }

              if (!this._destination) {
                this._pushOrReplaceState(position);

                return;
              }

              if (this._destination.temporary) {
                this._pushOrReplaceState(position, true);

                return;
              }

              if (this._destination.hash === position.hash) {
                return;
              }

              if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {
                return;
              }

              var forceReplace = false;

              if (this._destination.page >= position.first && this._destination.page <= position.page) {
                if (this._destination.dest !== undefined || !this._destination.first) {
                  return;
                }

                forceReplace = true;
              }

              this._pushOrReplaceState(position, forceReplace);
            }
          }, {
            key: "_isValidPage",
            value: function _isValidPage(val) {
              return Number.isInteger(val) && val > 0 && val <= this.linkService.pagesCount;
            }
          }, {
            key: "_isValidState",
            value: function _isValidState(state) {
              var checkReload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

              if (!state) {
                return false;
              }

              if (state.fingerprint !== this._fingerprint) {
                if (checkReload) {
                  if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) {
                    return false;
                  }

                  var _performance$getEntri = performance.getEntriesByType("navigation"),
                      _performance$getEntri2 = _slicedToArray(_performance$getEntri, 1),
                      perfEntry = _performance$getEntri2[0];

                  if ((perfEntry === null || perfEntry === void 0 ? void 0 : perfEntry.type) !== "reload") {
                    return false;
                  }
                } else {
                  return false;
                }
              }

              if (!Number.isInteger(state.uid) || state.uid < 0) {
                return false;
              }

              if (state.destination === null || _typeof(state.destination) !== "object") {
                return false;
              }

              return true;
            }
          }, {
            key: "_updateInternalState",
            value: function _updateInternalState(destination, uid) {
              var removeTemporary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

              if (this._updateViewareaTimeout) {
                clearTimeout(this._updateViewareaTimeout);
                this._updateViewareaTimeout = null;
              }

              if (removeTemporary && destination !== null && destination !== void 0 && destination.temporary) {
                delete destination.temporary;
              }

              this._destination = destination;
              this._uid = uid;
              this._maxUid = Math.max(this._maxUid, uid);
              this._numPositionUpdates = 0;
            }
          }, {
            key: "_parseCurrentHash",
            value: function _parseCurrentHash() {
              var checkNameddest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
              var hash = unescape(getCurrentHash()).substring(1);
              var params = (0, _ui_utils.parseQueryString)(hash);
              var nameddest = params.get("nameddest") || "";
              var page = params.get("page") | 0;

              if (!this._isValidPage(page) || checkNameddest && nameddest.length > 0) {
                page = null;
              }

              return {
                hash: hash,
                page: page,
                rotation: this.linkService.rotation
              };
            }
          }, {
            key: "_updateViewarea",
            value: function _updateViewarea(_ref15) {
              var _this12 = this;

              var location = _ref15.location;

              if (this._updateViewareaTimeout) {
                clearTimeout(this._updateViewareaTimeout);
                this._updateViewareaTimeout = null;
              }

              this._position = {
                hash: this._isViewerInPresentationMode ? "page=".concat(location.pageNumber) : location.pdfOpenParams.substring(1),
                page: this.linkService.page,
                first: location.pageNumber,
                rotation: location.rotation
              };

              if (this._popStateInProgress) {
                return;
              }

              if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {
                this._numPositionUpdates++;
              }

              if (UPDATE_VIEWAREA_TIMEOUT > 0) {
                this._updateViewareaTimeout = setTimeout(function () {
                  if (!_this12._popStateInProgress) {
                    _this12._tryPushCurrentPosition(true);
                  }

                  _this12._updateViewareaTimeout = null;
                }, UPDATE_VIEWAREA_TIMEOUT);
              }
            }
          }, {
            key: "_popState",
            value: function _popState(_ref16) {
              var _this13 = this;

              var state = _ref16.state;
              var newHash = getCurrentHash(),
                  hashChanged = this._currentHash !== newHash;
              this._currentHash = newHash;

              if (!state) {
                this._uid++;

                var _this$_parseCurrentHa2 = this._parseCurrentHash(),
                    hash = _this$_parseCurrentHa2.hash,
                    page = _this$_parseCurrentHa2.page,
                    rotation = _this$_parseCurrentHa2.rotation;

                this._pushOrReplaceState({
                  hash: hash,
                  page: page,
                  rotation: rotation
                }, true);

                return;
              }

              if (!this._isValidState(state)) {
                return;
              }

              this._popStateInProgress = true;

              if (hashChanged) {
                this._blockHashChange++;
                (0, _ui_utils.waitOnEventOrTimeout)({
                  target: window,
                  name: "hashchange",
                  delay: HASH_CHANGE_TIMEOUT
                }).then(function () {
                  _this13._blockHashChange--;
                });
              }

              var destination = state.destination;

              this._updateInternalState(destination, state.uid, true);

              if ((0, _ui_utils.isValidRotation)(destination.rotation)) {
                this.linkService.rotation = destination.rotation;
              }

              if (destination.dest) {
                this.linkService.goToDestination(destination.dest);
              } else if (destination.hash) {
                this.linkService.setHash(destination.hash);
              } else if (destination.page) {
                this.linkService.page = destination.page;
              }

              Promise.resolve().then(function () {
                _this13._popStateInProgress = false;
              });
            }
          }, {
            key: "_pageHide",
            value: function _pageHide() {
              if (!this._destination || this._destination.temporary) {
                this._tryPushCurrentPosition();
              }
            }
          }, {
            key: "_bindEvents",
            value: function _bindEvents() {
              if (this._boundEvents) {
                return;
              }

              this._boundEvents = {
                updateViewarea: this._updateViewarea.bind(this),
                popState: this._popState.bind(this),
                pageHide: this._pageHide.bind(this)
              };

              this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea);

              window.addEventListener("popstate", this._boundEvents.popState);
              window.addEventListener("pagehide", this._boundEvents.pageHide);
            }
          }, {
            key: "_unbindEvents",
            value: function _unbindEvents() {
              if (!this._boundEvents) {
                return;
              }

              this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea);

              window.removeEventListener("popstate", this._boundEvents.popState);
              window.removeEventListener("pagehide", this._boundEvents.pageHide);
              this._boundEvents = null;
            }
          }]);

          return PDFHistory;
        }();

        exports.PDFHistory = PDFHistory;

        function isDestHashesEqual(destHash, pushHash) {
          if (typeof destHash !== "string" || typeof pushHash !== "string") {
            return false;
          }

          if (destHash === pushHash) {
            return true;
          }

          var nameddest = (0, _ui_utils.parseQueryString)(destHash).get("nameddest");

          if (nameddest === pushHash) {
            return true;
          }

          return false;
        }

        function isDestArraysEqual(firstDest, secondDest) {
          function isEntryEqual(first, second) {
            if (_typeof(first) !== _typeof(second)) {
              return false;
            }

            if (Array.isArray(first) || Array.isArray(second)) {
              return false;
            }

            if (first !== null && _typeof(first) === "object" && second !== null) {
              if (Object.keys(first).length !== Object.keys(second).length) {
                return false;
              }

              for (var key in first) {
                if (!isEntryEqual(first[key], second[key])) {
                  return false;
                }
              }

              return true;
            }

            return first === second || Number.isNaN(first) && Number.isNaN(second);
          }

          if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {
            return false;
          }

          if (firstDest.length !== secondDest.length) {
            return false;
          }

          for (var i = 0, ii = firstDest.length; i < ii; i++) {
            if (!isEntryEqual(firstDest[i], secondDest[i])) {
              return false;
            }
          }

          return true;
        }
        /***/

      },
      /* 16 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFPageView = void 0;

        var _pdfjsLib = __w_pdfjs_require__(2);

        var _ui_utils = __w_pdfjs_require__(5);

        var _app_options = __w_pdfjs_require__(10);

        var _l10n_utils = __w_pdfjs_require__(3);

        var _pdf_rendering_queue = __w_pdfjs_require__(17);

        var MAX_CANVAS_PIXELS = _app_options.compatibilityParams.maxCanvasPixels || 16777216;

        var PDFPageView = /*#__PURE__*/function () {
          function PDFPageView(options) {
            var _options$textLayerMod, _options$annotationMo, _options$textHighligh, _this$renderingQueue;

            _classCallCheck(this, PDFPageView);

            var container = options.container;
            var defaultViewport = options.defaultViewport;
            this.id = options.id;
            this.renderingId = "page" + this.id;
            this.pdfPage = null;
            this.pageLabel = null;
            this.rotation = 0;
            this.scale = options.scale || _ui_utils.DEFAULT_SCALE;
            this.viewport = defaultViewport;
            this.pdfPageRotate = defaultViewport.rotation;
            this._optionalContentConfigPromise = options.optionalContentConfigPromise || null;
            this.hasRestrictedScaling = false;
            this.textLayerMode = (_options$textLayerMod = options.textLayerMode) !== null && _options$textLayerMod !== void 0 ? _options$textLayerMod : _ui_utils.TextLayerMode.ENABLE;
            this._annotationMode = (_options$annotationMo = options.annotationMode) !== null && _options$annotationMo !== void 0 ? _options$annotationMo : _pdfjsLib.AnnotationMode.ENABLE_FORMS;
            this.imageResourcesPath = options.imageResourcesPath || "";
            this.useOnlyCssZoom = options.useOnlyCssZoom || false;
            this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;
            this.eventBus = options.eventBus;
            this.renderingQueue = options.renderingQueue;
            this.textLayerFactory = options.textLayerFactory;
            this.annotationLayerFactory = options.annotationLayerFactory;
            this.xfaLayerFactory = options.xfaLayerFactory;
            this.textHighlighter = (_options$textHighligh = options.textHighlighterFactory) === null || _options$textHighligh === void 0 ? void 0 : _options$textHighligh.createTextHighlighter(this.id - 1, this.eventBus);
            this.structTreeLayerFactory = options.structTreeLayerFactory;
            this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
            this.l10n = options.l10n || _l10n_utils.NullL10n;
            this.paintTask = null;
            this.paintedViewportMap = new WeakMap();
            this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
            this.resume = null;
            this._renderError = null;
            this._isStandalone = !((_this$renderingQueue = this.renderingQueue) !== null && _this$renderingQueue !== void 0 && _this$renderingQueue.hasViewer());
            this.annotationLayer = null;
            this.textLayer = null;
            this.zoomLayer = null;
            this.xfaLayer = null;
            this.structTreeLayer = null;
            var div = document.createElement("div");
            div.className = "page";
            div.style.width = Math.floor(this.viewport.width) + "px";
            div.style.height = Math.floor(this.viewport.height) + "px";
            div.setAttribute("data-page-number", this.id);
            div.setAttribute("role", "region");
            this.l10n.get("page_landmark", {
              page: this.id
            }).then(function (msg) {
              div.setAttribute("aria-label", msg);
            });
            this.div = div;
            container.appendChild(div);
          }

          _createClass(PDFPageView, [{
            key: "setPdfPage",
            value: function setPdfPage(pdfPage) {
              this.pdfPage = pdfPage;
              this.pdfPageRotate = pdfPage.rotate;
              var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
              this.viewport = pdfPage.getViewport({
                scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS,
                rotation: totalRotation
              });
              this.reset();
            }
          }, {
            key: "destroy",
            value: function destroy() {
              this.reset();

              if (this.pdfPage) {
                this.pdfPage.cleanup();
              }
            }
          }, {
            key: "_renderAnnotationLayer",
            value: function () {
              var _renderAnnotationLayer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
                var error;
                return _regeneratorRuntime().wrap(function _callee12$(_context12) {
                  while (1) {
                    switch (_context12.prev = _context12.next) {
                      case 0:
                        error = null;
                        _context12.prev = 1;
                        _context12.next = 4;
                        return this.annotationLayer.render(this.viewport, "display");

                      case 4:
                        _context12.next = 9;
                        break;

                      case 6:
                        _context12.prev = 6;
                        _context12.t0 = _context12["catch"](1);
                        error = _context12.t0;

                      case 9:
                        _context12.prev = 9;
                        this.eventBus.dispatch("annotationlayerrendered", {
                          source: this,
                          pageNumber: this.id,
                          error: error
                        });
                        return _context12.finish(9);

                      case 12:
                      case "end":
                        return _context12.stop();
                    }
                  }
                }, _callee12, this, [[1, 6, 9, 12]]);
              }));

              function _renderAnnotationLayer() {
                return _renderAnnotationLayer2.apply(this, arguments);
              }

              return _renderAnnotationLayer;
            }()
          }, {
            key: "_renderXfaLayer",
            value: function () {
              var _renderXfaLayer2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
                var error, result;
                return _regeneratorRuntime().wrap(function _callee13$(_context13) {
                  while (1) {
                    switch (_context13.prev = _context13.next) {
                      case 0:
                        error = null;
                        _context13.prev = 1;
                        _context13.next = 4;
                        return this.xfaLayer.render(this.viewport, "display");

                      case 4:
                        result = _context13.sent;

                        if (this.textHighlighter) {
                          this._buildXfaTextContentItems(result.textDivs);
                        }

                        _context13.next = 11;
                        break;

                      case 8:
                        _context13.prev = 8;
                        _context13.t0 = _context13["catch"](1);
                        error = _context13.t0;

                      case 11:
                        _context13.prev = 11;
                        this.eventBus.dispatch("xfalayerrendered", {
                          source: this,
                          pageNumber: this.id,
                          error: error
                        });
                        return _context13.finish(11);

                      case 14:
                      case "end":
                        return _context13.stop();
                    }
                  }
                }, _callee13, this, [[1, 8, 11, 14]]);
              }));

              function _renderXfaLayer() {
                return _renderXfaLayer2.apply(this, arguments);
              }

              return _renderXfaLayer;
            }()
          }, {
            key: "_buildXfaTextContentItems",
            value: function () {
              var _buildXfaTextContentItems2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(textDivs) {
                var text, items, _iterator6, _step6, item;

                return _regeneratorRuntime().wrap(function _callee14$(_context14) {
                  while (1) {
                    switch (_context14.prev = _context14.next) {
                      case 0:
                        _context14.next = 2;
                        return this.pdfPage.getTextContent();

                      case 2:
                        text = _context14.sent;
                        items = [];
                        _iterator6 = _createForOfIteratorHelper(text.items);

                        try {
                          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                            item = _step6.value;
                            items.push(item.str);
                          }
                        } catch (err) {
                          _iterator6.e(err);
                        } finally {
                          _iterator6.f();
                        }

                        this.textHighlighter.setTextMapping(textDivs, items);
                        this.textHighlighter.enable();

                      case 8:
                      case "end":
                        return _context14.stop();
                    }
                  }
                }, _callee14, this);
              }));

              function _buildXfaTextContentItems(_x6) {
                return _buildXfaTextContentItems2.apply(this, arguments);
              }

              return _buildXfaTextContentItems;
            }()
          }, {
            key: "_resetZoomLayer",
            value: function _resetZoomLayer() {
              var removeFromDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

              if (!this.zoomLayer) {
                return;
              }

              var zoomLayerCanvas = this.zoomLayer.firstChild;
              this.paintedViewportMap["delete"](zoomLayerCanvas);
              zoomLayerCanvas.width = 0;
              zoomLayerCanvas.height = 0;

              if (removeFromDOM) {
                this.zoomLayer.remove();
              }

              this.zoomLayer = null;
            }
          }, {
            key: "reset",
            value: function reset() {
              var _this$annotationLayer,
                  _this$xfaLayer,
                  _this14 = this;

              var _ref17 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  _ref17$keepZoomLayer = _ref17.keepZoomLayer,
                  keepZoomLayer = _ref17$keepZoomLayer === void 0 ? false : _ref17$keepZoomLayer,
                  _ref17$keepAnnotation = _ref17.keepAnnotationLayer,
                  keepAnnotationLayer = _ref17$keepAnnotation === void 0 ? false : _ref17$keepAnnotation,
                  _ref17$keepXfaLayer = _ref17.keepXfaLayer,
                  keepXfaLayer = _ref17$keepXfaLayer === void 0 ? false : _ref17$keepXfaLayer;

              this.cancelRendering({
                keepAnnotationLayer: keepAnnotationLayer,
                keepXfaLayer: keepXfaLayer
              });
              this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;
              var div = this.div;
              div.style.width = Math.floor(this.viewport.width) + "px";
              div.style.height = Math.floor(this.viewport.height) + "px";
              var childNodes = div.childNodes,
                  zoomLayerNode = keepZoomLayer && this.zoomLayer || null,
                  annotationLayerNode = keepAnnotationLayer && ((_this$annotationLayer = this.annotationLayer) === null || _this$annotationLayer === void 0 ? void 0 : _this$annotationLayer.div) || null,
                  xfaLayerNode = keepXfaLayer && ((_this$xfaLayer = this.xfaLayer) === null || _this$xfaLayer === void 0 ? void 0 : _this$xfaLayer.div) || null;

              for (var i = childNodes.length - 1; i >= 0; i--) {
                var node = childNodes[i];

                switch (node) {
                  case zoomLayerNode:
                  case annotationLayerNode:
                  case xfaLayerNode:
                    continue;
                }

                div.removeChild(node);
              }

              div.removeAttribute("data-loaded");

              if (annotationLayerNode) {
                this.annotationLayer.hide();
              }

              if (xfaLayerNode) {
                this.xfaLayer.hide();
              }

              if (!zoomLayerNode) {
                if (this.canvas) {
                  this.paintedViewportMap["delete"](this.canvas);
                  this.canvas.width = 0;
                  this.canvas.height = 0;
                  delete this.canvas;
                }

                this._resetZoomLayer();
              }

              if (this.svg) {
                this.paintedViewportMap["delete"](this.svg);
                delete this.svg;
              }

              this.loadingIconDiv = document.createElement("div");
              this.loadingIconDiv.className = "loadingIcon";
              this.loadingIconDiv.setAttribute("role", "img");
              this.l10n.get("loading").then(function (msg) {
                var _this14$loadingIconDi;

                (_this14$loadingIconDi = _this14.loadingIconDiv) === null || _this14$loadingIconDi === void 0 ? void 0 : _this14$loadingIconDi.setAttribute("aria-label", msg);
              });
              div.appendChild(this.loadingIconDiv);
            }
          }, {
            key: "update",
            value: function update(_ref18) {
              var _ref18$scale = _ref18.scale,
                  scale = _ref18$scale === void 0 ? 0 : _ref18$scale,
                  _ref18$rotation = _ref18.rotation,
                  rotation = _ref18$rotation === void 0 ? null : _ref18$rotation,
                  _ref18$optionalConten = _ref18.optionalContentConfigPromise,
                  optionalContentConfigPromise = _ref18$optionalConten === void 0 ? null : _ref18$optionalConten;

              if (_typeof(arguments[0]) !== "object") {
                console.error("PDFPageView.update called with separate parameters, please use an object instead.");
                this.update({
                  scale: arguments[0],
                  rotation: arguments[1],
                  optionalContentConfigPromise: arguments[2]
                });
                return;
              }

              this.scale = scale || this.scale;

              if (typeof rotation === "number") {
                this.rotation = rotation;
              }

              if (optionalContentConfigPromise instanceof Promise) {
                this._optionalContentConfigPromise = optionalContentConfigPromise;
              }

              if (this._isStandalone) {
                var doc = document.documentElement;
                doc.style.setProperty("--zoom-factor", this.scale);
              }

              var totalRotation = (this.rotation + this.pdfPageRotate) % 360;
              this.viewport = this.viewport.clone({
                scale: this.scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS,
                rotation: totalRotation
              });

              if (this.svg) {
                this.cssTransform({
                  target: this.svg,
                  redrawAnnotationLayer: true,
                  redrawXfaLayer: true
                });
                this.eventBus.dispatch("pagerendered", {
                  source: this,
                  pageNumber: this.id,
                  cssTransform: true,
                  timestamp: performance.now(),
                  error: this._renderError
                });
                return;
              }

              var isScalingRestricted = false;

              if (this.canvas && this.maxCanvasPixels > 0) {
                var outputScale = this.outputScale;

                if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) {
                  isScalingRestricted = true;
                }
              }

              if (this.canvas) {
                if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {
                  this.cssTransform({
                    target: this.canvas,
                    redrawAnnotationLayer: true,
                    redrawXfaLayer: true
                  });
                  this.eventBus.dispatch("pagerendered", {
                    source: this,
                    pageNumber: this.id,
                    cssTransform: true,
                    timestamp: performance.now(),
                    error: this._renderError
                  });
                  return;
                }

                if (!this.zoomLayer && !this.canvas.hidden) {
                  this.zoomLayer = this.canvas.parentNode;
                  this.zoomLayer.style.position = "absolute";
                }
              }

              if (this.zoomLayer) {
                this.cssTransform({
                  target: this.zoomLayer.firstChild
                });
              }

              this.reset({
                keepZoomLayer: true,
                keepAnnotationLayer: true,
                keepXfaLayer: true
              });
            }
          }, {
            key: "cancelRendering",
            value: function cancelRendering() {
              var _ref19 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
                  _ref19$keepAnnotation = _ref19.keepAnnotationLayer,
                  keepAnnotationLayer = _ref19$keepAnnotation === void 0 ? false : _ref19$keepAnnotation,
                  _ref19$keepXfaLayer = _ref19.keepXfaLayer,
                  keepXfaLayer = _ref19$keepXfaLayer === void 0 ? false : _ref19$keepXfaLayer;

              if (this.paintTask) {
                this.paintTask.cancel();
                this.paintTask = null;
              }

              this.resume = null;

              if (this.textLayer) {
                this.textLayer.cancel();
                this.textLayer = null;
              }

              if (this.annotationLayer && (!keepAnnotationLayer || !this.annotationLayer.div)) {
                this.annotationLayer.cancel();
                this.annotationLayer = null;
              }

              if (this.xfaLayer && (!keepXfaLayer || !this.xfaLayer.div)) {
                var _this$textHighlighter;

                this.xfaLayer.cancel();
                this.xfaLayer = null;
                (_this$textHighlighter = this.textHighlighter) === null || _this$textHighlighter === void 0 ? void 0 : _this$textHighlighter.disable();
              }

              if (this._onTextLayerRendered) {
                this.eventBus._off("textlayerrendered", this._onTextLayerRendered);

                this._onTextLayerRendered = null;
              }
            }
          }, {
            key: "cssTransform",
            value: function cssTransform(_ref20) {
              var target = _ref20.target,
                  _ref20$redrawAnnotati = _ref20.redrawAnnotationLayer,
                  redrawAnnotationLayer = _ref20$redrawAnnotati === void 0 ? false : _ref20$redrawAnnotati,
                  _ref20$redrawXfaLayer = _ref20.redrawXfaLayer,
                  redrawXfaLayer = _ref20$redrawXfaLayer === void 0 ? false : _ref20$redrawXfaLayer;
              var width = this.viewport.width;
              var height = this.viewport.height;
              var div = this.div;
              target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + "px";
              target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + "px";
              var relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;
              var absRotation = Math.abs(relativeRotation);
              var scaleX = 1,
                  scaleY = 1;

              if (absRotation === 90 || absRotation === 270) {
                scaleX = height / width;
                scaleY = width / height;
              }

              target.style.transform = "rotate(".concat(relativeRotation, "deg) scale(").concat(scaleX, ", ").concat(scaleY, ")");

              if (this.textLayer) {
                var textLayerViewport = this.textLayer.viewport;
                var textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;
                var textAbsRotation = Math.abs(textRelativeRotation);
                var scale = width / textLayerViewport.width;

                if (textAbsRotation === 90 || textAbsRotation === 270) {
                  scale = width / textLayerViewport.height;
                }

                var textLayerDiv = this.textLayer.textLayerDiv;
                var transX, transY;

                switch (textAbsRotation) {
                  case 0:
                    transX = transY = 0;
                    break;

                  case 90:
                    transX = 0;
                    transY = "-" + textLayerDiv.style.height;
                    break;

                  case 180:
                    transX = "-" + textLayerDiv.style.width;
                    transY = "-" + textLayerDiv.style.height;
                    break;

                  case 270:
                    transX = "-" + textLayerDiv.style.width;
                    transY = 0;
                    break;

                  default:
                    console.error("Bad rotation value.");
                    break;
                }

                textLayerDiv.style.transform = "rotate(".concat(textAbsRotation, "deg) ") + "scale(".concat(scale, ") ") + "translate(".concat(transX, ", ").concat(transY, ")");
                textLayerDiv.style.transformOrigin = "0% 0%";
              }

              if (redrawAnnotationLayer && this.annotationLayer) {
                this._renderAnnotationLayer();
              }

              if (redrawXfaLayer && this.xfaLayer) {
                this._renderXfaLayer();
              }
            }
          }, {
            key: "width",
            get: function get() {
              return this.viewport.width;
            }
          }, {
            key: "height",
            get: function get() {
              return this.viewport.height;
            }
          }, {
            key: "getPagePoint",
            value: function getPagePoint(x, y) {
              return this.viewport.convertToPdfPoint(x, y);
            }
          }, {
            key: "draw",
            value: function draw() {
              var _this$annotationLayer2,
                  _this$xfaLayer2,
                  _this15 = this;

              if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {
                console.error("Must be in new state before drawing");
                this.reset();
              }

              var div = this.div,
                  pdfPage = this.pdfPage;

              if (!pdfPage) {
                this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

                if (this.loadingIconDiv) {
                  div.removeChild(this.loadingIconDiv);
                  delete this.loadingIconDiv;
                }

                return Promise.reject(new Error("pdfPage is not loaded"));
              }

              this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
              var canvasWrapper = document.createElement("div");
              canvasWrapper.style.width = div.style.width;
              canvasWrapper.style.height = div.style.height;
              canvasWrapper.classList.add("canvasWrapper");

              if ((_this$annotationLayer2 = this.annotationLayer) !== null && _this$annotationLayer2 !== void 0 && _this$annotationLayer2.div) {
                div.insertBefore(canvasWrapper, this.annotationLayer.div);
              } else {
                div.appendChild(canvasWrapper);
              }

              var textLayer = null;

              if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && this.textLayerFactory) {
                var _this$annotationLayer3;

                var textLayerDiv = document.createElement("div");
                textLayerDiv.className = "textLayer";
                textLayerDiv.style.width = canvasWrapper.style.width;
                textLayerDiv.style.height = canvasWrapper.style.height;

                if ((_this$annotationLayer3 = this.annotationLayer) !== null && _this$annotationLayer3 !== void 0 && _this$annotationLayer3.div) {
                  div.insertBefore(textLayerDiv, this.annotationLayer.div);
                } else {
                  div.appendChild(textLayerDiv);
                }

                textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === _ui_utils.TextLayerMode.ENABLE_ENHANCE, this.eventBus, this.textHighlighter);
              }

              this.textLayer = textLayer;

              if ((_this$xfaLayer2 = this.xfaLayer) !== null && _this$xfaLayer2 !== void 0 && _this$xfaLayer2.div) {
                div.appendChild(this.xfaLayer.div);
              }

              var renderContinueCallback = null;

              if (this.renderingQueue) {
                renderContinueCallback = function renderContinueCallback(cont) {
                  if (!_this15.renderingQueue.isHighestPriority(_this15)) {
                    _this15.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;

                    _this15.resume = function () {
                      _this15.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;
                      cont();
                    };

                    return;
                  }

                  cont();
                };
              }

              var finishPaintTask = /*#__PURE__*/function () {
                var _ref21 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
                  var error,
                      _args15 = arguments;
                  return _regeneratorRuntime().wrap(function _callee15$(_context15) {
                    while (1) {
                      switch (_context15.prev = _context15.next) {
                        case 0:
                          error = _args15.length > 0 && _args15[0] !== undefined ? _args15[0] : null;

                          if (paintTask === _this15.paintTask) {
                            _this15.paintTask = null;
                          }

                          if (!(error instanceof _pdfjsLib.RenderingCancelledException)) {
                            _context15.next = 5;
                            break;
                          }

                          _this15._renderError = null;
                          return _context15.abrupt("return");

                        case 5:
                          _this15._renderError = error;
                          _this15.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;

                          if (_this15.loadingIconDiv) {
                            div.removeChild(_this15.loadingIconDiv);
                            delete _this15.loadingIconDiv;
                          }

                          _this15._resetZoomLayer(true);

                          _this15.eventBus.dispatch("pagerendered", {
                            source: _this15,
                            pageNumber: _this15.id,
                            cssTransform: false,
                            timestamp: performance.now(),
                            error: _this15._renderError
                          });

                          if (!error) {
                            _context15.next = 12;
                            break;
                          }

                          throw error;

                        case 12:
                        case "end":
                          return _context15.stop();
                      }
                    }
                  }, _callee15);
                }));

                return function finishPaintTask() {
                  return _ref21.apply(this, arguments);
                };
              }();

              var paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);
              paintTask.onRenderContinue = renderContinueCallback;
              this.paintTask = paintTask;
              var resultPromise = paintTask.promise.then(function () {
                return finishPaintTask(null).then(function () {
                  if (textLayer) {
                    var readableStream = pdfPage.streamTextContent({
                      normalizeWhitespace: true,
                      includeMarkedContent: true
                    });
                    textLayer.setTextContentStream(readableStream);
                    textLayer.render();
                  }
                });
              }, function (reason) {
                return finishPaintTask(reason);
              });

              if (this._annotationMode !== _pdfjsLib.AnnotationMode.DISABLE && this.annotationLayerFactory) {
                if (!this.annotationLayer) {
                  this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, null, this.imageResourcesPath, this._annotationMode === _pdfjsLib.AnnotationMode.ENABLE_FORMS, this.l10n, null, null, null, null);
                }

                this._renderAnnotationLayer();
              }

              if (this.xfaLayerFactory) {
                if (!this.xfaLayer) {
                  this.xfaLayer = this.xfaLayerFactory.createXfaLayerBuilder(div, pdfPage, null);
                }

                this._renderXfaLayer();
              }

              if (this.structTreeLayerFactory && this.textLayer && this.canvas) {
                this._onTextLayerRendered = function (event) {
                  if (event.pageNumber !== _this15.id) {
                    return;
                  }

                  _this15.eventBus._off("textlayerrendered", _this15._onTextLayerRendered);

                  _this15._onTextLayerRendered = null;

                  if (!_this15.canvas) {
                    return;
                  }

                  _this15.pdfPage.getStructTree().then(function (tree) {
                    if (!tree) {
                      return;
                    }

                    if (!_this15.canvas) {
                      return;
                    }

                    var treeDom = _this15.structTreeLayer.render(tree);

                    treeDom.classList.add("structTree");

                    _this15.canvas.appendChild(treeDom);
                  });
                };

                this.eventBus._on("textlayerrendered", this._onTextLayerRendered);

                this.structTreeLayer = this.structTreeLayerFactory.createStructTreeLayerBuilder(pdfPage);
              }

              div.setAttribute("data-loaded", true);
              this.eventBus.dispatch("pagerender", {
                source: this,
                pageNumber: this.id
              });
              return resultPromise;
            }
          }, {
            key: "paintOnCanvas",
            value: function paintOnCanvas(canvasWrapper) {
              var renderCapability = (0, _pdfjsLib.createPromiseCapability)();
              var result = {
                promise: renderCapability.promise,
                onRenderContinue: function onRenderContinue(cont) {
                  cont();
                },
                cancel: function cancel() {
                  renderTask.cancel();
                }
              };
              var viewport = this.viewport;
              var canvas = document.createElement("canvas");
              canvas.hidden = true;
              var isCanvasHidden = true;

              var showCanvas = function showCanvas() {
                if (isCanvasHidden) {
                  canvas.hidden = false;
                  isCanvasHidden = false;
                }
              };

              canvasWrapper.appendChild(canvas);
              this.canvas = canvas;
              canvas.mozOpaque = true;
              var ctx = canvas.getContext("2d", {
                alpha: false
              });
              var outputScale = (0, _ui_utils.getOutputScale)(ctx);
              this.outputScale = outputScale;

              if (this.useOnlyCssZoom) {
                var actualSizeViewport = viewport.clone({
                  scale: _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS
                });
                outputScale.sx *= actualSizeViewport.width / viewport.width;
                outputScale.sy *= actualSizeViewport.height / viewport.height;
                outputScale.scaled = true;
              }

              if (this.maxCanvasPixels > 0) {
                var pixelsInViewport = viewport.width * viewport.height;
                var maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);

                if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
                  outputScale.sx = maxScale;
                  outputScale.sy = maxScale;
                  outputScale.scaled = true;
                  this.hasRestrictedScaling = true;
                } else {
                  this.hasRestrictedScaling = false;
                }
              }

              var sfx = (0, _ui_utils.approximateFraction)(outputScale.sx);
              var sfy = (0, _ui_utils.approximateFraction)(outputScale.sy);
              canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]);
              canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]);
              canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + "px";
              canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + "px";
              this.paintedViewportMap.set(canvas, viewport);
              var transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];
              var renderContext = {
                canvasContext: ctx,
                transform: transform,
                viewport: this.viewport,
                annotationMode: this._annotationMode,
                optionalContentConfigPromise: this._optionalContentConfigPromise
              };
              var renderTask = this.pdfPage.render(renderContext);

              renderTask.onContinue = function (cont) {
                showCanvas();

                if (result.onRenderContinue) {
                  result.onRenderContinue(cont);
                } else {
                  cont();
                }
              };

              renderTask.promise.then(function () {
                showCanvas();
                renderCapability.resolve(undefined);
              }, function (error) {
                showCanvas();
                renderCapability.reject(error);
              });
              return result;
            }
          }, {
            key: "paintOnSvg",
            value: function paintOnSvg(wrapper) {
              var _this16 = this;

              var cancelled = false;

              var ensureNotCancelled = function ensureNotCancelled() {
                if (cancelled) {
                  throw new _pdfjsLib.RenderingCancelledException("Rendering cancelled, page ".concat(_this16.id), "svg");
                }
              };

              var pdfPage = this.pdfPage;
              var actualSizeViewport = this.viewport.clone({
                scale: _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS
              });
              var promise = pdfPage.getOperatorList({
                annotationMode: this._annotationMode
              }).then(function (opList) {
                ensureNotCancelled();
                var svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs, _app_options.compatibilityParams.disableCreateObjectURL);
                return svgGfx.getSVG(opList, actualSizeViewport).then(function (svg) {
                  ensureNotCancelled();
                  _this16.svg = svg;

                  _this16.paintedViewportMap.set(svg, actualSizeViewport);

                  svg.style.width = wrapper.style.width;
                  svg.style.height = wrapper.style.height;
                  _this16.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;
                  wrapper.appendChild(svg);
                });
              });
              return {
                promise: promise,
                onRenderContinue: function onRenderContinue(cont) {
                  cont();
                },
                cancel: function cancel() {
                  cancelled = true;
                }
              };
            }
          }, {
            key: "setPageLabel",
            value: function setPageLabel(label) {
              this.pageLabel = typeof label === "string" ? label : null;

              if (this.pageLabel !== null) {
                this.div.setAttribute("data-page-label", this.pageLabel);
              } else {
                this.div.removeAttribute("data-page-label");
              }
            }
          }]);

          return PDFPageView;
        }();

        exports.PDFPageView = PDFPageView;
        /***/
      },
      /* 17 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.RenderingStates = exports.PDFRenderingQueue = void 0;

        var _pdfjsLib = __w_pdfjs_require__(2);

        var CLEANUP_TIMEOUT = 30000;
        var RenderingStates = {
          INITIAL: 0,
          RUNNING: 1,
          PAUSED: 2,
          FINISHED: 3
        };
        exports.RenderingStates = RenderingStates;

        var PDFRenderingQueue = /*#__PURE__*/function () {
          function PDFRenderingQueue() {
            _classCallCheck(this, PDFRenderingQueue);

            this.pdfViewer = null;
            this.pdfThumbnailViewer = null;
            this.onIdle = null;
            this.highestPriorityPage = null;
            this.idleTimeout = null;
            this.printing = false;
            this.isThumbnailViewEnabled = false;
          }

          _createClass(PDFRenderingQueue, [{
            key: "setViewer",
            value: function setViewer(pdfViewer) {
              this.pdfViewer = pdfViewer;
            }
          }, {
            key: "setThumbnailViewer",
            value: function setThumbnailViewer(pdfThumbnailViewer) {
              this.pdfThumbnailViewer = pdfThumbnailViewer;
            }
          }, {
            key: "isHighestPriority",
            value: function isHighestPriority(view) {
              return this.highestPriorityPage === view.renderingId;
            }
          }, {
            key: "hasViewer",
            value: function hasViewer() {
              return !!this.pdfViewer;
            }
          }, {
            key: "renderHighestPriority",
            value: function renderHighestPriority(currentlyVisiblePages) {
              if (this.idleTimeout) {
                clearTimeout(this.idleTimeout);
                this.idleTimeout = null;
              }

              if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
                return;
              }

              if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {
                if (this.pdfThumbnailViewer.forceRendering()) {
                  return;
                }
              }

              if (this.printing) {
                return;
              }

              if (this.onIdle) {
                this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);
              }
            }
          }, {
            key: "getHighestPriority",
            value: function getHighestPriority(visible, views, scrolledDown) {
              var preRenderExtra = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
              var visibleViews = visible.views;
              var numVisible = visibleViews.length;

              if (numVisible === 0) {
                return null;
              }

              for (var i = 0; i < numVisible; ++i) {
                var view = visibleViews[i].view;

                if (!this.isViewFinished(view)) {
                  return view;
                }
              }

              var preRenderIndex = scrolledDown ? visible.last.id : visible.first.id - 2;
              var preRenderView = views[preRenderIndex];

              if (preRenderView && !this.isViewFinished(preRenderView)) {
                return preRenderView;
              }

              if (preRenderExtra) {
                preRenderIndex += scrolledDown ? 1 : -1;
                preRenderView = views[preRenderIndex];

                if (preRenderView && !this.isViewFinished(preRenderView)) {
                  return preRenderView;
                }
              }

              return null;
            }
          }, {
            key: "isViewFinished",
            value: function isViewFinished(view) {
              return view.renderingState === RenderingStates.FINISHED;
            }
          }, {
            key: "renderView",
            value: function renderView(view) {
              var _this17 = this;

              switch (view.renderingState) {
                case RenderingStates.FINISHED:
                  return false;

                case RenderingStates.PAUSED:
                  this.highestPriorityPage = view.renderingId;
                  view.resume();
                  break;

                case RenderingStates.RUNNING:
                  this.highestPriorityPage = view.renderingId;
                  break;

                case RenderingStates.INITIAL:
                  this.highestPriorityPage = view.renderingId;
                  view.draw()["finally"](function () {
                    _this17.renderHighestPriority();
                  })["catch"](function (reason) {
                    if (reason instanceof _pdfjsLib.RenderingCancelledException) {
                      return;
                    }

                    console.error("renderView: \"".concat(reason, "\""));
                  });
                  break;
              }

              return true;
            }
          }]);

          return PDFRenderingQueue;
        }();

        exports.PDFRenderingQueue = PDFRenderingQueue;
        /***/
      },
      /* 18 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFScriptingManager = void 0;

        var _pdfjsLib = __w_pdfjs_require__(2);

        var _ui_utils = __w_pdfjs_require__(5);

        var _pdf_rendering_queue = __w_pdfjs_require__(17);

        var PDFScriptingManager = /*#__PURE__*/function () {
          function PDFScriptingManager(_ref22) {
            var _this18 = this;

            var eventBus = _ref22.eventBus,
                _ref22$sandboxBundleS = _ref22.sandboxBundleSrc,
                sandboxBundleSrc = _ref22$sandboxBundleS === void 0 ? null : _ref22$sandboxBundleS,
                _ref22$scriptingFacto = _ref22.scriptingFactory,
                scriptingFactory = _ref22$scriptingFacto === void 0 ? null : _ref22$scriptingFacto,
                _ref22$docPropertiesL = _ref22.docPropertiesLookup,
                docPropertiesLookup = _ref22$docPropertiesL === void 0 ? null : _ref22$docPropertiesL;

            _classCallCheck(this, PDFScriptingManager);

            this._pdfDocument = null;
            this._pdfViewer = null;
            this._closeCapability = null;
            this._destroyCapability = null;
            this._scripting = null;
            this._mouseState = Object.create(null);
            this._ready = false;
            this._eventBus = eventBus;
            this._sandboxBundleSrc = sandboxBundleSrc;
            this._scriptingFactory = scriptingFactory;
            this._docPropertiesLookup = docPropertiesLookup;

            if (!this._scriptingFactory) {
              window.addEventListener("updatefromsandbox", function (event) {
                _this18._eventBus.dispatch("updatefromsandbox", {
                  source: window,
                  detail: event.detail
                });
              });
            }
          }

          _createClass(PDFScriptingManager, [{
            key: "setViewer",
            value: function setViewer(pdfViewer) {
              this._pdfViewer = pdfViewer;
            }
          }, {
            key: "setDocument",
            value: function () {
              var _setDocument = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(pdfDocument) {
                var _this19 = this,
                    _this$_scripting;

                var _yield$Promise$all3, _yield$Promise$all4, objects, calculationOrder, docActions, _iterator7, _step7, _step7$value, name, listener, _iterator8, _step8, _step8$value, _name, _listener2, docProperties;

                return _regeneratorRuntime().wrap(function _callee17$(_context17) {
                  while (1) {
                    switch (_context17.prev = _context17.next) {
                      case 0:
                        if (!this._pdfDocument) {
                          _context17.next = 3;
                          break;
                        }

                        _context17.next = 3;
                        return this._destroyScripting();

                      case 3:
                        this._pdfDocument = pdfDocument;

                        if (pdfDocument) {
                          _context17.next = 6;
                          break;
                        }

                        return _context17.abrupt("return");

                      case 6:
                        _context17.next = 8;
                        return Promise.all([pdfDocument.getFieldObjects(), pdfDocument.getCalculationOrderIds(), pdfDocument.getJSActions()]);

                      case 8:
                        _yield$Promise$all3 = _context17.sent;
                        _yield$Promise$all4 = _slicedToArray(_yield$Promise$all3, 3);
                        objects = _yield$Promise$all4[0];
                        calculationOrder = _yield$Promise$all4[1];
                        docActions = _yield$Promise$all4[2];

                        if (!(!objects && !docActions)) {
                          _context17.next = 17;
                          break;
                        }

                        _context17.next = 16;
                        return this._destroyScripting();

                      case 16:
                        return _context17.abrupt("return");

                      case 17:
                        if (!(pdfDocument !== this._pdfDocument)) {
                          _context17.next = 19;
                          break;
                        }

                        return _context17.abrupt("return");

                      case 19:
                        _context17.prev = 19;
                        this._scripting = this._createScripting();
                        _context17.next = 29;
                        break;

                      case 23:
                        _context17.prev = 23;
                        _context17.t0 = _context17["catch"](19);
                        console.error("PDFScriptingManager.setDocument: \"".concat(_context17.t0 === null || _context17.t0 === void 0 ? void 0 : _context17.t0.message, "\"."));
                        _context17.next = 28;
                        return this._destroyScripting();

                      case 28:
                        return _context17.abrupt("return");

                      case 29:
                        this._internalEvents.set("updatefromsandbox", function (event) {
                          if ((event === null || event === void 0 ? void 0 : event.source) !== window) {
                            return;
                          }

                          _this19._updateFromSandbox(event.detail);
                        });

                        this._internalEvents.set("dispatcheventinsandbox", function (event) {
                          var _this19$_scripting;

                          (_this19$_scripting = _this19._scripting) === null || _this19$_scripting === void 0 ? void 0 : _this19$_scripting.dispatchEventInSandbox(event.detail);
                        });

                        this._internalEvents.set("pagechanging", function (_ref23) {
                          var pageNumber = _ref23.pageNumber,
                              previous = _ref23.previous;

                          if (pageNumber === previous) {
                            return;
                          }

                          _this19._dispatchPageClose(previous);

                          _this19._dispatchPageOpen(pageNumber);
                        });

                        this._internalEvents.set("pagerendered", function (_ref24) {
                          var pageNumber = _ref24.pageNumber;

                          if (!_this19._pageOpenPending.has(pageNumber)) {
                            return;
                          }

                          if (pageNumber !== _this19._pdfViewer.currentPageNumber) {
                            return;
                          }

                          _this19._dispatchPageOpen(pageNumber);
                        });

                        this._internalEvents.set("pagesdestroy", /*#__PURE__*/function () {
                          var _ref25 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(event) {
                            var _this19$_scripting2, _this19$_closeCapabil;

                            return _regeneratorRuntime().wrap(function _callee16$(_context16) {
                              while (1) {
                                switch (_context16.prev = _context16.next) {
                                  case 0:
                                    _context16.next = 2;
                                    return _this19._dispatchPageClose(_this19._pdfViewer.currentPageNumber);

                                  case 2:
                                    _context16.next = 4;
                                    return (_this19$_scripting2 = _this19._scripting) === null || _this19$_scripting2 === void 0 ? void 0 : _this19$_scripting2.dispatchEventInSandbox({
                                      id: "doc",
                                      name: "WillClose"
                                    });

                                  case 4:
                                    (_this19$_closeCapabil = _this19._closeCapability) === null || _this19$_closeCapabil === void 0 ? void 0 : _this19$_closeCapabil.resolve();

                                  case 5:
                                  case "end":
                                    return _context16.stop();
                                }
                              }
                            }, _callee16);
                          }));

                          return function (_x8) {
                            return _ref25.apply(this, arguments);
                          };
                        }());

                        this._domEvents.set("mousedown", function (event) {
                          _this19._mouseState.isDown = true;
                        });

                        this._domEvents.set("mouseup", function (event) {
                          _this19._mouseState.isDown = false;
                        });

                        _iterator7 = _createForOfIteratorHelper(this._internalEvents);

                        try {
                          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                            _step7$value = _slicedToArray(_step7.value, 2), name = _step7$value[0], listener = _step7$value[1];

                            this._eventBus._on(name, listener);
                          }
                        } catch (err) {
                          _iterator7.e(err);
                        } finally {
                          _iterator7.f();
                        }

                        _iterator8 = _createForOfIteratorHelper(this._domEvents);

                        try {
                          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                            _step8$value = _slicedToArray(_step8.value, 2), _name = _step8$value[0], _listener2 = _step8$value[1];
                            window.addEventListener(_name, _listener2);
                          }
                        } catch (err) {
                          _iterator8.e(err);
                        } finally {
                          _iterator8.f();
                        }

                        _context17.prev = 40;
                        _context17.next = 43;
                        return this._getDocProperties();

                      case 43:
                        docProperties = _context17.sent;

                        if (!(pdfDocument !== this._pdfDocument)) {
                          _context17.next = 46;
                          break;
                        }

                        return _context17.abrupt("return");

                      case 46:
                        _context17.next = 48;
                        return this._scripting.createSandbox({
                          objects: objects,
                          calculationOrder: calculationOrder,
                          appInfo: {
                            platform: navigator.platform,
                            language: navigator.language
                          },
                          docInfo: _objectSpread(_objectSpread({}, docProperties), {}, {
                            actions: docActions
                          })
                        });

                      case 48:
                        this._eventBus.dispatch("sandboxcreated", {
                          source: this
                        });

                        _context17.next = 57;
                        break;

                      case 51:
                        _context17.prev = 51;
                        _context17.t1 = _context17["catch"](40);
                        console.error("PDFScriptingManager.setDocument: \"".concat(_context17.t1 === null || _context17.t1 === void 0 ? void 0 : _context17.t1.message, "\"."));
                        _context17.next = 56;
                        return this._destroyScripting();

                      case 56:
                        return _context17.abrupt("return");

                      case 57:
                        _context17.next = 59;
                        return (_this$_scripting = this._scripting) === null || _this$_scripting === void 0 ? void 0 : _this$_scripting.dispatchEventInSandbox({
                          id: "doc",
                          name: "Open"
                        });

                      case 59:
                        _context17.next = 61;
                        return this._dispatchPageOpen(this._pdfViewer.currentPageNumber, true);

                      case 61:
                        Promise.resolve().then(function () {
                          if (pdfDocument === _this19._pdfDocument) {
                            _this19._ready = true;
                          }
                        });

                      case 62:
                      case "end":
                        return _context17.stop();
                    }
                  }
                }, _callee17, this, [[19, 23], [40, 51]]);
              }));

              function setDocument(_x7) {
                return _setDocument.apply(this, arguments);
              }

              return setDocument;
            }()
          }, {
            key: "dispatchWillSave",
            value: function () {
              var _dispatchWillSave = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(detail) {
                var _this$_scripting2;

                return _regeneratorRuntime().wrap(function _callee18$(_context18) {
                  while (1) {
                    switch (_context18.prev = _context18.next) {
                      case 0:
                        return _context18.abrupt("return", (_this$_scripting2 = this._scripting) === null || _this$_scripting2 === void 0 ? void 0 : _this$_scripting2.dispatchEventInSandbox({
                          id: "doc",
                          name: "WillSave"
                        }));

                      case 1:
                      case "end":
                        return _context18.stop();
                    }
                  }
                }, _callee18, this);
              }));

              function dispatchWillSave(_x9) {
                return _dispatchWillSave.apply(this, arguments);
              }

              return dispatchWillSave;
            }()
          }, {
            key: "dispatchDidSave",
            value: function () {
              var _dispatchDidSave = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(detail) {
                var _this$_scripting3;

                return _regeneratorRuntime().wrap(function _callee19$(_context19) {
                  while (1) {
                    switch (_context19.prev = _context19.next) {
                      case 0:
                        return _context19.abrupt("return", (_this$_scripting3 = this._scripting) === null || _this$_scripting3 === void 0 ? void 0 : _this$_scripting3.dispatchEventInSandbox({
                          id: "doc",
                          name: "DidSave"
                        }));

                      case 1:
                      case "end":
                        return _context19.stop();
                    }
                  }
                }, _callee19, this);
              }));

              function dispatchDidSave(_x10) {
                return _dispatchDidSave.apply(this, arguments);
              }

              return dispatchDidSave;
            }()
          }, {
            key: "dispatchWillPrint",
            value: function () {
              var _dispatchWillPrint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(detail) {
                var _this$_scripting4;

                return _regeneratorRuntime().wrap(function _callee20$(_context20) {
                  while (1) {
                    switch (_context20.prev = _context20.next) {
                      case 0:
                        return _context20.abrupt("return", (_this$_scripting4 = this._scripting) === null || _this$_scripting4 === void 0 ? void 0 : _this$_scripting4.dispatchEventInSandbox({
                          id: "doc",
                          name: "WillPrint"
                        }));

                      case 1:
                      case "end":
                        return _context20.stop();
                    }
                  }
                }, _callee20, this);
              }));

              function dispatchWillPrint(_x11) {
                return _dispatchWillPrint.apply(this, arguments);
              }

              return dispatchWillPrint;
            }()
          }, {
            key: "dispatchDidPrint",
            value: function () {
              var _dispatchDidPrint = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(detail) {
                var _this$_scripting5;

                return _regeneratorRuntime().wrap(function _callee21$(_context21) {
                  while (1) {
                    switch (_context21.prev = _context21.next) {
                      case 0:
                        return _context21.abrupt("return", (_this$_scripting5 = this._scripting) === null || _this$_scripting5 === void 0 ? void 0 : _this$_scripting5.dispatchEventInSandbox({
                          id: "doc",
                          name: "DidPrint"
                        }));

                      case 1:
                      case "end":
                        return _context21.stop();
                    }
                  }
                }, _callee21, this);
              }));

              function dispatchDidPrint(_x12) {
                return _dispatchDidPrint.apply(this, arguments);
              }

              return dispatchDidPrint;
            }()
          }, {
            key: "mouseState",
            get: function get() {
              return this._mouseState;
            }
          }, {
            key: "destroyPromise",
            get: function get() {
              var _this$_destroyCapabil;

              return ((_this$_destroyCapabil = this._destroyCapability) === null || _this$_destroyCapabil === void 0 ? void 0 : _this$_destroyCapabil.promise) || null;
            }
          }, {
            key: "ready",
            get: function get() {
              return this._ready;
            }
          }, {
            key: "_internalEvents",
            get: function get() {
              return (0, _pdfjsLib.shadow)(this, "_internalEvents", new Map());
            }
          }, {
            key: "_domEvents",
            get: function get() {
              return (0, _pdfjsLib.shadow)(this, "_domEvents", new Map());
            }
          }, {
            key: "_pageOpenPending",
            get: function get() {
              return (0, _pdfjsLib.shadow)(this, "_pageOpenPending", new Set());
            }
          }, {
            key: "_visitedPages",
            get: function get() {
              return (0, _pdfjsLib.shadow)(this, "_visitedPages", new Map());
            }
          }, {
            key: "_updateFromSandbox",
            value: function () {
              var _updateFromSandbox2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(detail) {
                var isInPresentationMode, id, siblings, command, value, ids, _iterator9, _step9, elementId, element, _this$_pdfDocument;

                return _regeneratorRuntime().wrap(function _callee22$(_context22) {
                  while (1) {
                    switch (_context22.prev = _context22.next) {
                      case 0:
                        isInPresentationMode = this._pdfViewer.isInPresentationMode || this._pdfViewer.isChangingPresentationMode;
                        id = detail.id, siblings = detail.siblings, command = detail.command, value = detail.value;

                        if (id) {
                          _context22.next = 43;
                          break;
                        }

                        _context22.t0 = command;
                        _context22.next = _context22.t0 === "clear" ? 6 : _context22.t0 === "error" ? 8 : _context22.t0 === "layout" ? 10 : _context22.t0 === "page-num" ? 12 : _context22.t0 === "print" ? 14 : _context22.t0 === "println" ? 18 : _context22.t0 === "zoom" ? 20 : _context22.t0 === "SaveAs" ? 24 : _context22.t0 === "FirstPage" ? 26 : _context22.t0 === "LastPage" ? 28 : _context22.t0 === "NextPage" ? 30 : _context22.t0 === "PrevPage" ? 32 : _context22.t0 === "ZoomViewIn" ? 34 : _context22.t0 === "ZoomViewOut" ? 38 : 42;
                        break;

                      case 6:
                        console.clear();
                        return _context22.abrupt("break", 42);

                      case 8:
                        console.error(value);
                        return _context22.abrupt("break", 42);

                      case 10:
                        this._pdfViewer.spreadMode = (0, _ui_utils.apiPageLayoutToSpreadMode)(value);
                        return _context22.abrupt("break", 42);

                      case 12:
                        this._pdfViewer.currentPageNumber = value + 1;
                        return _context22.abrupt("break", 42);

                      case 14:
                        _context22.next = 16;
                        return this._pdfViewer.pagesPromise;

                      case 16:
                        this._eventBus.dispatch("print", {
                          source: this
                        });

                        return _context22.abrupt("break", 42);

                      case 18:
                        console.log(value);
                        return _context22.abrupt("break", 42);

                      case 20:
                        if (!isInPresentationMode) {
                          _context22.next = 22;
                          break;
                        }

                        return _context22.abrupt("return");

                      case 22:
                        this._pdfViewer.currentScaleValue = value;
                        return _context22.abrupt("break", 42);

                      case 24:
                        this._eventBus.dispatch("save", {
                          source: this
                        });

                        return _context22.abrupt("break", 42);

                      case 26:
                        this._pdfViewer.currentPageNumber = 1;
                        return _context22.abrupt("break", 42);

                      case 28:
                        this._pdfViewer.currentPageNumber = this._pdfViewer.pagesCount;
                        return _context22.abrupt("break", 42);

                      case 30:
                        this._pdfViewer.nextPage();

                        return _context22.abrupt("break", 42);

                      case 32:
                        this._pdfViewer.previousPage();

                        return _context22.abrupt("break", 42);

                      case 34:
                        if (!isInPresentationMode) {
                          _context22.next = 36;
                          break;
                        }

                        return _context22.abrupt("return");

                      case 36:
                        this._pdfViewer.increaseScale();

                        return _context22.abrupt("break", 42);

                      case 38:
                        if (!isInPresentationMode) {
                          _context22.next = 40;
                          break;
                        }

                        return _context22.abrupt("return");

                      case 40:
                        this._pdfViewer.decreaseScale();

                        return _context22.abrupt("break", 42);

                      case 42:
                        return _context22.abrupt("return");

                      case 43:
                        if (!isInPresentationMode) {
                          _context22.next = 46;
                          break;
                        }

                        if (!detail.focus) {
                          _context22.next = 46;
                          break;
                        }

                        return _context22.abrupt("return");

                      case 46:
                        delete detail.id;
                        delete detail.siblings;
                        ids = siblings ? [id].concat(_toConsumableArray(siblings)) : [id];
                        _iterator9 = _createForOfIteratorHelper(ids);

                        try {
                          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                            elementId = _step9.value;
                            element = document.getElementById(elementId);

                            if (element) {
                              element.dispatchEvent(new CustomEvent("updatefromsandbox", {
                                detail: detail
                              }));
                            } else {
                              (_this$_pdfDocument = this._pdfDocument) === null || _this$_pdfDocument === void 0 ? void 0 : _this$_pdfDocument.annotationStorage.setValue(elementId, detail);
                            }
                          }
                        } catch (err) {
                          _iterator9.e(err);
                        } finally {
                          _iterator9.f();
                        }

                      case 51:
                      case "end":
                        return _context22.stop();
                    }
                  }
                }, _callee22, this);
              }));

              function _updateFromSandbox(_x13) {
                return _updateFromSandbox2.apply(this, arguments);
              }

              return _updateFromSandbox;
            }()
          }, {
            key: "_dispatchPageOpen",
            value: function () {
              var _dispatchPageOpen2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(pageNumber) {
                var _this20 = this;

                var initialize,
                    pdfDocument,
                    visitedPages,
                    pageView,
                    actionsPromise,
                    _args24 = arguments;
                return _regeneratorRuntime().wrap(function _callee24$(_context24) {
                  while (1) {
                    switch (_context24.prev = _context24.next) {
                      case 0:
                        initialize = _args24.length > 1 && _args24[1] !== undefined ? _args24[1] : false;
                        pdfDocument = this._pdfDocument, visitedPages = this._visitedPages;

                        if (initialize) {
                          this._closeCapability = (0, _pdfjsLib.createPromiseCapability)();
                        }

                        if (this._closeCapability) {
                          _context24.next = 5;
                          break;
                        }

                        return _context24.abrupt("return");

                      case 5:
                        pageView = this._pdfViewer.getPageView(pageNumber - 1);

                        if (!((pageView === null || pageView === void 0 ? void 0 : pageView.renderingState) !== _pdf_rendering_queue.RenderingStates.FINISHED)) {
                          _context24.next = 9;
                          break;
                        }

                        this._pageOpenPending.add(pageNumber);

                        return _context24.abrupt("return");

                      case 9:
                        this._pageOpenPending["delete"](pageNumber);

                        actionsPromise = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
                          var _pageView$pdfPage, _this20$_scripting;

                          var actions;
                          return _regeneratorRuntime().wrap(function _callee23$(_context23) {
                            while (1) {
                              switch (_context23.prev = _context23.next) {
                                case 0:
                                  _context23.next = 2;
                                  return !visitedPages.has(pageNumber) ? (_pageView$pdfPage = pageView.pdfPage) === null || _pageView$pdfPage === void 0 ? void 0 : _pageView$pdfPage.getJSActions() : null;

                                case 2:
                                  actions = _context23.sent;

                                  if (!(pdfDocument !== _this20._pdfDocument)) {
                                    _context23.next = 5;
                                    break;
                                  }

                                  return _context23.abrupt("return");

                                case 5:
                                  _context23.next = 7;
                                  return (_this20$_scripting = _this20._scripting) === null || _this20$_scripting === void 0 ? void 0 : _this20$_scripting.dispatchEventInSandbox({
                                    id: "page",
                                    name: "PageOpen",
                                    pageNumber: pageNumber,
                                    actions: actions
                                  });

                                case 7:
                                case "end":
                                  return _context23.stop();
                              }
                            }
                          }, _callee23);
                        }))();
                        visitedPages.set(pageNumber, actionsPromise);

                      case 12:
                      case "end":
                        return _context24.stop();
                    }
                  }
                }, _callee24, this);
              }));

              function _dispatchPageOpen(_x14) {
                return _dispatchPageOpen2.apply(this, arguments);
              }

              return _dispatchPageOpen;
            }()
          }, {
            key: "_dispatchPageClose",
            value: function () {
              var _dispatchPageClose2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(pageNumber) {
                var _this$_scripting6;

                var pdfDocument, visitedPages, actionsPromise;
                return _regeneratorRuntime().wrap(function _callee25$(_context25) {
                  while (1) {
                    switch (_context25.prev = _context25.next) {
                      case 0:
                        pdfDocument = this._pdfDocument, visitedPages = this._visitedPages;

                        if (this._closeCapability) {
                          _context25.next = 3;
                          break;
                        }

                        return _context25.abrupt("return");

                      case 3:
                        if (!this._pageOpenPending.has(pageNumber)) {
                          _context25.next = 5;
                          break;
                        }

                        return _context25.abrupt("return");

                      case 5:
                        actionsPromise = visitedPages.get(pageNumber);

                        if (actionsPromise) {
                          _context25.next = 8;
                          break;
                        }

                        return _context25.abrupt("return");

                      case 8:
                        visitedPages.set(pageNumber, null);
                        _context25.next = 11;
                        return actionsPromise;

                      case 11:
                        if (!(pdfDocument !== this._pdfDocument)) {
                          _context25.next = 13;
                          break;
                        }

                        return _context25.abrupt("return");

                      case 13:
                        _context25.next = 15;
                        return (_this$_scripting6 = this._scripting) === null || _this$_scripting6 === void 0 ? void 0 : _this$_scripting6.dispatchEventInSandbox({
                          id: "page",
                          name: "PageClose",
                          pageNumber: pageNumber
                        });

                      case 15:
                      case "end":
                        return _context25.stop();
                    }
                  }
                }, _callee25, this);
              }));

              function _dispatchPageClose(_x15) {
                return _dispatchPageClose2.apply(this, arguments);
              }

              return _dispatchPageClose;
            }()
          }, {
            key: "_getDocProperties",
            value: function () {
              var _getDocProperties2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
                var _w_pdfjs_require__, docPropertiesLookup;

                return _regeneratorRuntime().wrap(function _callee26$(_context26) {
                  while (1) {
                    switch (_context26.prev = _context26.next) {
                      case 0:
                        if (!this._docPropertiesLookup) {
                          _context26.next = 2;
                          break;
                        }

                        return _context26.abrupt("return", this._docPropertiesLookup(this._pdfDocument));

                      case 2:
                        _w_pdfjs_require__ = __w_pdfjs_require__(19), docPropertiesLookup = _w_pdfjs_require__.docPropertiesLookup;
                        return _context26.abrupt("return", docPropertiesLookup(this._pdfDocument));

                      case 4:
                      case "end":
                        return _context26.stop();
                    }
                  }
                }, _callee26, this);
              }));

              function _getDocProperties() {
                return _getDocProperties2.apply(this, arguments);
              }

              return _getDocProperties;
            }()
          }, {
            key: "_createScripting",
            value: function _createScripting() {
              this._destroyCapability = (0, _pdfjsLib.createPromiseCapability)();

              if (this._scripting) {
                throw new Error("_createScripting: Scripting already exists.");
              }

              if (this._scriptingFactory) {
                return this._scriptingFactory.createScripting({
                  sandboxBundleSrc: this._sandboxBundleSrc
                });
              }

              var _w_pdfjs_require__2 = __w_pdfjs_require__(19),
                  GenericScripting = _w_pdfjs_require__2.GenericScripting;

              return new GenericScripting(this._sandboxBundleSrc);
            }
          }, {
            key: "_destroyScripting",
            value: function () {
              var _destroyScripting2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {
                var _this$_destroyCapabil3;

                var _this$_destroyCapabil2, _iterator10, _step10, _step10$value, name, listener, _iterator11, _step11, _step11$value, _name2, _listener3;

                return _regeneratorRuntime().wrap(function _callee27$(_context27) {
                  while (1) {
                    switch (_context27.prev = _context27.next) {
                      case 0:
                        if (this._scripting) {
                          _context27.next = 4;
                          break;
                        }

                        this._pdfDocument = null;
                        (_this$_destroyCapabil2 = this._destroyCapability) === null || _this$_destroyCapabil2 === void 0 ? void 0 : _this$_destroyCapabil2.resolve();
                        return _context27.abrupt("return");

                      case 4:
                        if (!this._closeCapability) {
                          _context27.next = 8;
                          break;
                        }

                        _context27.next = 7;
                        return Promise.race([this._closeCapability.promise, new Promise(function (resolve) {
                          setTimeout(resolve, 1000);
                        })])["catch"](function (reason) {});

                      case 7:
                        this._closeCapability = null;

                      case 8:
                        this._pdfDocument = null;
                        _context27.prev = 9;
                        _context27.next = 12;
                        return this._scripting.destroySandbox();

                      case 12:
                        _context27.next = 16;
                        break;

                      case 14:
                        _context27.prev = 14;
                        _context27.t0 = _context27["catch"](9);

                      case 16:
                        _iterator10 = _createForOfIteratorHelper(this._internalEvents);

                        try {
                          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                            _step10$value = _slicedToArray(_step10.value, 2), name = _step10$value[0], listener = _step10$value[1];

                            this._eventBus._off(name, listener);
                          }
                        } catch (err) {
                          _iterator10.e(err);
                        } finally {
                          _iterator10.f();
                        }

                        this._internalEvents.clear();

                        _iterator11 = _createForOfIteratorHelper(this._domEvents);

                        try {
                          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
                            _step11$value = _slicedToArray(_step11.value, 2), _name2 = _step11$value[0], _listener3 = _step11$value[1];
                            window.removeEventListener(_name2, _listener3);
                          }
                        } catch (err) {
                          _iterator11.e(err);
                        } finally {
                          _iterator11.f();
                        }

                        this._domEvents.clear();

                        this._pageOpenPending.clear();

                        this._visitedPages.clear();

                        this._scripting = null;
                        delete this._mouseState.isDown;
                        this._ready = false;
                        (_this$_destroyCapabil3 = this._destroyCapability) === null || _this$_destroyCapabil3 === void 0 ? void 0 : _this$_destroyCapabil3.resolve();

                      case 28:
                      case "end":
                        return _context27.stop();
                    }
                  }
                }, _callee27, this, [[9, 14]]);
              }));

              function _destroyScripting() {
                return _destroyScripting2.apply(this, arguments);
              }

              return _destroyScripting;
            }()
          }]);

          return PDFScriptingManager;
        }();

        exports.PDFScriptingManager = PDFScriptingManager;
        /***/
      },
      /* 19 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.docPropertiesLookup = docPropertiesLookup;
        exports.GenericScripting = void 0;

        var _pdfjsLib = __w_pdfjs_require__(2);

        function docPropertiesLookup(_x16) {
          return _docPropertiesLookup.apply(this, arguments);
        }

        function _docPropertiesLookup() {
          _docPropertiesLookup = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(pdfDocument) {
            var url, baseUrl, _yield$pdfDocument$ge, info, metadata, contentDispositionFilename, contentLength, _yield$pdfDocument$ge2, length;

            return _regeneratorRuntime().wrap(function _callee31$(_context31) {
              while (1) {
                switch (_context31.prev = _context31.next) {
                  case 0:
                    url = "", baseUrl = url.split("#")[0];
                    _context31.next = 3;
                    return pdfDocument.getMetadata();

                  case 3:
                    _yield$pdfDocument$ge = _context31.sent;
                    info = _yield$pdfDocument$ge.info;
                    metadata = _yield$pdfDocument$ge.metadata;
                    contentDispositionFilename = _yield$pdfDocument$ge.contentDispositionFilename;
                    contentLength = _yield$pdfDocument$ge.contentLength;

                    if (contentLength) {
                      _context31.next = 14;
                      break;
                    }

                    _context31.next = 11;
                    return pdfDocument.getDownloadInfo();

                  case 11:
                    _yield$pdfDocument$ge2 = _context31.sent;
                    length = _yield$pdfDocument$ge2.length;
                    contentLength = length;

                  case 14:
                    return _context31.abrupt("return", _objectSpread(_objectSpread({}, info), {}, {
                      baseURL: baseUrl,
                      filesize: contentLength,
                      filename: contentDispositionFilename || (0, _pdfjsLib.getPdfFilenameFromUrl)(url),
                      metadata: metadata === null || metadata === void 0 ? void 0 : metadata.getRaw(),
                      authors: metadata === null || metadata === void 0 ? void 0 : metadata.get("dc:creator"),
                      numPages: pdfDocument.numPages,
                      URL: url
                    }));

                  case 15:
                  case "end":
                    return _context31.stop();
                }
              }
            }, _callee31);
          }));
          return _docPropertiesLookup.apply(this, arguments);
        }

        var GenericScripting = /*#__PURE__*/function () {
          function GenericScripting(sandboxBundleSrc) {
            _classCallCheck(this, GenericScripting);

            this._ready = (0, _pdfjsLib.loadScript)(sandboxBundleSrc, true).then(function () {
              return window.pdfjsSandbox.QuickJSSandbox();
            });
          }

          _createClass(GenericScripting, [{
            key: "createSandbox",
            value: function () {
              var _createSandbox = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(data) {
                var sandbox;
                return _regeneratorRuntime().wrap(function _callee28$(_context28) {
                  while (1) {
                    switch (_context28.prev = _context28.next) {
                      case 0:
                        _context28.next = 2;
                        return this._ready;

                      case 2:
                        sandbox = _context28.sent;
                        sandbox.create(data);

                      case 4:
                      case "end":
                        return _context28.stop();
                    }
                  }
                }, _callee28, this);
              }));

              function createSandbox(_x17) {
                return _createSandbox.apply(this, arguments);
              }

              return createSandbox;
            }()
          }, {
            key: "dispatchEventInSandbox",
            value: function () {
              var _dispatchEventInSandbox = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(event) {
                var sandbox;
                return _regeneratorRuntime().wrap(function _callee29$(_context29) {
                  while (1) {
                    switch (_context29.prev = _context29.next) {
                      case 0:
                        _context29.next = 2;
                        return this._ready;

                      case 2:
                        sandbox = _context29.sent;
                        sandbox.dispatchEvent(event);

                      case 4:
                      case "end":
                        return _context29.stop();
                    }
                  }
                }, _callee29, this);
              }));

              function dispatchEventInSandbox(_x18) {
                return _dispatchEventInSandbox.apply(this, arguments);
              }

              return dispatchEventInSandbox;
            }()
          }, {
            key: "destroySandbox",
            value: function () {
              var _destroySandbox = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {
                var sandbox;
                return _regeneratorRuntime().wrap(function _callee30$(_context30) {
                  while (1) {
                    switch (_context30.prev = _context30.next) {
                      case 0:
                        _context30.next = 2;
                        return this._ready;

                      case 2:
                        sandbox = _context30.sent;
                        sandbox.nukeSandbox();

                      case 4:
                      case "end":
                        return _context30.stop();
                    }
                  }
                }, _callee30, this);
              }));

              function destroySandbox() {
                return _destroySandbox.apply(this, arguments);
              }

              return destroySandbox;
            }()
          }]);

          return GenericScripting;
        }();

        exports.GenericScripting = GenericScripting;
        /***/
      },
      /* 20 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFSinglePageViewer = void 0;

        var _base_viewer = __w_pdfjs_require__(21);

        var _pdfjsLib = __w_pdfjs_require__(2);

        var PDFSinglePageViewer = /*#__PURE__*/function (_base_viewer$BaseView) {
          _inherits(PDFSinglePageViewer, _base_viewer$BaseView);

          var _super2 = _createSuper(PDFSinglePageViewer);

          function PDFSinglePageViewer(options) {
            var _this21;

            _classCallCheck(this, PDFSinglePageViewer);

            _this21 = _super2.call(this, options);

            _this21.eventBus._on("pagesinit", function (evt) {
              _this21._ensurePageViewVisible();
            });

            return _this21;
          }

          _createClass(PDFSinglePageViewer, [{
            key: "_viewerElement",
            get: function get() {
              return (0, _pdfjsLib.shadow)(this, "_viewerElement", this._shadowViewer);
            }
          }, {
            key: "_pageWidthScaleFactor",
            get: function get() {
              return 1;
            }
          }, {
            key: "_resetView",
            value: function _resetView() {
              _get2(_getPrototypeOf(PDFSinglePageViewer.prototype), "_resetView", this).call(this);

              this._previousPageNumber = 1;
              this._shadowViewer = document.createDocumentFragment();
              this._updateScrollDown = null;
            }
          }, {
            key: "_ensurePageViewVisible",
            value: function _ensurePageViewVisible() {
              var pageView = this._pages[this._currentPageNumber - 1];
              var previousPageView = this._pages[this._previousPageNumber - 1];
              var viewerNodes = this.viewer.childNodes;

              switch (viewerNodes.length) {
                case 0:
                  this.viewer.appendChild(pageView.div);
                  break;

                case 1:
                  if (viewerNodes[0] !== previousPageView.div) {
                    throw new Error("_ensurePageViewVisible: Unexpected previously visible page.");
                  }

                  if (pageView === previousPageView) {
                    break;
                  }

                  this._shadowViewer.appendChild(previousPageView.div);

                  this.viewer.appendChild(pageView.div);
                  this.container.scrollTop = 0;
                  break;

                default:
                  throw new Error("_ensurePageViewVisible: Only one page should be visible at a time.");
              }

              this._previousPageNumber = this._currentPageNumber;
            }
          }, {
            key: "_scrollUpdate",
            value: function _scrollUpdate() {
              if (this._updateScrollDown) {
                this._updateScrollDown();
              }

              _get2(_getPrototypeOf(PDFSinglePageViewer.prototype), "_scrollUpdate", this).call(this);
            }
          }, {
            key: "_scrollIntoView",
            value: function _scrollIntoView(_ref27) {
              var _this22 = this;

              var pageDiv = _ref27.pageDiv,
                  _ref27$pageSpot = _ref27.pageSpot,
                  pageSpot = _ref27$pageSpot === void 0 ? null : _ref27$pageSpot,
                  _ref27$pageNumber = _ref27.pageNumber,
                  pageNumber = _ref27$pageNumber === void 0 ? null : _ref27$pageNumber;

              if (pageNumber) {
                this._setCurrentPageNumber(pageNumber);
              }

              var scrolledDown = this._currentPageNumber >= this._previousPageNumber;

              this._ensurePageViewVisible();

              this.update();

              _get2(_getPrototypeOf(PDFSinglePageViewer.prototype), "_scrollIntoView", this).call(this, {
                pageDiv: pageDiv,
                pageSpot: pageSpot,
                pageNumber: pageNumber
              });

              this._updateScrollDown = function () {
                _this22.scroll.down = scrolledDown;
                _this22._updateScrollDown = null;
              };
            }
          }, {
            key: "_getVisiblePages",
            value: function _getVisiblePages() {
              return this._getCurrentVisiblePage();
            }
          }, {
            key: "_updateHelper",
            value: function _updateHelper(visiblePages) {}
          }, {
            key: "_isScrollModeHorizontal",
            get: function get() {
              return (0, _pdfjsLib.shadow)(this, "_isScrollModeHorizontal", false);
            }
          }, {
            key: "_updateScrollMode",
            value: function _updateScrollMode() {}
          }, {
            key: "_updateSpreadMode",
            value: function _updateSpreadMode() {}
          }, {
            key: "_getPageAdvance",
            value: function _getPageAdvance() {
              return 1;
            }
          }]);

          return PDFSinglePageViewer;
        }(_base_viewer.BaseViewer);

        exports.PDFSinglePageViewer = PDFSinglePageViewer;
        /***/
      },
      /* 21 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.BaseViewer = void 0;

        var _pdfjsLib = __w_pdfjs_require__(2);

        var _ui_utils = __w_pdfjs_require__(5);

        var _pdf_rendering_queue = __w_pdfjs_require__(17);

        var _annotation_layer_builder = __w_pdfjs_require__(1);

        var _l10n_utils = __w_pdfjs_require__(3);

        var _pdf_page_view = __w_pdfjs_require__(16);

        var _pdf_link_service = __w_pdfjs_require__(4);

        var _struct_tree_layer_builder = __w_pdfjs_require__(6);

        var _text_highlighter = __w_pdfjs_require__(22);

        var _text_layer_builder = __w_pdfjs_require__(7);

        var _xfa_layer_builder = __w_pdfjs_require__(8);

        var DEFAULT_CACHE_SIZE = 10;

        function PDFPageViewBuffer(size) {
          var data = [];

          this.push = function (view) {
            var i = data.indexOf(view);

            if (i >= 0) {
              data.splice(i, 1);
            }

            data.push(view);

            if (data.length > size) {
              data.shift().destroy();
            }
          };

          this.resize = function (newSize, pagesToKeep) {
            size = newSize;

            if (pagesToKeep) {
              var pageIdsToKeep = new Set();

              for (var i = 0, iMax = pagesToKeep.length; i < iMax; ++i) {
                pageIdsToKeep.add(pagesToKeep[i].id);
              }

              (0, _ui_utils.moveToEndOfArray)(data, function (page) {
                return pageIdsToKeep.has(page.id);
              });
            }

            while (data.length > size) {
              data.shift().destroy();
            }
          };

          this.has = function (view) {
            return data.includes(view);
          };
        }

        function isSameScale(oldScale, newScale) {
          if (newScale === oldScale) {
            return true;
          }

          if (Math.abs(newScale - oldScale) < 1e-15) {
            return true;
          }

          return false;
        }

        var BaseViewer = /*#__PURE__*/function () {
          function BaseViewer(options) {
            var _this$container,
                _this$viewer,
                _options$textLayerMod2,
                _options$annotationMo2,
                _this23 = this;

            _classCallCheck(this, BaseViewer);

            if (this.constructor === BaseViewer) {
              throw new Error("Cannot initialize BaseViewer.");
            }

            var viewerVersion = '2.11.338';

            if (_pdfjsLib.version !== viewerVersion) {
              throw new Error("The API version \"".concat(_pdfjsLib.version, "\" does not match the Viewer version \"").concat(viewerVersion, "\"."));
            }

            this.container = options.container;
            this.viewer = options.viewer || options.container.firstElementChild;

            if (!(((_this$container = this.container) === null || _this$container === void 0 ? void 0 : _this$container.tagName.toUpperCase()) === "DIV" && ((_this$viewer = this.viewer) === null || _this$viewer === void 0 ? void 0 : _this$viewer.tagName.toUpperCase()) === "DIV")) {
              throw new Error("Invalid `container` and/or `viewer` option.");
            }

            if (this.container.offsetParent && getComputedStyle(this.container).position !== "absolute") {
              throw new Error("The `container` must be absolutely positioned.");
            }

            this.eventBus = options.eventBus;
            this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService();
            this.downloadManager = options.downloadManager || null;
            this.findController = options.findController || null;
            this._scriptingManager = options.scriptingManager || null;
            this.removePageBorders = options.removePageBorders || false;
            this.textLayerMode = (_options$textLayerMod2 = options.textLayerMode) !== null && _options$textLayerMod2 !== void 0 ? _options$textLayerMod2 : _ui_utils.TextLayerMode.ENABLE;
            this._annotationMode = (_options$annotationMo2 = options.annotationMode) !== null && _options$annotationMo2 !== void 0 ? _options$annotationMo2 : _pdfjsLib.AnnotationMode.ENABLE_FORMS;
            this.imageResourcesPath = options.imageResourcesPath || "";
            this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;
            this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;
            this.useOnlyCssZoom = options.useOnlyCssZoom || false;
            this.maxCanvasPixels = options.maxCanvasPixels;
            this.l10n = options.l10n || _l10n_utils.NullL10n;
            this.defaultRenderingQueue = !options.renderingQueue;

            if (this.defaultRenderingQueue) {
              this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();
              this.renderingQueue.setViewer(this);
            } else {
              this.renderingQueue = options.renderingQueue;
            }

            this._doc = document.documentElement;
            this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this));
            this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN;
            this._onBeforeDraw = this._onAfterDraw = null;

            this._resetView();

            if (this.removePageBorders) {
              this.viewer.classList.add("removePageBorders");
            }

            Promise.resolve().then(function () {
              _this23.eventBus.dispatch("baseviewerinit", {
                source: _this23
              });
            });
          }

          _createClass(BaseViewer, [{
            key: "pagesCount",
            get: function get() {
              return this._pages.length;
            }
          }, {
            key: "getPageView",
            value: function getPageView(index) {
              return this._pages[index];
            }
          }, {
            key: "pageViewsReady",
            get: function get() {
              if (!this._pagesCapability.settled) {
                return false;
              }

              return this._pages.every(function (pageView) {
                return pageView === null || pageView === void 0 ? void 0 : pageView.pdfPage;
              });
            }
          }, {
            key: "renderForms",
            get: function get() {
              return this._annotationMode === _pdfjsLib.AnnotationMode.ENABLE_FORMS;
            }
          }, {
            key: "enableScripting",
            get: function get() {
              return !!this._scriptingManager;
            }
          }, {
            key: "currentPageNumber",
            get: function get() {
              return this._currentPageNumber;
            },
            set: function set(val) {
              if (!Number.isInteger(val)) {
                throw new Error("Invalid page number.");
              }

              if (!this.pdfDocument) {
                return;
              }

              if (!this._setCurrentPageNumber(val, true)) {
                console.error("currentPageNumber: \"".concat(val, "\" is not a valid page."));
              }
            }
          }, {
            key: "_setCurrentPageNumber",
            value: function _setCurrentPageNumber(val) {
              var _this$_pageLabels, _this$_pageLabels2;

              var resetCurrentPageView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

              if (this._currentPageNumber === val) {
                if (resetCurrentPageView) {
                  this._resetCurrentPageView();
                }

                return true;
              }

              if (!(0 < val && val <= this.pagesCount)) {
                return false;
              }

              var previous = this._currentPageNumber;
              this._currentPageNumber = val;
              this.eventBus.dispatch("pagechanging", {
                source: this,
                pageNumber: val,
                pageLabel: (_this$_pageLabels = (_this$_pageLabels2 = this._pageLabels) === null || _this$_pageLabels2 === void 0 ? void 0 : _this$_pageLabels2[val - 1]) !== null && _this$_pageLabels !== void 0 ? _this$_pageLabels : null,
                previous: previous
              });

              if (resetCurrentPageView) {
                this._resetCurrentPageView();
              }

              return true;
            }
          }, {
            key: "currentPageLabel",
            get: function get() {
              var _this$_pageLabels3, _this$_pageLabels4;

              return (_this$_pageLabels3 = (_this$_pageLabels4 = this._pageLabels) === null || _this$_pageLabels4 === void 0 ? void 0 : _this$_pageLabels4[this._currentPageNumber - 1]) !== null && _this$_pageLabels3 !== void 0 ? _this$_pageLabels3 : null;
            },
            set: function set(val) {
              if (!this.pdfDocument) {
                return;
              }

              var page = val | 0;

              if (this._pageLabels) {
                var i = this._pageLabels.indexOf(val);

                if (i >= 0) {
                  page = i + 1;
                }
              }

              if (!this._setCurrentPageNumber(page, true)) {
                console.error("currentPageLabel: \"".concat(val, "\" is not a valid page."));
              }
            }
          }, {
            key: "currentScale",
            get: function get() {
              return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE;
            },
            set: function set(val) {
              if (isNaN(val)) {
                throw new Error("Invalid numeric scale.");
              }

              if (!this.pdfDocument) {
                return;
              }

              this._setScale(val, false);
            }
          }, {
            key: "currentScaleValue",
            get: function get() {
              return this._currentScaleValue;
            },
            set: function set(val) {
              if (!this.pdfDocument) {
                return;
              }

              this._setScale(val, false);
            }
          }, {
            key: "pagesRotation",
            get: function get() {
              return this._pagesRotation;
            },
            set: function set(rotation) {
              if (!(0, _ui_utils.isValidRotation)(rotation)) {
                throw new Error("Invalid pages rotation angle.");
              }

              if (!this.pdfDocument) {
                return;
              }

              rotation %= 360;

              if (rotation < 0) {
                rotation += 360;
              }

              if (this._pagesRotation === rotation) {
                return;
              }

              this._pagesRotation = rotation;
              var pageNumber = this._currentPageNumber;
              var updateArgs = {
                rotation: rotation
              };

              var _iterator12 = _createForOfIteratorHelper(this._pages),
                  _step12;

              try {
                for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
                  var pageView = _step12.value;
                  pageView.update(updateArgs);
                }
              } catch (err) {
                _iterator12.e(err);
              } finally {
                _iterator12.f();
              }

              if (this._currentScaleValue) {
                this._setScale(this._currentScaleValue, true);
              }

              this.eventBus.dispatch("rotationchanging", {
                source: this,
                pagesRotation: rotation,
                pageNumber: pageNumber
              });

              if (this.defaultRenderingQueue) {
                this.update();
              }
            }
          }, {
            key: "firstPagePromise",
            get: function get() {
              return this.pdfDocument ? this._firstPageCapability.promise : null;
            }
          }, {
            key: "onePageRendered",
            get: function get() {
              return this.pdfDocument ? this._onePageRenderedCapability.promise : null;
            }
          }, {
            key: "pagesPromise",
            get: function get() {
              return this.pdfDocument ? this._pagesCapability.promise : null;
            }
          }, {
            key: "_viewerElement",
            get: function get() {
              throw new Error("Not implemented: _viewerElement");
            }
          }, {
            key: "_onePageRenderedOrForceFetch",
            value: function _onePageRenderedOrForceFetch() {
              if (!this.container.offsetParent || this._getVisiblePages().views.length === 0) {
                return Promise.resolve();
              }

              return this._onePageRenderedCapability.promise;
            }
          }, {
            key: "setDocument",
            value: function setDocument(pdfDocument) {
              var _this24 = this;

              if (this.pdfDocument) {
                this.eventBus.dispatch("pagesdestroy", {
                  source: this
                });

                this._cancelRendering();

                this._resetView();

                if (this.findController) {
                  this.findController.setDocument(null);
                }

                if (this._scriptingManager) {
                  this._scriptingManager.setDocument(null);
                }
              }

              this.pdfDocument = pdfDocument;

              if (!pdfDocument) {
                return;
              }

              var isPureXfa = pdfDocument.isPureXfa;
              var pagesCount = pdfDocument.numPages;
              var firstPagePromise = pdfDocument.getPage(1);
              var optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();

              this._pagesCapability.promise.then(function () {
                _this24.eventBus.dispatch("pagesloaded", {
                  source: _this24,
                  pagesCount: pagesCount
                });
              });

              this._onBeforeDraw = function (evt) {
                var pageView = _this24._pages[evt.pageNumber - 1];

                if (!pageView) {
                  return;
                }

                _this24._buffer.push(pageView);
              };

              this.eventBus._on("pagerender", this._onBeforeDraw);

              this._onAfterDraw = function (evt) {
                if (evt.cssTransform || _this24._onePageRenderedCapability.settled) {
                  return;
                }

                _this24._onePageRenderedCapability.resolve();

                _this24.eventBus._off("pagerendered", _this24._onAfterDraw);

                _this24._onAfterDraw = null;
              };

              this.eventBus._on("pagerendered", this._onAfterDraw);

              firstPagePromise.then(function (firstPdfPage) {
                _this24._firstPageCapability.resolve(firstPdfPage);

                _this24._optionalContentConfigPromise = optionalContentConfigPromise;
                var scale = _this24.currentScale;
                var viewport = firstPdfPage.getViewport({
                  scale: scale * _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS
                });
                var textLayerFactory = _this24.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && !isPureXfa ? _this24 : null;
                var annotationLayerFactory = _this24._annotationMode !== _pdfjsLib.AnnotationMode.DISABLE ? _this24 : null;
                var xfaLayerFactory = isPureXfa ? _this24 : null;

                for (var pageNum = 1; pageNum <= pagesCount; ++pageNum) {
                  var pageView = new _pdf_page_view.PDFPageView({
                    container: _this24._viewerElement,
                    eventBus: _this24.eventBus,
                    id: pageNum,
                    scale: scale,
                    defaultViewport: viewport.clone(),
                    optionalContentConfigPromise: optionalContentConfigPromise,
                    renderingQueue: _this24.renderingQueue,
                    textLayerFactory: textLayerFactory,
                    textLayerMode: _this24.textLayerMode,
                    annotationLayerFactory: annotationLayerFactory,
                    annotationMode: _this24._annotationMode,
                    xfaLayerFactory: xfaLayerFactory,
                    textHighlighterFactory: _this24,
                    structTreeLayerFactory: _this24,
                    imageResourcesPath: _this24.imageResourcesPath,
                    renderer: _this24.renderer,
                    useOnlyCssZoom: _this24.useOnlyCssZoom,
                    maxCanvasPixels: _this24.maxCanvasPixels,
                    l10n: _this24.l10n
                  });

                  _this24._pages.push(pageView);
                }

                var firstPageView = _this24._pages[0];

                if (firstPageView) {
                  firstPageView.setPdfPage(firstPdfPage);

                  _this24.linkService.cachePageRef(1, firstPdfPage.ref);
                }

                if (_this24._spreadMode !== _ui_utils.SpreadMode.NONE) {
                  _this24._updateSpreadMode();
                }

                _this24._onePageRenderedOrForceFetch().then(function () {
                  if (_this24.findController) {
                    _this24.findController.setDocument(pdfDocument);
                  }

                  if (_this24._scriptingManager) {
                    _this24._scriptingManager.setDocument(pdfDocument);
                  }

                  if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > 7500) {
                    _this24._pagesCapability.resolve();

                    return;
                  }

                  var getPagesLeft = pagesCount - 1;

                  if (getPagesLeft <= 0) {
                    _this24._pagesCapability.resolve();

                    return;
                  }

                  var _loop2 = function _loop2(_pageNum) {
                    pdfDocument.getPage(_pageNum).then(function (pdfPage) {
                      var pageView = _this24._pages[_pageNum - 1];

                      if (!pageView.pdfPage) {
                        pageView.setPdfPage(pdfPage);
                      }

                      _this24.linkService.cachePageRef(_pageNum, pdfPage.ref);

                      if (--getPagesLeft === 0) {
                        _this24._pagesCapability.resolve();
                      }
                    }, function (reason) {
                      console.error("Unable to get page ".concat(_pageNum, " to initialize viewer"), reason);

                      if (--getPagesLeft === 0) {
                        _this24._pagesCapability.resolve();
                      }
                    });
                  };

                  for (var _pageNum = 2; _pageNum <= pagesCount; ++_pageNum) {
                    _loop2(_pageNum);
                  }
                });

                _this24.eventBus.dispatch("pagesinit", {
                  source: _this24
                });

                if (_this24.defaultRenderingQueue) {
                  _this24.update();
                }
              })["catch"](function (reason) {
                console.error("Unable to initialize viewer", reason);
              });
            }
          }, {
            key: "setPageLabels",
            value: function setPageLabels(labels) {
              if (!this.pdfDocument) {
                return;
              }

              if (!labels) {
                this._pageLabels = null;
              } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {
                this._pageLabels = null;
                console.error("setPageLabels: Invalid page labels.");
              } else {
                this._pageLabels = labels;
              }

              for (var i = 0, ii = this._pages.length; i < ii; i++) {
                var _this$_pageLabels$i, _this$_pageLabels5;

                this._pages[i].setPageLabel((_this$_pageLabels$i = (_this$_pageLabels5 = this._pageLabels) === null || _this$_pageLabels5 === void 0 ? void 0 : _this$_pageLabels5[i]) !== null && _this$_pageLabels$i !== void 0 ? _this$_pageLabels$i : null);
              }
            }
          }, {
            key: "_resetView",
            value: function _resetView() {
              this._pages = [];
              this._currentPageNumber = 1;
              this._currentScale = _ui_utils.UNKNOWN_SCALE;
              this._currentScaleValue = null;
              this._pageLabels = null;
              this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);
              this._location = null;
              this._pagesRotation = 0;
              this._optionalContentConfigPromise = null;
              this._pagesRequests = new WeakMap();
              this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();
              this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)();
              this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)();
              this._scrollMode = _ui_utils.ScrollMode.VERTICAL;
              this._spreadMode = _ui_utils.SpreadMode.NONE;

              if (this._onBeforeDraw) {
                this.eventBus._off("pagerender", this._onBeforeDraw);

                this._onBeforeDraw = null;
              }

              if (this._onAfterDraw) {
                this.eventBus._off("pagerendered", this._onAfterDraw);

                this._onAfterDraw = null;
              }

              this.viewer.textContent = "";

              this._updateScrollMode();
            }
          }, {
            key: "_scrollUpdate",
            value: function _scrollUpdate() {
              if (this.pagesCount === 0) {
                return;
              }

              this.update();
            }
          }, {
            key: "_scrollIntoView",
            value: function _scrollIntoView(_ref28) {
              var pageDiv = _ref28.pageDiv,
                  _ref28$pageSpot = _ref28.pageSpot,
                  pageSpot = _ref28$pageSpot === void 0 ? null : _ref28$pageSpot,
                  _ref28$pageNumber = _ref28.pageNumber,
                  pageNumber = _ref28$pageNumber === void 0 ? null : _ref28$pageNumber;
              (0, _ui_utils.scrollIntoView)(pageDiv, pageSpot);
            }
          }, {
            key: "_setScaleUpdatePages",
            value: function _setScaleUpdatePages(newScale, newValue) {
              var noScroll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
              var preset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
              this._currentScaleValue = newValue.toString();

              if (isSameScale(this._currentScale, newScale)) {
                if (preset) {
                  this.eventBus.dispatch("scalechanging", {
                    source: this,
                    scale: newScale,
                    presetValue: newValue
                  });
                }

                return;
              }

              this._doc.style.setProperty("--zoom-factor", newScale);

              var updateArgs = {
                scale: newScale
              };

              var _iterator13 = _createForOfIteratorHelper(this._pages),
                  _step13;

              try {
                for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
                  var pageView = _step13.value;
                  pageView.update(updateArgs);
                }
              } catch (err) {
                _iterator13.e(err);
              } finally {
                _iterator13.f();
              }

              this._currentScale = newScale;

              if (!noScroll) {
                var page = this._currentPageNumber,
                    dest;

                if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) {
                  page = this._location.pageNumber;
                  dest = [null, {
                    name: "XYZ"
                  }, this._location.left, this._location.top, null];
                }

                this.scrollPageIntoView({
                  pageNumber: page,
                  destArray: dest,
                  allowNegativeOffset: true
                });
              }

              this.eventBus.dispatch("scalechanging", {
                source: this,
                scale: newScale,
                presetValue: preset ? newValue : undefined
              });

              if (this.defaultRenderingQueue) {
                this.update();
              }
            }
          }, {
            key: "_pageWidthScaleFactor",
            get: function get() {
              if (this._spreadMode !== _ui_utils.SpreadMode.NONE && this._scrollMode !== _ui_utils.ScrollMode.HORIZONTAL && !this.isInPresentationMode) {
                return 2;
              }

              return 1;
            }
          }, {
            key: "_setScale",
            value: function _setScale(value) {
              var noScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
              var scale = parseFloat(value);

              if (scale > 0) {
                this._setScaleUpdatePages(scale, value, noScroll, false);
              } else {
                var currentPage = this._pages[this._currentPageNumber - 1];

                if (!currentPage) {
                  return;
                }

                var noPadding = this.isInPresentationMode || this.removePageBorders;
                var hPadding = noPadding ? 0 : _ui_utils.SCROLLBAR_PADDING;
                var vPadding = noPadding ? 0 : _ui_utils.VERTICAL_PADDING;

                if (!noPadding && this._isScrollModeHorizontal) {
                  var _ref29 = [vPadding, hPadding];
                  hPadding = _ref29[0];
                  vPadding = _ref29[1];
                }

                var pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale / this._pageWidthScaleFactor;
                var pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;

                switch (value) {
                  case "page-actual":
                    scale = 1;
                    break;

                  case "page-width":
                    scale = pageWidthScale;
                    break;

                  case "page-height":
                    scale = pageHeightScale;
                    break;

                  case "page-fit":
                    scale = Math.min(pageWidthScale, pageHeightScale);
                    break;

                  case "auto":
                    var horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);
                    scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale);
                    break;

                  default:
                    console.error("_setScale: \"".concat(value, "\" is an unknown zoom value."));
                    return;
                }

                this._setScaleUpdatePages(scale, value, noScroll, true);
              }
            }
          }, {
            key: "_resetCurrentPageView",
            value: function _resetCurrentPageView() {
              if (this.isInPresentationMode) {
                this._setScale(this._currentScaleValue, true);
              }

              var pageView = this._pages[this._currentPageNumber - 1];

              this._scrollIntoView({
                pageDiv: pageView.div
              });
            }
          }, {
            key: "pageLabelToPageNumber",
            value: function pageLabelToPageNumber(label) {
              if (!this._pageLabels) {
                return null;
              }

              var i = this._pageLabels.indexOf(label);

              if (i < 0) {
                return null;
              }

              return i + 1;
            }
          }, {
            key: "scrollPageIntoView",
            value: function scrollPageIntoView(_ref30) {
              var pageNumber = _ref30.pageNumber,
                  _ref30$destArray = _ref30.destArray,
                  destArray = _ref30$destArray === void 0 ? null : _ref30$destArray,
                  _ref30$allowNegativeO = _ref30.allowNegativeOffset,
                  allowNegativeOffset = _ref30$allowNegativeO === void 0 ? false : _ref30$allowNegativeO,
                  _ref30$ignoreDestinat = _ref30.ignoreDestinationZoom,
                  ignoreDestinationZoom = _ref30$ignoreDestinat === void 0 ? false : _ref30$ignoreDestinat;

              if (!this.pdfDocument) {
                return;
              }

              var pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];

              if (!pageView) {
                console.error("scrollPageIntoView: \"".concat(pageNumber, "\" is not a valid pageNumber parameter."));
                return;
              }

              if (this.isInPresentationMode || !destArray) {
                this._setCurrentPageNumber(pageNumber, true);

                return;
              }

              var x = 0,
                  y = 0;
              var width = 0,
                  height = 0,
                  widthScale,
                  heightScale;
              var changeOrientation = pageView.rotation % 180 !== 0;
              var pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
              var pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
              var scale = 0;

              switch (destArray[1].name) {
                case "XYZ":
                  x = destArray[2];
                  y = destArray[3];
                  scale = destArray[4];
                  x = x !== null ? x : 0;
                  y = y !== null ? y : pageHeight;
                  break;

                case "Fit":
                case "FitB":
                  scale = "page-fit";
                  break;

                case "FitH":
                case "FitBH":
                  y = destArray[2];
                  scale = "page-width";

                  if (y === null && this._location) {
                    x = this._location.left;
                    y = this._location.top;
                  } else if (typeof y !== "number") {
                    y = pageHeight;
                  }

                  break;

                case "FitV":
                case "FitBV":
                  x = destArray[2];
                  width = pageWidth;
                  height = pageHeight;
                  scale = "page-height";
                  break;

                case "FitR":
                  x = destArray[2];
                  y = destArray[3];
                  width = destArray[4] - x;
                  height = destArray[5] - y;
                  var hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING;
                  var vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING;
                  widthScale = (this.container.clientWidth - hPadding) / width / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
                  heightScale = (this.container.clientHeight - vPadding) / height / _pdfjsLib.PixelsPerInch.PDF_TO_CSS_UNITS;
                  scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));
                  break;

                default:
                  console.error("scrollPageIntoView: \"".concat(destArray[1].name, "\" is not a valid destination type."));
                  return;
              }

              if (!ignoreDestinationZoom) {
                if (scale && scale !== this._currentScale) {
                  this.currentScaleValue = scale;
                } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) {
                  this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;
                }
              }

              if (scale === "page-fit" && !destArray[4]) {
                this._scrollIntoView({
                  pageDiv: pageView.div,
                  pageNumber: pageNumber
                });

                return;
              }

              var boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)];
              var left = Math.min(boundingRect[0][0], boundingRect[1][0]);
              var top = Math.min(boundingRect[0][1], boundingRect[1][1]);

              if (!allowNegativeOffset) {
                left = Math.max(left, 0);
                top = Math.max(top, 0);
              }

              this._scrollIntoView({
                pageDiv: pageView.div,
                pageSpot: {
                  left: left,
                  top: top
                },
                pageNumber: pageNumber
              });
            }
          }, {
            key: "_updateLocation",
            value: function _updateLocation(firstPage) {
              var currentScale = this._currentScale;
              var currentScaleValue = this._currentScaleValue;
              var normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue;
              var pageNumber = firstPage.id;
              var pdfOpenParams = "#page=" + pageNumber;
              pdfOpenParams += "&zoom=" + normalizedScaleValue;
              var currentPageView = this._pages[pageNumber - 1];
              var container = this.container;
              var topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);
              var intLeft = Math.round(topLeft[0]);
              var intTop = Math.round(topLeft[1]);
              pdfOpenParams += "," + intLeft + "," + intTop;
              this._location = {
                pageNumber: pageNumber,
                scale: normalizedScaleValue,
                top: intTop,
                left: intLeft,
                rotation: this._pagesRotation,
                pdfOpenParams: pdfOpenParams
              };
            }
          }, {
            key: "_updateHelper",
            value: function _updateHelper(visiblePages) {
              throw new Error("Not implemented: _updateHelper");
            }
          }, {
            key: "update",
            value: function update() {
              var visible = this._getVisiblePages();

              var visiblePages = visible.views,
                  numVisiblePages = visiblePages.length;

              if (numVisiblePages === 0) {
                return;
              }

              var newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);

              this._buffer.resize(newCacheSize, visiblePages);

              this.renderingQueue.renderHighestPriority(visible);

              this._updateHelper(visiblePages);

              this._updateLocation(visible.first);

              this.eventBus.dispatch("updateviewarea", {
                source: this,
                location: this._location
              });
            }
          }, {
            key: "containsElement",
            value: function containsElement(element) {
              return this.container.contains(element);
            }
          }, {
            key: "focus",
            value: function focus() {
              this.container.focus();
            }
          }, {
            key: "_isScrollModeHorizontal",
            get: function get() {
              return this.isInPresentationMode ? false : this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL;
            }
          }, {
            key: "_isContainerRtl",
            get: function get() {
              return getComputedStyle(this.container).direction === "rtl";
            }
          }, {
            key: "isInPresentationMode",
            get: function get() {
              return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN;
            }
          }, {
            key: "isChangingPresentationMode",
            get: function get() {
              return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING;
            }
          }, {
            key: "isHorizontalScrollbarEnabled",
            get: function get() {
              return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;
            }
          }, {
            key: "isVerticalScrollbarEnabled",
            get: function get() {
              return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight;
            }
          }, {
            key: "_getCurrentVisiblePage",
            value: function _getCurrentVisiblePage() {
              if (!this.pagesCount) {
                return {
                  views: []
                };
              }

              var pageView = this._pages[this._currentPageNumber - 1];
              var element = pageView.div;
              var view = {
                id: pageView.id,
                x: element.offsetLeft + element.clientLeft,
                y: element.offsetTop + element.clientTop,
                view: pageView
              };
              return {
                first: view,
                last: view,
                views: [view]
              };
            }
          }, {
            key: "_getVisiblePages",
            value: function _getVisiblePages() {
              return (0, _ui_utils.getVisibleElements)({
                scrollEl: this.container,
                views: this._pages,
                sortByVisibility: true,
                horizontal: this._isScrollModeHorizontal,
                rtl: this._isScrollModeHorizontal && this._isContainerRtl
              });
            }
          }, {
            key: "isPageVisible",
            value: function isPageVisible(pageNumber) {
              if (!this.pdfDocument) {
                return false;
              }

              if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
                console.error("isPageVisible: \"".concat(pageNumber, "\" is not a valid page."));
                return false;
              }

              return this._getVisiblePages().views.some(function (view) {
                return view.id === pageNumber;
              });
            }
          }, {
            key: "isPageCached",
            value: function isPageCached(pageNumber) {
              if (!this.pdfDocument || !this._buffer) {
                return false;
              }

              if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.pagesCount)) {
                console.error("isPageCached: \"".concat(pageNumber, "\" is not a valid page."));
                return false;
              }

              var pageView = this._pages[pageNumber - 1];

              if (!pageView) {
                return false;
              }

              return this._buffer.has(pageView);
            }
          }, {
            key: "cleanup",
            value: function cleanup() {
              for (var i = 0, ii = this._pages.length; i < ii; i++) {
                if (this._pages[i] && this._pages[i].renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {
                  this._pages[i].reset();
                }
              }
            }
          }, {
            key: "_cancelRendering",
            value: function _cancelRendering() {
              for (var i = 0, ii = this._pages.length; i < ii; i++) {
                if (this._pages[i]) {
                  this._pages[i].cancelRendering();
                }
              }
            }
          }, {
            key: "_ensurePdfPageLoaded",
            value: function _ensurePdfPageLoaded(pageView) {
              var _this25 = this;

              if (pageView.pdfPage) {
                return Promise.resolve(pageView.pdfPage);
              }

              if (this._pagesRequests.has(pageView)) {
                return this._pagesRequests.get(pageView);
              }

              var promise = this.pdfDocument.getPage(pageView.id).then(function (pdfPage) {
                if (!pageView.pdfPage) {
                  pageView.setPdfPage(pdfPage);
                }

                _this25._pagesRequests["delete"](pageView);

                return pdfPage;
              })["catch"](function (reason) {
                console.error("Unable to get page for page view", reason);

                _this25._pagesRequests["delete"](pageView);
              });

              this._pagesRequests.set(pageView, promise);

              return promise;
            }
          }, {
            key: "forceRendering",
            value: function forceRendering(currentlyVisiblePages) {
              var _this26 = this;

              var visiblePages = currentlyVisiblePages || this._getVisiblePages();

              var scrollAhead = this._isScrollModeHorizontal ? this.scroll.right : this.scroll.down;
              var preRenderExtra = this._scrollMode === _ui_utils.ScrollMode.VERTICAL && this._spreadMode !== _ui_utils.SpreadMode.NONE && !this.isInPresentationMode;
              var pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead, preRenderExtra);

              if (pageView) {
                this._ensurePdfPageLoaded(pageView).then(function () {
                  _this26.renderingQueue.renderView(pageView);
                });

                return true;
              }

              return false;
            }
          }, {
            key: "createTextLayerBuilder",
            value: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) {
              var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
              var eventBus = arguments.length > 4 ? arguments[4] : undefined;
              var highlighter = arguments.length > 5 ? arguments[5] : undefined;
              return new _text_layer_builder.TextLayerBuilder({
                textLayerDiv: textLayerDiv,
                eventBus: eventBus,
                pageIndex: pageIndex,
                viewport: viewport,
                enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection,
                highlighter: highlighter
              });
            }
          }, {
            key: "createTextHighlighter",
            value: function createTextHighlighter(pageIndex, eventBus) {
              return new _text_highlighter.TextHighlighter({
                eventBus: eventBus,
                pageIndex: pageIndex,
                findController: this.isInPresentationMode ? null : this.findController
              });
            }
          }, {
            key: "createAnnotationLayerBuilder",
            value: function createAnnotationLayerBuilder(pageDiv, pdfPage) {
              var _this$pdfDocument, _this$pdfDocument2, _this$pdfDocument3, _this$_scriptingManag;

              var annotationStorage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              var imageResourcesPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "";
              var renderForms = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
              var l10n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _l10n_utils.NullL10n;
              var enableScripting = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
              var hasJSActionsPromise = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
              var mouseState = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
              var fieldObjectsPromise = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
              return new _annotation_layer_builder.AnnotationLayerBuilder({
                pageDiv: pageDiv,
                pdfPage: pdfPage,
                annotationStorage: annotationStorage || ((_this$pdfDocument = this.pdfDocument) === null || _this$pdfDocument === void 0 ? void 0 : _this$pdfDocument.annotationStorage),
                imageResourcesPath: imageResourcesPath,
                renderForms: renderForms,
                linkService: this.linkService,
                downloadManager: this.downloadManager,
                l10n: l10n,
                enableScripting: enableScripting !== null && enableScripting !== void 0 ? enableScripting : this.enableScripting,
                hasJSActionsPromise: hasJSActionsPromise || ((_this$pdfDocument2 = this.pdfDocument) === null || _this$pdfDocument2 === void 0 ? void 0 : _this$pdfDocument2.hasJSActions()),
                fieldObjectsPromise: fieldObjectsPromise || ((_this$pdfDocument3 = this.pdfDocument) === null || _this$pdfDocument3 === void 0 ? void 0 : _this$pdfDocument3.getFieldObjects()),
                mouseState: mouseState || ((_this$_scriptingManag = this._scriptingManager) === null || _this$_scriptingManag === void 0 ? void 0 : _this$_scriptingManag.mouseState)
              });
            }
          }, {
            key: "createXfaLayerBuilder",
            value: function createXfaLayerBuilder(pageDiv, pdfPage) {
              var _this$pdfDocument4;

              var annotationStorage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
              return new _xfa_layer_builder.XfaLayerBuilder({
                pageDiv: pageDiv,
                pdfPage: pdfPage,
                annotationStorage: annotationStorage || ((_this$pdfDocument4 = this.pdfDocument) === null || _this$pdfDocument4 === void 0 ? void 0 : _this$pdfDocument4.annotationStorage),
                linkService: this.linkService
              });
            }
          }, {
            key: "createStructTreeLayerBuilder",
            value: function createStructTreeLayerBuilder(pdfPage) {
              return new _struct_tree_layer_builder.StructTreeLayerBuilder({
                pdfPage: pdfPage
              });
            }
          }, {
            key: "hasEqualPageSizes",
            get: function get() {
              var firstPageView = this._pages[0];

              for (var i = 1, ii = this._pages.length; i < ii; ++i) {
                var pageView = this._pages[i];

                if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {
                  return false;
                }
              }

              return true;
            }
          }, {
            key: "getPagesOverview",
            value: function getPagesOverview() {
              var _this27 = this;

              return this._pages.map(function (pageView) {
                var viewport = pageView.pdfPage.getViewport({
                  scale: 1
                });

                if (!_this27.enablePrintAutoRotate || (0, _ui_utils.isPortraitOrientation)(viewport)) {
                  return {
                    width: viewport.width,
                    height: viewport.height,
                    rotation: viewport.rotation
                  };
                }

                return {
                  width: viewport.height,
                  height: viewport.width,
                  rotation: (viewport.rotation - 90) % 360
                };
              });
            }
          }, {
            key: "optionalContentConfigPromise",
            get: function get() {
              if (!this.pdfDocument) {
                return Promise.resolve(null);
              }

              if (!this._optionalContentConfigPromise) {
                return this.pdfDocument.getOptionalContentConfig();
              }

              return this._optionalContentConfigPromise;
            },
            set: function set(promise) {
              if (!(promise instanceof Promise)) {
                throw new Error("Invalid optionalContentConfigPromise: ".concat(promise));
              }

              if (!this.pdfDocument) {
                return;
              }

              if (!this._optionalContentConfigPromise) {
                return;
              }

              this._optionalContentConfigPromise = promise;
              var updateArgs = {
                optionalContentConfigPromise: promise
              };

              var _iterator14 = _createForOfIteratorHelper(this._pages),
                  _step14;

              try {
                for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
                  var pageView = _step14.value;
                  pageView.update(updateArgs);
                }
              } catch (err) {
                _iterator14.e(err);
              } finally {
                _iterator14.f();
              }

              this.update();
              this.eventBus.dispatch("optionalcontentconfigchanged", {
                source: this,
                promise: promise
              });
            }
          }, {
            key: "scrollMode",
            get: function get() {
              return this._scrollMode;
            },
            set: function set(mode) {
              if (this._scrollMode === mode) {
                return;
              }

              if (!(0, _ui_utils.isValidScrollMode)(mode)) {
                throw new Error("Invalid scroll mode: ".concat(mode));
              }

              this._scrollMode = mode;
              this.eventBus.dispatch("scrollmodechanged", {
                source: this,
                mode: mode
              });

              this._updateScrollMode(this._currentPageNumber);
            }
          }, {
            key: "_updateScrollMode",
            value: function _updateScrollMode() {
              var pageNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
              var scrollMode = this._scrollMode,
                  viewer = this.viewer;
              viewer.classList.toggle("scrollHorizontal", scrollMode === _ui_utils.ScrollMode.HORIZONTAL);
              viewer.classList.toggle("scrollWrapped", scrollMode === _ui_utils.ScrollMode.WRAPPED);

              if (!this.pdfDocument || !pageNumber) {
                return;
              }

              if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
                this._setScale(this._currentScaleValue, true);
              }

              this._setCurrentPageNumber(pageNumber, true);

              this.update();
            }
          }, {
            key: "spreadMode",
            get: function get() {
              return this._spreadMode;
            },
            set: function set(mode) {
              if (this._spreadMode === mode) {
                return;
              }

              if (!(0, _ui_utils.isValidSpreadMode)(mode)) {
                throw new Error("Invalid spread mode: ".concat(mode));
              }

              this._spreadMode = mode;
              this.eventBus.dispatch("spreadmodechanged", {
                source: this,
                mode: mode
              });

              this._updateSpreadMode(this._currentPageNumber);
            }
          }, {
            key: "_updateSpreadMode",
            value: function _updateSpreadMode() {
              var pageNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

              if (!this.pdfDocument) {
                return;
              }

              var viewer = this.viewer,
                  pages = this._pages;
              viewer.textContent = "";

              if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
                for (var i = 0, iMax = pages.length; i < iMax; ++i) {
                  viewer.appendChild(pages[i].div);
                }
              } else {
                var parity = this._spreadMode - 1;
                var spread = null;

                for (var _i2 = 0, _iMax = pages.length; _i2 < _iMax; ++_i2) {
                  if (spread === null) {
                    spread = document.createElement("div");
                    spread.className = "spread";
                    viewer.appendChild(spread);
                  } else if (_i2 % 2 === parity) {
                    spread = spread.cloneNode(false);
                    viewer.appendChild(spread);
                  }

                  spread.appendChild(pages[_i2].div);
                }
              }

              if (!pageNumber) {
                return;
              }

              if (this._currentScaleValue && isNaN(this._currentScaleValue)) {
                this._setScale(this._currentScaleValue, true);
              }

              this._setCurrentPageNumber(pageNumber, true);

              this.update();
            }
          }, {
            key: "_getPageAdvance",
            value: function _getPageAdvance(currentPageNumber) {
              var previous = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

              if (this.isInPresentationMode) {
                return 1;
              }

              switch (this._scrollMode) {
                case _ui_utils.ScrollMode.WRAPPED:
                  {
                    var _this$_getVisiblePage = this._getVisiblePages(),
                        views = _this$_getVisiblePage.views,
                        pageLayout = new Map();

                    var _iterator15 = _createForOfIteratorHelper(views),
                        _step15;

                    try {
                      for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                        var _step15$value = _step15.value,
                            id = _step15$value.id,
                            y = _step15$value.y,
                            percent = _step15$value.percent,
                            widthPercent = _step15$value.widthPercent;

                        if (percent === 0 || widthPercent < 100) {
                          continue;
                        }

                        var yArray = pageLayout.get(y);

                        if (!yArray) {
                          pageLayout.set(y, yArray || (yArray = []));
                        }

                        yArray.push(id);
                      }
                    } catch (err) {
                      _iterator15.e(err);
                    } finally {
                      _iterator15.f();
                    }

                    var _iterator16 = _createForOfIteratorHelper(pageLayout.values()),
                        _step16;

                    try {
                      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
                        var _yArray = _step16.value;

                        var currentIndex = _yArray.indexOf(currentPageNumber);

                        if (currentIndex === -1) {
                          continue;
                        }

                        var numPages = _yArray.length;

                        if (numPages === 1) {
                          break;
                        }

                        if (previous) {
                          for (var i = currentIndex - 1, ii = 0; i >= ii; i--) {
                            var currentId = _yArray[i],
                                expectedId = _yArray[i + 1] - 1;

                            if (currentId < expectedId) {
                              return currentPageNumber - expectedId;
                            }
                          }
                        } else {
                          for (var _i3 = currentIndex + 1, _ii = numPages; _i3 < _ii; _i3++) {
                            var _currentId = _yArray[_i3],
                                _expectedId = _yArray[_i3 - 1] + 1;

                            if (_currentId > _expectedId) {
                              return _expectedId - currentPageNumber;
                            }
                          }
                        }

                        if (previous) {
                          var firstId = _yArray[0];

                          if (firstId < currentPageNumber) {
                            return currentPageNumber - firstId + 1;
                          }
                        } else {
                          var lastId = _yArray[numPages - 1];

                          if (lastId > currentPageNumber) {
                            return lastId - currentPageNumber + 1;
                          }
                        }

                        break;
                      }
                    } catch (err) {
                      _iterator16.e(err);
                    } finally {
                      _iterator16.f();
                    }

                    break;
                  }

                case _ui_utils.ScrollMode.HORIZONTAL:
                  {
                    break;
                  }

                case _ui_utils.ScrollMode.VERTICAL:
                  {
                    if (this._spreadMode === _ui_utils.SpreadMode.NONE) {
                      break;
                    }

                    var parity = this._spreadMode - 1;

                    if (previous && currentPageNumber % 2 !== parity) {
                      break;
                    } else if (!previous && currentPageNumber % 2 === parity) {
                      break;
                    }

                    var _this$_getVisiblePage2 = this._getVisiblePages(),
                        _views = _this$_getVisiblePage2.views,
                        _expectedId2 = previous ? currentPageNumber - 1 : currentPageNumber + 1;

                    var _iterator17 = _createForOfIteratorHelper(_views),
                        _step17;

                    try {
                      for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
                        var _step17$value = _step17.value,
                            _id = _step17$value.id,
                            _percent = _step17$value.percent,
                            _widthPercent = _step17$value.widthPercent;

                        if (_id !== _expectedId2) {
                          continue;
                        }

                        if (_percent > 0 && _widthPercent === 100) {
                          return 2;
                        }

                        break;
                      }
                    } catch (err) {
                      _iterator17.e(err);
                    } finally {
                      _iterator17.f();
                    }

                    break;
                  }
              }

              return 1;
            }
          }, {
            key: "nextPage",
            value: function nextPage() {
              var currentPageNumber = this._currentPageNumber,
                  pagesCount = this.pagesCount;

              if (currentPageNumber >= pagesCount) {
                return false;
              }

              var advance = this._getPageAdvance(currentPageNumber, false) || 1;
              this.currentPageNumber = Math.min(currentPageNumber + advance, pagesCount);
              return true;
            }
          }, {
            key: "previousPage",
            value: function previousPage() {
              var currentPageNumber = this._currentPageNumber;

              if (currentPageNumber <= 1) {
                return false;
              }

              var advance = this._getPageAdvance(currentPageNumber, true) || 1;
              this.currentPageNumber = Math.max(currentPageNumber - advance, 1);
              return true;
            }
          }, {
            key: "increaseScale",
            value: function increaseScale() {
              var steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
              var newScale = this._currentScale;

              do {
                newScale = (newScale * _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2);
                newScale = Math.ceil(newScale * 10) / 10;
                newScale = Math.min(_ui_utils.MAX_SCALE, newScale);
              } while (--steps > 0 && newScale < _ui_utils.MAX_SCALE);

              this.currentScaleValue = newScale;
            }
          }, {
            key: "decreaseScale",
            value: function decreaseScale() {
              var steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
              var newScale = this._currentScale;

              do {
                newScale = (newScale / _ui_utils.DEFAULT_SCALE_DELTA).toFixed(2);
                newScale = Math.floor(newScale * 10) / 10;
                newScale = Math.max(_ui_utils.MIN_SCALE, newScale);
              } while (--steps > 0 && newScale > _ui_utils.MIN_SCALE);

              this.currentScaleValue = newScale;
            }
          }]);

          return BaseViewer;
        }();

        exports.BaseViewer = BaseViewer;
        /***/
      },
      /* 22 */

      /***/
      function (__unused_webpack_module, exports) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.TextHighlighter = void 0;

        var TextHighlighter = /*#__PURE__*/function () {
          function TextHighlighter(_ref31) {
            var findController = _ref31.findController,
                eventBus = _ref31.eventBus,
                pageIndex = _ref31.pageIndex;

            _classCallCheck(this, TextHighlighter);

            this.findController = findController;
            this.matches = [];
            this.eventBus = eventBus;
            this.pageIdx = pageIndex;
            this._onUpdateTextLayerMatches = null;
            this.textDivs = null;
            this.textContentItemsStr = null;
            this.enabled = false;
          }

          _createClass(TextHighlighter, [{
            key: "setTextMapping",
            value: function setTextMapping(divs, texts) {
              this.textDivs = divs;
              this.textContentItemsStr = texts;
            }
          }, {
            key: "enable",
            value: function enable() {
              var _this28 = this;

              if (!this.textDivs || !this.textContentItemsStr) {
                throw new Error("Text divs and strings have not been set.");
              }

              if (this.enabled) {
                throw new Error("TextHighlighter is already enabled.");
              }

              this.enabled = true;

              if (!this._onUpdateTextLayerMatches) {
                this._onUpdateTextLayerMatches = function (evt) {
                  if (evt.pageIndex === _this28.pageIdx || evt.pageIndex === -1) {
                    _this28._updateMatches();
                  }
                };

                this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches);
              }

              this._updateMatches();
            }
          }, {
            key: "disable",
            value: function disable() {
              if (!this.enabled) {
                return;
              }

              this.enabled = false;

              if (this._onUpdateTextLayerMatches) {
                this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches);

                this._onUpdateTextLayerMatches = null;
              }
            }
          }, {
            key: "_convertMatches",
            value: function _convertMatches(matches, matchesLength) {
              if (!matches) {
                return [];
              }

              var textContentItemsStr = this.textContentItemsStr;
              var i = 0,
                  iIndex = 0;
              var end = textContentItemsStr.length - 1;
              var result = [];

              for (var m = 0, mm = matches.length; m < mm; m++) {
                var matchIdx = matches[m];

                while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {
                  iIndex += textContentItemsStr[i].length;
                  i++;
                }

                if (i === textContentItemsStr.length) {
                  console.error("Could not find a matching mapping");
                }

                var match = {
                  begin: {
                    divIdx: i,
                    offset: matchIdx - iIndex
                  }
                };
                matchIdx += matchesLength[m];

                while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {
                  iIndex += textContentItemsStr[i].length;
                  i++;
                }

                match.end = {
                  divIdx: i,
                  offset: matchIdx - iIndex
                };
                result.push(match);
              }

              return result;
            }
          }, {
            key: "_renderMatches",
            value: function _renderMatches(matches) {
              if (matches.length === 0) {
                return;
              }

              var findController = this.findController,
                  pageIdx = this.pageIdx;
              var textContentItemsStr = this.textContentItemsStr,
                  textDivs = this.textDivs;
              var isSelectedPage = pageIdx === findController.selected.pageIdx;
              var selectedMatchIdx = findController.selected.matchIdx;
              var highlightAll = findController.state.highlightAll;
              var prevEnd = null;
              var infinity = {
                divIdx: -1,
                offset: undefined
              };

              function beginText(begin, className) {
                var divIdx = begin.divIdx;
                textDivs[divIdx].textContent = "";
                return appendTextToDiv(divIdx, 0, begin.offset, className);
              }

              function appendTextToDiv(divIdx, fromOffset, toOffset, className) {
                var div = textDivs[divIdx];

                if (div.nodeType === Node.TEXT_NODE) {
                  var span = document.createElement("span");
                  div.parentNode.insertBefore(span, div);
                  span.appendChild(div);
                  textDivs[divIdx] = span;
                  div = span;
                }

                var content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);
                var node = document.createTextNode(content);

                if (className) {
                  var _span = document.createElement("span");

                  _span.className = "".concat(className, " appended");

                  _span.appendChild(node);

                  div.appendChild(_span);
                  return className.includes("selected") ? _span.offsetLeft : 0;
                }

                div.appendChild(node);
                return 0;
              }

              var i0 = selectedMatchIdx,
                  i1 = i0 + 1;

              if (highlightAll) {
                i0 = 0;
                i1 = matches.length;
              } else if (!isSelectedPage) {
                return;
              }

              for (var i = i0; i < i1; i++) {
                var match = matches[i];
                var begin = match.begin;
                var end = match.end;
                var isSelected = isSelectedPage && i === selectedMatchIdx;
                var highlightSuffix = isSelected ? " selected" : "";
                var selectedLeft = 0;

                if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {
                  if (prevEnd !== null) {
                    appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
                  }

                  beginText(begin);
                } else {
                  appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);
                }

                if (begin.divIdx === end.divIdx) {
                  selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix);
                } else {
                  selectedLeft = appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix);

                  for (var n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {
                    textDivs[n0].className = "highlight middle" + highlightSuffix;
                  }

                  beginText(end, "highlight end" + highlightSuffix);
                }

                prevEnd = end;

                if (isSelected) {
                  findController.scrollMatchIntoView({
                    element: textDivs[begin.divIdx],
                    selectedLeft: selectedLeft,
                    pageIndex: pageIdx,
                    matchIndex: selectedMatchIdx
                  });
                }
              }

              if (prevEnd) {
                appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);
              }
            }
          }, {
            key: "_updateMatches",
            value: function _updateMatches() {
              if (!this.enabled) {
                return;
              }

              var findController = this.findController,
                  matches = this.matches,
                  pageIdx = this.pageIdx;
              var textContentItemsStr = this.textContentItemsStr,
                  textDivs = this.textDivs;
              var clearedUntilDivIdx = -1;

              for (var i = 0, ii = matches.length; i < ii; i++) {
                var match = matches[i];
                var begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);

                for (var n = begin, end = match.end.divIdx; n <= end; n++) {
                  var div = textDivs[n];
                  div.textContent = textContentItemsStr[n];
                  div.className = "";
                }

                clearedUntilDivIdx = match.end.divIdx + 1;
              }

              if (!(findController !== null && findController !== void 0 && findController.highlightMatches)) {
                return;
              }

              var pageMatches = findController.pageMatches[pageIdx] || null;
              var pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;
              this.matches = this._convertMatches(pageMatches, pageMatchesLength);

              this._renderMatches(this.matches);
            }
          }]);

          return TextHighlighter;
        }();

        exports.TextHighlighter = TextHighlighter;
        /***/
      },
      /* 23 */

      /***/
      function (__unused_webpack_module, exports, __w_pdfjs_require__) {
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.PDFViewer = void 0;

        var _ui_utils = __w_pdfjs_require__(5);

        var _base_viewer = __w_pdfjs_require__(21);

        var _pdfjsLib = __w_pdfjs_require__(2);

        var PDFViewer = /*#__PURE__*/function (_base_viewer$BaseView2) {
          _inherits(PDFViewer, _base_viewer$BaseView2);

          var _super3 = _createSuper(PDFViewer);

          function PDFViewer() {
            _classCallCheck(this, PDFViewer);

            return _super3.apply(this, arguments);
          }

          _createClass(PDFViewer, [{
            key: "_viewerElement",
            get: function get() {
              return (0, _pdfjsLib.shadow)(this, "_viewerElement", this.viewer);
            }
          }, {
            key: "_scrollIntoView",
            value: function _scrollIntoView(_ref32) {
              var pageDiv = _ref32.pageDiv,
                  _ref32$pageSpot = _ref32.pageSpot,
                  pageSpot = _ref32$pageSpot === void 0 ? null : _ref32$pageSpot,
                  _ref32$pageNumber = _ref32.pageNumber,
                  pageNumber = _ref32$pageNumber === void 0 ? null : _ref32$pageNumber;

              if (!pageSpot && !this.isInPresentationMode) {
                var left = pageDiv.offsetLeft + pageDiv.clientLeft;
                var right = left + pageDiv.clientWidth;
                var _this$container2 = this.container,
                    scrollLeft = _this$container2.scrollLeft,
                    clientWidth = _this$container2.clientWidth;

                if (this._isScrollModeHorizontal || left < scrollLeft || right > scrollLeft + clientWidth) {
                  pageSpot = {
                    left: 0,
                    top: 0
                  };
                }
              }

              _get2(_getPrototypeOf(PDFViewer.prototype), "_scrollIntoView", this).call(this, {
                pageDiv: pageDiv,
                pageSpot: pageSpot,
                pageNumber: pageNumber
              });
            }
          }, {
            key: "_getVisiblePages",
            value: function _getVisiblePages() {
              if (this.isInPresentationMode) {
                return this._getCurrentVisiblePage();
              }

              return _get2(_getPrototypeOf(PDFViewer.prototype), "_getVisiblePages", this).call(this);
            }
          }, {
            key: "_updateHelper",
            value: function _updateHelper(visiblePages) {
              if (this.isInPresentationMode) {
                return;
              }

              var currentId = this._currentPageNumber;
              var stillFullyVisible = false;

              var _iterator18 = _createForOfIteratorHelper(visiblePages),
                  _step18;

              try {
                for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {
                  var page = _step18.value;

                  if (page.percent < 100) {
                    break;
                  }

                  if (page.id === currentId && this._scrollMode === _ui_utils.ScrollMode.VERTICAL && this._spreadMode === _ui_utils.SpreadMode.NONE) {
                    stillFullyVisible = true;
                    break;
                  }
                }
              } catch (err) {
                _iterator18.e(err);
              } finally {
                _iterator18.f();
              }

              if (!stillFullyVisible) {
                currentId = visiblePages[0].id;
              }

              this._setCurrentPageNumber(currentId);
            }
          }]);

          return PDFViewer;
        }(_base_viewer.BaseViewer);

        exports.PDFViewer = PDFViewer;
        /***/
      }
      /******/
      ];
      /************************************************************************/

      /******/
      // The module cache

      /******/

      var __webpack_module_cache__ = {};
      /******/

      /******/
      // The require function

      /******/

      function __w_pdfjs_require__(moduleId) {
        /******/
        // Check if module is in cache

        /******/
        var cachedModule = __webpack_module_cache__[moduleId];
        /******/

        if (cachedModule !== undefined) {
          /******/
          return cachedModule.exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = __webpack_module_cache__[moduleId] = {
          /******/
          // no module.id needed

          /******/
          // no module.loaded needed

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        __webpack_modules__[moduleId](module, module.exports, __w_pdfjs_require__);
        /******/

        /******/
        // Return the exports of the module

        /******/


        return module.exports;
        /******/
      }
      /******/

      /************************************************************************/


      var __webpack_exports__ = {}; // This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.

      (function () {
        var exports = __webpack_exports__;
        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        Object.defineProperty(exports, "AnnotationLayerBuilder", {
          enumerable: true,
          get: function get() {
            return _annotation_layer_builder.AnnotationLayerBuilder;
          }
        });
        Object.defineProperty(exports, "DefaultAnnotationLayerFactory", {
          enumerable: true,
          get: function get() {
            return _annotation_layer_builder.DefaultAnnotationLayerFactory;
          }
        });
        Object.defineProperty(exports, "DefaultStructTreeLayerFactory", {
          enumerable: true,
          get: function get() {
            return _struct_tree_layer_builder.DefaultStructTreeLayerFactory;
          }
        });
        Object.defineProperty(exports, "StructTreeLayerBuilder", {
          enumerable: true,
          get: function get() {
            return _struct_tree_layer_builder.StructTreeLayerBuilder;
          }
        });
        Object.defineProperty(exports, "DefaultTextLayerFactory", {
          enumerable: true,
          get: function get() {
            return _text_layer_builder.DefaultTextLayerFactory;
          }
        });
        Object.defineProperty(exports, "TextLayerBuilder", {
          enumerable: true,
          get: function get() {
            return _text_layer_builder.TextLayerBuilder;
          }
        });
        Object.defineProperty(exports, "DefaultXfaLayerFactory", {
          enumerable: true,
          get: function get() {
            return _xfa_layer_builder.DefaultXfaLayerFactory;
          }
        });
        Object.defineProperty(exports, "XfaLayerBuilder", {
          enumerable: true,
          get: function get() {
            return _xfa_layer_builder.XfaLayerBuilder;
          }
        });
        Object.defineProperty(exports, "EventBus", {
          enumerable: true,
          get: function get() {
            return _ui_utils.EventBus;
          }
        });
        Object.defineProperty(exports, "ProgressBar", {
          enumerable: true,
          get: function get() {
            return _ui_utils.ProgressBar;
          }
        });
        Object.defineProperty(exports, "PDFLinkService", {
          enumerable: true,
          get: function get() {
            return _pdf_link_service.PDFLinkService;
          }
        });
        Object.defineProperty(exports, "SimpleLinkService", {
          enumerable: true,
          get: function get() {
            return _pdf_link_service.SimpleLinkService;
          }
        });
        Object.defineProperty(exports, "DownloadManager", {
          enumerable: true,
          get: function get() {
            return _download_manager.DownloadManager;
          }
        });
        Object.defineProperty(exports, "GenericL10n", {
          enumerable: true,
          get: function get() {
            return _genericl10n.GenericL10n;
          }
        });
        Object.defineProperty(exports, "NullL10n", {
          enumerable: true,
          get: function get() {
            return _l10n_utils.NullL10n;
          }
        });
        Object.defineProperty(exports, "PDFFindController", {
          enumerable: true,
          get: function get() {
            return _pdf_find_controller.PDFFindController;
          }
        });
        Object.defineProperty(exports, "PDFHistory", {
          enumerable: true,
          get: function get() {
            return _pdf_history.PDFHistory;
          }
        });
        Object.defineProperty(exports, "PDFPageView", {
          enumerable: true,
          get: function get() {
            return _pdf_page_view.PDFPageView;
          }
        });
        Object.defineProperty(exports, "PDFScriptingManager", {
          enumerable: true,
          get: function get() {
            return _pdf_scripting_manager.PDFScriptingManager;
          }
        });
        Object.defineProperty(exports, "PDFSinglePageViewer", {
          enumerable: true,
          get: function get() {
            return _pdf_single_page_viewer.PDFSinglePageViewer;
          }
        });
        Object.defineProperty(exports, "PDFViewer", {
          enumerable: true,
          get: function get() {
            return _pdf_viewer.PDFViewer;
          }
        });

        var _annotation_layer_builder = __w_pdfjs_require__(1);

        var _struct_tree_layer_builder = __w_pdfjs_require__(6);

        var _text_layer_builder = __w_pdfjs_require__(7);

        var _xfa_layer_builder = __w_pdfjs_require__(8);

        var _ui_utils = __w_pdfjs_require__(5);

        var _pdf_link_service = __w_pdfjs_require__(4);

        var _download_manager = __w_pdfjs_require__(9);

        var _genericl10n = __w_pdfjs_require__(11);

        var _l10n_utils = __w_pdfjs_require__(3);

        var _pdf_find_controller = __w_pdfjs_require__(13);

        var _pdf_history = __w_pdfjs_require__(15);

        var _pdf_page_view = __w_pdfjs_require__(16);

        var _pdf_scripting_manager = __w_pdfjs_require__(18);

        var _pdf_single_page_viewer = __w_pdfjs_require__(20);

        var _pdf_viewer = __w_pdfjs_require__(23);

        var pdfjsVersion = '2.11.338';
        var pdfjsBuild = 'dedff3c98';
      })();
      /******/


      return __webpack_exports__;
      /******/
    }()
  );
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(16)(module)))

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _download__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(25);
/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
/* harmony import */ var _print__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_print__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }







var Toolbar = /*#__PURE__*/function (_React$Component) {
  _inherits(Toolbar, _React$Component);

  var _super = _createSuper(Toolbar);

  function Toolbar(props) {
    var _this;

    _classCallCheck(this, Toolbar);

    _this = _super.apply(this, arguments);

    _defineProperty(_assertThisInitialized(_this), "startBeforePrint", function () {
      _this.printing = true;
      _this.pageStyleSheet = document.createElement('style');
      var body = document.querySelector('body');
      body.setAttribute('data-mozPrintCallback', true);

      var pageSize = _this.getPageSize();

      var width = pageSize.width,
          height = pageSize.height;
      _this.pageStyleSheet.textContent = '@supports ((size:A4) and (size:1pt 1pt)) {' + '@page { size: ' + width + 'pt ' + height + 'pt;}' + '}';
      body.appendChild(_this.pageStyleSheet);

      for (var i = 0; i < _this.props.numPages; ++i) {
        _this.props.eventBus.dispatch('beforeprint', {
          index: i
        });
      }
    });

    _defineProperty(_assertThisInitialized(_this), "beforePrint", function (e) {
      var i = e.index;
      var pdfPage = _this.props.viewers[i].page;
      var viewport = Object(_tools__WEBPACK_IMPORTED_MODULE_3__["getViewport"])(pdfPage, 1);
      var PRINT_OUTPUT_SCALE = 2;
      var canvas = document.createElement('canvas');
      canvas.width = Math.floor(viewport.width) * PRINT_OUTPUT_SCALE;
      canvas.height = Math.floor(viewport.height) * PRINT_OUTPUT_SCALE;
      canvas.style.width = PRINT_OUTPUT_SCALE * 100 + '%';
      var cssScale = 'scale(' + 1 / PRINT_OUTPUT_SCALE + ', ' + 1 / PRINT_OUTPUT_SCALE + ')';
      _tools__WEBPACK_IMPORTED_MODULE_3__["CustomStyle"].setProp('transform', canvas, cssScale);
      _tools__WEBPACK_IMPORTED_MODULE_3__["CustomStyle"].setProp('transformOrigin', canvas, '0% 0%');
      var canvasWrapper = document.createElement('div');
      canvasWrapper.appendChild(canvas);

      canvas.mozPrintCallback = function (obj) {
        var ctx = obj.context;
        ctx.save();
        ctx.fillStyle = 'rgb(255, 255, 255)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.restore();
        ctx._transformMatrix = [PRINT_OUTPUT_SCALE, 0, 0, PRINT_OUTPUT_SCALE, 0, 0];
        ctx.scale(PRINT_OUTPUT_SCALE, PRINT_OUTPUT_SCALE);
        var renderContext = {
          canvasContext: ctx,
          viewport: viewport,
          intent: 'print'
        };
        pdfPage.render(renderContext).promise.then(function () {
          obj.done();
        }, function (error) {
          window.console && console.error('page render err', error);

          if ('abort' in obj) {
            obj.abort();
          } else {
            obj.done();
          }
        });
      };

      _this.printContainer.appendChild(canvasWrapper);
    });

    _defineProperty(_assertThisInitialized(_this), "afterPrint", function () {
      var div = _this.printContainer;

      while (div.hasChildNodes()) {
        div.removeChild(div.lastChild);
      }

      if (_this.pageStyleSheet && _this.pageStyleSheet.parentNode) {
        _this.pageStyleSheet.parentNode.removeChild(_this.pageStyleSheet);

        _this.pageStyleSheet = null;
      }

      _this.printing = false;
    });

    _defineProperty(_assertThisInitialized(_this), "downloadFile", function () {
      var blob = new Blob([_this.props.docData]);
      var blobUrl = URL.createObjectURL(blob);
      Object(_download__WEBPACK_IMPORTED_MODULE_1__["download"])(blobUrl, _this.props.filename);
    });

    _defineProperty(_assertThisInitialized(_this), "getPageSize", function () {
      var width = 0;
      var height = 0;
      var _this$props = _this.props,
          numPages = _this$props.numPages,
          viewers = _this$props.viewers;

      for (var i = 0; i < numPages; i++) {
        var viewport = Object(_tools__WEBPACK_IMPORTED_MODULE_3__["getViewport"])(viewers[i].page, 2);

        if (viewport.width > width) {
          width = viewport.width;
        }

        if (viewport.height > height) {
          height = viewport.height;
        }
      }

      return {
        width: width,
        height: height
      };
    });

    _defineProperty(_assertThisInitialized(_this), "printDoc", function () {
      window.print();
    });

    _defineProperty(_assertThisInitialized(_this), "changeScale", function (e) {
      _this.props.foreceRender(true, e.target.value);

      _this.setState({
        scale: e.target.value
      });
    });

    _defineProperty(_assertThisInitialized(_this), "zoomIn", function (ticks) {
      var newScale = _this.props.scale;

      do {
        newScale = (newScale * _tools__WEBPACK_IMPORTED_MODULE_3__["DEFAULT_SCALE_DELTA"]).toFixed(2);
        newScale = Math.ceil(newScale * 10) / 10;
        newScale = Math.min(_tools__WEBPACK_IMPORTED_MODULE_3__["MAX_SCALE"], newScale);
      } while (--ticks > 0 && newScale < _tools__WEBPACK_IMPORTED_MODULE_3__["MAX_SCALE"]);

      _this.props.foreceRender(true, newScale);

      _this.setState({
        scale: newScale
      });
    });

    _defineProperty(_assertThisInitialized(_this), "zoomOut", function (ticks) {
      var newScale = _this.props.scale;

      do {
        newScale = (newScale / _tools__WEBPACK_IMPORTED_MODULE_3__["DEFAULT_SCALE_DELTA"]).toFixed(2);
        newScale = Math.floor(newScale * 10) / 10;
        newScale = Math.max(_tools__WEBPACK_IMPORTED_MODULE_3__["MIN_SCALE"], newScale);
      } while (--ticks > 0 && newScale > _tools__WEBPACK_IMPORTED_MODULE_3__["MIN_SCALE"]);

      _this.props.foreceRender(true, newScale);

      _this.setState({
        scale: newScale
      });
    });

    _defineProperty(_assertThisInitialized(_this), "goToPage", function (pageNum) {
      _this.props.goToPage(pageNum);
    });

    _defineProperty(_assertThisInitialized(_this), "onChange", function (e) {
      var num = parseInt(e.target.value);

      if (isNaN(num)) {
        num = 1;
      }

      _this.setState({
        tempPageNum: num
      });
    });

    _defineProperty(_assertThisInitialized(_this), "onConfirmPage", function (e, type) {
      var numPages = _this.props.numPages;
      var pageNum = _this.state.tempPageNum;
      pageNum = parseInt(pageNum);

      if (type === 1) {
        // 失去焦点时
        _this.setState({
          tempPageNum: ''
        });

        if (pageNum >= 1 && pageNum <= numPages) {
          _this.goToPage(pageNum);
        }
      } else if (type === 2 && e.keyCode === 13) {
        // keyDown时间回车判断
        _this.setState({
          tempPageNum: ''
        });

        if (pageNum >= 1 && pageNum <= numPages) {
          _this.goToPage(pageNum);
        }
      }
    });

    _defineProperty(_assertThisInitialized(_this), "nextPage", function () {
      var pageNum = _this.props.activePageNum;

      if (pageNum + 1 <= _this.props.numPages) {
        _this.goToPage(pageNum + 1);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "prePage", function () {
      var pageNum = _this.props.activePageNum;

      if (pageNum - 1 >= 1) {
        _this.goToPage(pageNum - 1);
      }
    });

    _this.pageNum = props.activePageNum || 1;
    _this.state = {
      scale: props.scale,
      pageNum: props.activePageNum || 1,
      tempPageNum: ''
    };
    return _this;
  }

  _createClass(Toolbar, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.printContainer = document.getElementById('printContainer');

      if (window.attachEvent) {
        window.attachEvent('beforeprint', this.startBeforePrint);
        window.attachEvent('afterprint', this.afterPrint);
      } else if (window.addEventListener) {
        window.addEventListener('beforeprint', this.startBeforePrint);
        window.addEventListener('afterprint', this.afterPrint);
      }

      this.props.eventBus.on('afterprint', this.afterPrint);
      this.props.eventBus.on('beforeprint', this.beforePrint);
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          _this$props2$percent = _this$props2.percent,
          percent = _this$props2$percent === void 0 ? 0 : _this$props2$percent,
          _this$props2$loadFile = _this$props2.loadFile,
          loadFile = _this$props2$loadFile === void 0 ? false : _this$props2$loadFile,
          numPages = _this$props2.numPages,
          filename = _this$props2.filename,
          activePageNum = _this$props2.activePageNum;
      var scale = this.state.scale;
      var tempPageNum = this.state.tempPageNum;
      var displayScale = scale;
      var list = ['auto', 'page-actual', 'page-fit', 'page-width', 0.5, 0.75, 1, 1.25, 1.5, 2, 3, 4];

      if (list.indexOf(scale) === -1) {
        displayScale = 'custom';
      }

      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "toolbar"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: "toolbarContainer"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: "toolbarViewer"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: "toolbarViewerLeft",
        className: "hiddenMediumView"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        id: "sidebarToggle",
        className: "toolbarButton",
        title: "\u5207\u6362\u4FA7\u680F",
        tabIndex: "11",
        "data-l10n-id": "toggle_sidebar",
        onClick: this.props.toggleSlide
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "toggle_sidebar_label"
      }, "\u5207\u6362\u4FA7\u680F")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "toolbarButtonSpacer"
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "splitToolbarButton"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        className: "toolbarButton pageUp",
        title: "\u4E0A\u4E00\u9875",
        id: "previous",
        tabIndex: "13",
        "data-l10n-id": "previous",
        disabled: activePageNum <= 1,
        onClick: this.prePage
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "previous_label"
      }, "\u4E0A\u4E00\u9875")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "splitToolbarButtonSeparator"
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        className: "toolbarButton pageDown",
        title: "\u4E0B\u4E00\u9875",
        id: "next",
        tabIndex: "14",
        "data-l10n-id": "next",
        disabled: activePageNum >= numPages,
        onClick: this.nextPage
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "next_label"
      }, "\u4E0B\u4E00\u9875"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("label", {
        id: "pageNumberLabel",
        className: "toolbarLabel pageNumber",
        "data-l10n-id": "page_label"
      }, "\u9875\u9762\uFF1A"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("input", {
        type: "number",
        id: "pageNumber",
        className: "toolbarField pageNumber loading",
        value: tempPageNum || activePageNum,
        size: "4",
        min: "1",
        tabIndex: "15",
        max: numPages,
        onChange: this.onChange,
        onBlur: function onBlur(e) {
          return _this2.onConfirmPage(e, 1);
        },
        onKeyDown: function onKeyDown(e) {
          return _this2.onConfirmPage(e, 2);
        }
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        id: "numPages",
        className: "toolbarLabel"
      }, "/", numPages)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        className: "filename"
      }, filename), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: "toolbarViewerRight"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        id: "print",
        className: "toolbarButton print hiddenMediumView",
        title: "\u6253\u53701",
        tabIndex: "33",
        "data-l10n-id": "print",
        onClick: this.printDoc
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "print_label"
      }, "\u6253\u5370")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        onClick: this.downloadFile,
        id: "download",
        className: "toolbarButton download",
        title: "\u4E0B\u8F7D",
        tabIndex: "34",
        "data-l10n-id": "download"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "download_label"
      }, "\u4E0B\u8F7D")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "verticalToolbarSeparator hiddenSmallView",
        style: {
          display: 'none'
        }
      })), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "outerCenter hiddenMediumView"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "innerCenter",
        id: "toolbarViewerMiddle"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "splitToolbarButton"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        disabled: scale <= _tools__WEBPACK_IMPORTED_MODULE_3__["MIN_SCALE"],
        id: "zoomOut",
        className: "toolbarButton zoomOut",
        title: "\u7F29\u5C0F",
        tabIndex: "21",
        "data-l10n-id": "zoom_out",
        onClick: this.zoomOut
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "zoom_out_label"
      }, "\u7F29\u5C0F")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "splitToolbarButtonSeparator"
      }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        disabled: scale >= _tools__WEBPACK_IMPORTED_MODULE_3__["MAX_SCALE"],
        id: "zoomIn",
        className: "toolbarButton zoomIn",
        title: "\u653E\u5927",
        tabIndex: "22",
        "data-l10n-id": "zoom_in",
        onClick: this.zoomIn
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "zoom_in_label"
      }, "\u653E\u5927"))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        id: "scaleSelectContainer",
        className: "dropdownToolbarButton",
        style: {
          minWidth: '82px',
          maxWidth: '82px'
        }
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("select", {
        id: "scaleSelect",
        title: "\u7F29\u653E",
        tabIndex: "23",
        "data-l10n-id": "zoom",
        style: {
          minWidth: '104px'
        },
        value: displayScale,
        onChange: this.changeScale
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        id: "pageAutoOption",
        title: "",
        value: "auto",
        "data-l10n-id": "page_scale_auto"
      }, "\u81EA\u52A8\u7F29\u653E"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        id: "pageActualOption",
        title: "",
        value: "page-actual",
        "data-l10n-id": "page_scale_actual"
      }, "\u5B9E\u9645\u5927\u5C0F"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        id: "pageFitOption",
        title: "",
        value: "page-fit",
        "data-l10n-id": "page_scale_fit"
      }, "\u9002\u5408\u9875\u9762"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        id: "pageWidthOption",
        title: "",
        value: "page-width",
        "data-l10n-id": "page_scale_width"
      }, "\u9002\u5408\u9875\u5BBD"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        id: "customScaleOption",
        title: "",
        value: "custom"
      }, parseInt(scale * 100) + '%'), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        title: "",
        value: "0.5",
        "data-l10n-id": "page_scale_percent",
        "data-l10n-args": "{ \"scale\": 50 }"
      }, "50%"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        title: "",
        value: "0.75",
        "data-l10n-id": "page_scale_percent",
        "data-l10n-args": "{ \"scale\": 75 }"
      }, "75%"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        title: "",
        value: "1",
        "data-l10n-id": "page_scale_percent",
        "data-l10n-args": "{ \"scale\": 100 }"
      }, "100%"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        title: "",
        value: "1.25",
        "data-l10n-id": "page_scale_percent",
        "data-l10n-args": "{ \"scale\": 125 }"
      }, "125%"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        title: "",
        value: "1.5",
        "data-l10n-id": "page_scale_percent",
        "data-l10n-args": "{ \"scale\": 150 }"
      }, "150%"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        title: "",
        value: "2",
        "data-l10n-id": "page_scale_percent",
        "data-l10n-args": "{ \"scale\": 200 }"
      }, "200%"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        title: "",
        value: "3",
        "data-l10n-id": "page_scale_percent",
        "data-l10n-args": "{ \"scale\": 300 }"
      }, "300%"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("option", {
        title: "",
        value: "4",
        "data-l10n-id": "page_scale_percent",
        "data-l10n-args": "{ \"scale\": 400 }"
      }, "400%")))))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: "loadingBar",
        className: loadFile ? '' : 'hidden'
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "progress",
        style: {
          height: '100%',
          width: percent + '%'
        }
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "glimmer"
      })))));
    }
  }]);

  return Toolbar;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

Toolbar.propTypes = {
  activePageNum: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number,
  scale: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number]),
  eventBus: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
  numPages: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number,
  viewers: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.array,
  docData: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.object,
  toggleSlide: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
  filename: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,
  foreceRender: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
  goToPage: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func,
  percent: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number]),
  loadFile: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool
};
/* harmony default export */ __webpack_exports__["default"] = (Toolbar);

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "download", function() { return download; });
function download(blobUrl, filename) {
  var a = document.createElement('a');

  if (a.click) {
    a.href = blobUrl;
    a.target = '_parent';

    if ('download' in a) {
      a.download = filename;
    }

    (document.body || document.documentElement).appendChild(a);
    a.click();
    a.parentNode.removeChild(a);
  } else {
    if (window.top === window && blobUrl.split('#')[0] === window.location.href.split('#')[0]) {
      var padCharacter = blobUrl.indexOf('?') === -1 ? '?' : '&';
      blobUrl = blobUrl.replace(/#|$/, padCharacter + '$&');
    }

    window.open(blobUrl, '_parent');
  }
}

/***/ }),
/* 26 */
/***/ (function(module, exports) {

(function () {
  if ('mozPrintCallback' in document.createElement('canvas')) {
    return;
  }

  if ('onbeforeprint' in window) {
    var stopPropagationIfNeeded = function stopPropagationIfNeeded(event) {
      if (event.detail !== 'custom' && event.stopImmediatePropagation) {
        event.stopImmediatePropagation();
      }
    };

    window.addEventListener('beforeprint', stopPropagationIfNeeded, false);
    window.addEventListener('afterprint', stopPropagationIfNeeded, false);
  }

  HTMLCanvasElement.prototype.mozPrintCallback = undefined;
  var canvases;
  var index;
  var print = window.print;

  window.print = function print() {
    if (canvases) {
      console.warn('Ignored window.print() because of a pending print job.');
      return;
    }

    try {
      dispatchEvent('beforeprint');
    } finally {
      canvases = document.querySelectorAll('canvas');
      index = -1;
      next();
    }
  };

  function dispatchEvent(eventType) {
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(eventType, false, false, 'custom');
    window.dispatchEvent(event);
  }

  function next() {
    if (!canvases) {
      return;
    }

    renderProgress();

    if (++index < canvases.length) {
      var canvas = canvases[index];

      if (typeof canvas.mozPrintCallback === 'function') {
        canvas.mozPrintCallback({
          context: canvas.getContext('2d'),
          abort: abort,
          done: next
        });
      } else {
        next();
      }
    } else {
      renderProgress();
      setTimeout(function () {
        if (!canvases) {
          return;
        }

        print.call(window);
        setTimeout(abort, 20);
      }, 0);
    }
  }

  function abort() {
    if (canvases) {
      canvases = null;
      renderProgress();
      dispatchEvent('afterprint');
    }
  }

  function renderProgress() {
    var progressContainer = document.getElementById('mozPrintCallback-shim');

    if (canvases && canvases.length) {
      var progress = Math.round(100 * index / canvases.length);
      var progressBar = progressContainer.querySelector('progress');
      var progressPerc = progressContainer.querySelector('.relative-progress');
      progressBar.value = progress;
      progressPerc.textContent = progress + '%';
      progressContainer.removeAttribute('hidden');
      progressContainer.onclick = abort;
    } else {
      progressContainer.setAttribute('hidden', '');
    }
  }
})();

/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_SCALE", function() { return DEFAULT_SCALE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_AUTO_SCALE", function() { return MAX_AUTO_SCALE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SCROLLBAR_PADDING", function() { return SCROLLBAR_PADDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTICAL_PADDING", function() { return VERTICAL_PADDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_UNITS", function() { return CSS_UNITS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_SCALE_DELTA", function() { return DEFAULT_SCALE_DELTA; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIN_SCALE", function() { return MIN_SCALE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_SCALE", function() { return MAX_SCALE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "THUMBNAIL_WIDTH", function() { return THUMBNAIL_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomStyle", function() { return CustomStyle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Util", function() { return Util; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PageViewport", function() { return PageViewport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getViewport", function() { return getViewport; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "approximateFraction", function() { return approximateFraction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundToDivide", function() { return roundToDivide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "binarySearchFirstItem", function() { return binarySearchFirstItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVisibleElements", function() { return getVisibleElements; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOutputScale", function() { return getOutputScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCanvasCSSWH", function() { return getCanvasCSSWH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScale", function() { return getScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "watchScroll", function() { return watchScroll; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDownloadInfo", function() { return getDownloadInfo; });
var DEFAULT_SCALE = 1.0;
var MAX_AUTO_SCALE = 1.25;
var SCROLLBAR_PADDING = 40;
var VERTICAL_PADDING = 5;
var CSS_UNITS = 96.0 / 72.0;
var DEFAULT_SCALE_DELTA = 1.1;
var MIN_SCALE = 0.25;
var MAX_SCALE = 10.0;
var THUMBNAIL_WIDTH = 90;
var CustomStyle = function CustomStyleClosure() {
  var prefixes = ['ms', 'Moz', 'Webkit', 'O'];

  var _cache = Object.create(null);

  function CustomStyle() {}

  CustomStyle.getProp = function get(propName, element) {
    if (arguments.length === 1 && typeof _cache[propName] === 'string') {
      return _cache[propName];
    }

    element = element || document.documentElement;
    var style = element.style;
    var prefixed;
    var uPropName;

    if (typeof style[propName] === 'string') {
      return _cache[propName] = propName;
    }

    uPropName = propName.charAt(0).toUpperCase() + propName.slice(1);

    for (var i = 0, l = prefixes.length; i < l; i++) {
      prefixed = prefixes[i] + uPropName;

      if (typeof style[prefixed] === 'string') {
        return _cache[propName] = prefixed;
      }
    }

    return _cache[propName] = 'undefined';
  };

  CustomStyle.setProp = function set(propName, element, str) {
    var prop = this.getProp(propName);

    if (prop !== 'undefined') {
      element.style[prop] = str;
    }
  };

  return CustomStyle;
}();
var Util = function UtilClosure() {
  function Util() {}

  var rgbBuf = ['rgb(', 0, ',', 0, ',', 0, ')'];

  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {
    rgbBuf[1] = r;
    rgbBuf[3] = g;
    rgbBuf[5] = b;
    return rgbBuf.join('');
  };

  Util.transform = function Util_transform(m1, m2) {
    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
  };

  Util.applyTransform = function Util_applyTransform(p, m) {
    var xt = p[0] * m[0] + p[1] * m[2] + m[4];
    var yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  };

  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {
    var d = m[0] * m[3] - m[1] * m[2];
    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  };

  Util.getAxialAlignedBoundingBox = function Util_getAxialAlignedBoundingBox(r, m) {
    var p1 = Util.applyTransform(r, m);
    var p2 = Util.applyTransform(r.slice(2, 4), m);
    var p3 = Util.applyTransform([r[0], r[3]], m);
    var p4 = Util.applyTransform([r[2], r[1]], m);
    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];
  };

  Util.inverseTransform = function Util_inverseTransform(m) {
    var d = m[0] * m[3] - m[1] * m[2];
    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
  };

  Util.apply3dTransform = function Util_apply3dTransform(m, v) {
    return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];
  };

  Util.singularValueDecompose2dScale = function Util_singularValueDecompose2dScale(m) {
    var transpose = [m[0], m[2], m[1], m[3]];
    var a = m[0] * transpose[0] + m[1] * transpose[2];
    var b = m[0] * transpose[1] + m[1] * transpose[3];
    var c = m[2] * transpose[0] + m[3] * transpose[2];
    var d = m[2] * transpose[1] + m[3] * transpose[3];
    var first = (a + d) / 2;
    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;
    var sx = first + second || 1;
    var sy = first - second || 1;
    return [Math.sqrt(sx), Math.sqrt(sy)];
  };

  Util.normalizeRect = function Util_normalizeRect(rect) {
    var r = rect.slice(0);

    if (rect[0] > rect[2]) {
      r[0] = rect[2];
      r[2] = rect[0];
    }

    if (rect[1] > rect[3]) {
      r[1] = rect[3];
      r[3] = rect[1];
    }

    return r;
  };

  Util.intersect = function Util_intersect(rect1, rect2) {
    function compare(a, b) {
      return a - b;
    }

    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);
    var orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);
    var result = [];
    rect1 = Util.normalizeRect(rect1);
    rect2 = Util.normalizeRect(rect2);

    if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {
      result[0] = orderedX[1];
      result[2] = orderedX[2];
    } else {
      return false;
    }

    if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {
      result[1] = orderedY[1];
      result[3] = orderedY[2];
    } else {
      return false;
    }

    return result;
  };

  Util.sign = function Util_sign(num) {
    return num < 0 ? -1 : 1;
  };

  var ROMAN_NUMBER_MAP = ['', 'C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM', '', 'X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC', '', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];

  Util.toRoman = function Util_toRoman(number, lowerCase) {
    var pos;
    var romanBuf = [];

    while (number >= 1000) {
      number -= 1000;
      romanBuf.push('M');
    }

    pos = number / 100 | 0;
    number %= 100;
    romanBuf.push(ROMAN_NUMBER_MAP[pos]);
    pos = number / 10 | 0;
    number %= 10;
    romanBuf.push(ROMAN_NUMBER_MAP[10 + pos]);
    romanBuf.push(ROMAN_NUMBER_MAP[20 + number]);
    var romanStr = romanBuf.join('');
    return lowerCase ? romanStr.toLowerCase() : romanStr;
  };

  Util.appendToArray = function Util_appendToArray(arr1, arr2) {
    Array.prototype.push.apply(arr1, arr2);
  };

  Util.prependToArray = function Util_prependToArray(arr1, arr2) {
    Array.prototype.unshift.apply(arr1, arr2);
  };

  Util.extendObj = function extendObj(obj1, obj2) {
    for (var key in obj2) {
      obj1[key] = obj2[key];
    }
  };

  Util.getInheritableProperty = function Util_getInheritableProperty(dict, name) {
    while (dict && !dict.has(name)) {
      dict = dict.get('Parent');
    }

    if (!dict) {
      return null;
    }

    return dict.get(name);
  };

  Util.inherit = function Util_inherit(sub, base, prototype) {
    sub.prototype = Object.create(base.prototype);
    sub.prototype.constructor = sub;

    for (var prop in prototype) {
      sub.prototype[prop] = prototype[prop];
    }
  };

  Util.loadScript = function Util_loadScript(src, callback) {
    var script = document.createElement('script');
    var loaded = false;
    script.setAttribute('src', src);

    if (callback) {
      script.onload = function () {
        if (!loaded) {
          callback();
        }

        loaded = true;
      };
    }

    document.getElementsByTagName('head')[0].appendChild(script);
  };

  return Util;
}();
var PageViewport = function PageViewportClosure() {
  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    var centerX = (viewBox[2] + viewBox[0]) / 2;
    var centerY = (viewBox[3] + viewBox[1]) / 2;
    var rotateA, rotateB, rotateC, rotateD;
    rotation = rotation % 360;
    rotation = rotation < 0 ? rotation + 360 : rotation;

    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;

      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;

      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;

      default:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
    }

    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }

    var offsetCanvasX, offsetCanvasY;
    var width, height;

    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = Math.abs(viewBox[3] - viewBox[1]) * scale;
      height = Math.abs(viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = Math.abs(viewBox[2] - viewBox[0]) * scale;
      height = Math.abs(viewBox[3] - viewBox[1]) * scale;
    }

    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
    this.width = width;
    this.height = height;
    this.fontScale = scale;
  }

  PageViewport.prototype = {
    clone: function PageViewPort_clone(args) {
      args = args || {};
      var scale = 'scale' in args ? args.scale : this.scale;
      var rotation = 'rotation' in args ? args.rotation : this.rotation;
      return new PageViewport(this.viewBox.slice(), scale, rotation, this.offsetX, this.offsetY, args.dontFlip);
    },
    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {
      return Util.applyTransform([x, y], this.transform);
    },
    convertToViewportRectangle: function PageViewport_convertToViewportRectangle(rect) {
      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);
      var br = Util.applyTransform([rect[2], rect[3]], this.transform);
      return [tl[0], tl[1], br[0], br[1]];
    },
    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {
      return Util.applyInverseTransform([x, y], this.transform);
    }
  };
  return PageViewport;
}();
function getViewport(pageInfo, scale, rotate) {
  if (arguments.length < 3) {
    rotate = pageInfo.view.rotate;
  }

  return new PageViewport(pageInfo.view, scale, rotate, 0, 0);
}
function approximateFraction(x) {
  if (Math.floor(x) === x) {
    return [x, 1];
  }

  var xinv = 1 / x;
  var limit = 8;

  if (xinv > limit) {
    return [1, limit];
  } else if (Math.floor(xinv) === xinv) {
    return [1, xinv];
  }

  var x_ = x > 1 ? xinv : x;
  var a = 0;
  var b = 1;
  var c = 1;
  var d = 1;

  while (true) {
    var p = a + c;
    var q = b + d;

    if (q > limit) {
      break;
    }

    if (x_ <= p / q) {
      c = p;
      d = q;
    } else {
      a = p;
      b = q;
    }
  }

  if (x_ - a / b < c / d - x_) {
    return x_ === x ? [a, b] : [b, a];
  } else {
    return x_ === x ? [c, d] : [d, c];
  }
}
function roundToDivide(x, div) {
  var r = x % div;
  return r === 0 ? x : Math.round(x - r + div);
}
function binarySearchFirstItem(items, condition) {
  var minIndex = 0;
  var maxIndex = items.length - 1;

  if (items.length === 0 || !condition(items[maxIndex])) {
    return items.length;
  }

  if (condition(items[minIndex])) {
    return minIndex;
  }

  while (minIndex < maxIndex) {
    var currentIndex = minIndex + maxIndex >> 1;
    var currentItem = items[currentIndex];

    if (condition(currentItem)) {
      maxIndex = currentIndex;
    } else {
      minIndex = currentIndex + 1;
    }
  }

  return minIndex;
}
function getVisibleElements(scrollEl, views, sortByVisibility) {
  var top = scrollEl.scrollTop;
  var bottom = top + scrollEl.clientHeight;
  var left = scrollEl.scrollLeft;
  var right = left + scrollEl.clientWidth;

  function isElementBottomBelowViewTop(view) {
    var element = view.pageContainer;
    var elementBottom = element.offsetTop + element.clientTop + element.clientHeight;
    return elementBottom > top;
  }

  var visible = [];
  var view;
  var element;
  var currentHeight, viewHeight, hiddenHeight, percentHeight;
  var currentWidth, viewWidth;
  var firstVisibleElementInd = views.length === 0 ? 0 : binarySearchFirstItem(views, isElementBottomBelowViewTop);

  for (var i = firstVisibleElementInd, ii = views.length; i < ii; i++) {
    view = views[i];
    element = view.pageContainer;
    currentHeight = element.offsetTop + element.clientTop;
    viewHeight = element.clientHeight;

    if (currentHeight > bottom) {
      break;
    }

    currentWidth = element.offsetLeft + element.clientLeft;
    viewWidth = element.clientWidth;

    if (currentWidth + viewWidth < left || currentWidth > right) {
      continue;
    }

    hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, currentHeight + viewHeight - bottom);
    percentHeight = (viewHeight - hiddenHeight) * 100 / viewHeight | 0;
    visible.push({
      id: view.id,
      x: currentWidth,
      y: currentHeight,
      view: view,
      percent: percentHeight
    });
  }

  var first = visible[0];
  var last = visible[visible.length - 1];

  if (sortByVisibility) {
    visible.sort(function (a, b) {
      var pc = a.percent - b.percent;

      if (Math.abs(pc) > 0.001) {
        return -pc;
      }

      return a.id - b.id;
    });
  }

  return {
    first: first,
    last: last,
    views: visible
  };
}
function getOutputScale(ctx) {
  var devicePixelRatio = window.devicePixelRatio || 1;
  var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
  var pixelRatio = devicePixelRatio / backingStoreRatio;
  return {
    sx: pixelRatio,
    sy: pixelRatio,
    scaled: pixelRatio !== 1
  };
}
function getCanvasCSSWH(viewport, ctx, _ref) {
  var useOnlyCssZoom = _ref.useOnlyCssZoom,
      maxCanvasPixels = _ref.maxCanvasPixels,
      CSS_UNITS = _ref.CSS_UNITS;
  var hasRestrictedScaling = false;
  var outputScale = getOutputScale(ctx);

  if (useOnlyCssZoom) {
    var actualSizeViewport = viewport.clone({
      scale: CSS_UNITS
    });
    outputScale.sx *= actualSizeViewport.width / viewport.width;
    outputScale.sy *= actualSizeViewport.height / viewport.height;
    outputScale.scaled = true;
  }

  if (maxCanvasPixels > 0) {
    var pixelsInViewport = viewport.width * viewport.height;
    var maxScale = Math.sqrt(maxCanvasPixels / pixelsInViewport);

    if (outputScale.sx > maxScale || outputScale.sy > maxScale) {
      outputScale.sx = maxScale;
      outputScale.sy = maxScale;
      outputScale.scaled = true;
      hasRestrictedScaling = true;
    } else {
      hasRestrictedScaling = false;
    }
  }

  var sfx = approximateFraction(outputScale.sx);
  var sfy = approximateFraction(outputScale.sy);
  var width = roundToDivide(viewport.width * outputScale.sx, sfx[0]);
  var height = roundToDivide(viewport.height * outputScale.sy, sfy[0]);
  var styleWidth = roundToDivide(viewport.width, sfx[1]);
  var styleHeight = roundToDivide(viewport.height, sfy[1]);
  return {
    width: width,
    height: height,
    styleWidth: styleWidth,
    styleHeight: styleHeight,
    outputScale: outputScale,
    hasRestrictedScaling: hasRestrictedScaling
  };
}
function getScale(currentPage, value) {
  var opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var scale = parseFloat(value);

  if (scale > 0) {
    return scale;
  }

  var pdfPageRotate = currentPage.rotate;
  var totalRotation = ((opt.rotation || 0) + pdfPageRotate) % 360;
  var viewport = getViewport(currentPage, CSS_UNITS * DEFAULT_SCALE, totalRotation);
  var isInPresentationMode = opt.isInPresentationMode,
      removePageBorders = opt.removePageBorders,
      container = opt.container;
  var hPadding = isInPresentationMode || removePageBorders ? 0 : SCROLLBAR_PADDING;
  var vPadding = isInPresentationMode || removePageBorders ? 0 : VERTICAL_PADDING; // 4为修复css 中 pageBorder变量导致出现滚动条，--page-border: 9px solid transparent;

  var pageWidthScale = (container.clientWidth - hPadding - 4) / viewport.width * 1;
  var pageHeightScale = (container.clientHeight - vPadding - 4) / viewport.height * 1;

  switch (value) {
    case 'page-actual':
      scale = 1;
      break;

    case 'page-width':
      scale = pageWidthScale;
      break;

    case 'page-height':
      scale = pageHeightScale;
      break;

    case 'page-fit':
      scale = Math.min(pageWidthScale, pageHeightScale);
      break;

    case 'auto':
      var isLandscape = currentPage.width > currentPage.height;
      var horizontalScale = isLandscape ? Math.min(pageHeightScale, pageWidthScale) : pageWidthScale;
      scale = Math.min(MAX_AUTO_SCALE, horizontalScale);
      break;

    default:
      console.error('PDFViewer_setScale: "' + value + '" is an unknown zoom value.');
      return;
  }

  return scale;
}
function watchScroll(viewAreaElement, callback) {
  var debounceScroll = function debounceScroll(evt) {
    if (rAF) {
      return;
    }

    rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {
      rAF = null;
      var currentY = viewAreaElement.scrollTop;
      var lastY = state.lastY;

      if (currentY !== lastY) {
        state.down = currentY > lastY;
      }

      state.lastY = currentY;
      callback(state);
    });
  };

  var state = {
    down: true,
    lastY: viewAreaElement.scrollTop,
    _eventHandler: debounceScroll
  };
  var rAF = null;
  viewAreaElement.addEventListener('scroll', debounceScroll, true);
  return state;
}
function getDownloadInfo(xhr) {
  var realFilename = '';
  var filename = '';
  var fileType = '';
  var contentType = '';

  try {
    contentType = xhr.getResponseHeader('content-type');
    var contentDisposition = xhr.getResponseHeader('content-disposition');

    if (contentDisposition) {
      // 通过正则匹配到附件文件名称
      var dispositionMatch = contentDisposition.match(/filename[^;\n=]*=((['"]).*?\2|[^;\n]*)/g);
      var disposition = dispositionMatch[0].split('=')[1].replace(/^["']/, '').replace(/["']$/, '');
      disposition = decodeURIComponent(disposition);
      realFilename = disposition;
    }
  } catch (error) {}

  filename = realFilename || filename;

  if (contentType.indexOf('image/') !== -1 || /\.(jpg|JPG|jpeg|JPEG|png|PNG|bmp|BMP)$/.test(filename)) {
    fileType = 'image';
  } else if (contentType.indexOf('excel') !== -1 || contentType.indexOf('spreadsheetml.sheet') !== -1 || /\.(xlsx|xls)$/.test(filename)) {
    fileType = 'excel';
  } else if (contentType.indexOf('application/pdf') !== -1 || /\.pdf$/.test(filename)) {
    fileType = 'pdf';
  } else if (contentType.indexOf('application/json') !== -1) {
    fileType = 'json';
  } else {
    fileType = 'office';
  }

  return {
    fileType: fileType,
    filename: filename
  };
}

/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _style_less__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _style_less__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_style_less__WEBPACK_IMPORTED_MODULE_1__);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }




var Spin = /*#__PURE__*/function (_React$Component) {
  _inherits(Spin, _React$Component);

  var _super = _createSuper(Spin);

  function Spin() {
    _classCallCheck(this, Spin);

    return _super.apply(this, arguments);
  }

  _createClass(Spin, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        style: {
          position: 'absolute',
          top: '50%',
          left: '50%',
          marginLeft: -16,
          marginTop: -30
        },
        className: "pwy-spin pwy-spin-lg pwy-spin-spinning"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        className: "pwy-spin-dot pwy-spin-dot-spin"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", {
        className: "pwy-spin-dot-item"
      }, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", {
        className: "pwy-spin-dot-item"
      }, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", {
        className: "pwy-spin-dot-item"
      }, "\xA0"), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("i", {
        className: "pwy-spin-dot-item"
      }, "\xA0")));
    }
  }]);

  return Spin;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

/* harmony default export */ __webpack_exports__["default"] = (Spin);

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _slide_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(33);
/* harmony import */ var _slide_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_slide_css__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(27);
function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






var SliderBar = /*#__PURE__*/function (_React$Component) {
  _inherits(SliderBar, _React$Component);

  var _super = _createSuper(SliderBar);

  function SliderBar(props) {
    var _this;

    _classCallCheck(this, SliderBar);

    _this = _super.apply(this, arguments);

    _defineProperty(_assertThisInitialized(_this), "mySetState", function (data) {
      if (_this._isAmounted) {
        _this.setState(data);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "foreceRender", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var fullViews, visibleEles, visibleThumViews, _loop, i, _ret;

      return _regeneratorRuntime().wrap(function _callee$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _this.rendering = true;
              fullViews = _this.state.thumViews.map(function (item) {
                return _objectSpread(_objectSpread({}, item), {}, {
                  pageContainer: item.pageContainer ? item.pageContainer : document.getElementById('thumbnailContainer' + item.pageNum)
                });
              });
              visibleEles = Object(_tools__WEBPACK_IMPORTED_MODULE_3__["getVisibleElements"])(_this.thumbnailView, fullViews, true);
              visibleThumViews = visibleEles.views;
              _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(i) {
                var pageNum, curView;
                return _regeneratorRuntime().wrap(function _loop$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        pageNum = visibleThumViews[i].view.pageNum;

                        if (!fullViews[pageNum - 1].src) {
                          _context.next = 3;
                          break;
                        }

                        return _context.abrupt("return", "continue");

                      case 3:
                        _context.next = 5;
                        return _this.getThumbViewItem(pageNum);

                      case 5:
                        curView = _context.sent;

                        _this.mySetState({
                          thumViews: _this.state.thumViews.map(function (item) {
                            if (item.pageNum === pageNum) {
                              return _objectSpread(_objectSpread({}, item), curView);
                            } else {
                              return item;
                            }
                          })
                        });

                      case 7:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _loop);
              });
              i = 0;

            case 6:
              if (!(i < visibleThumViews.length)) {
                _context2.next = 14;
                break;
              }

              return _context2.delegateYield(_loop(i), "t0", 8);

            case 8:
              _ret = _context2.t0;

              if (!(_ret === "continue")) {
                _context2.next = 11;
                break;
              }

              return _context2.abrupt("continue", 11);

            case 11:
              i++;
              _context2.next = 6;
              break;

            case 14:
              _this.rendering = false;

            case 15:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee);
    })));

    _defineProperty(_assertThisInitialized(_this), "getThumbSize", function (pageNum) {
      var pdfPage = _this.props.viewers[pageNum - 1].page;
      var pdfPageRotate = pdfPage.rotate;
      var totalRotation = pdfPageRotate % 360;
      var viewport = Object(_tools__WEBPACK_IMPORTED_MODULE_3__["getViewport"])(pdfPage, 1, totalRotation);
      var pageWidth = viewport.width;
      var pageHeight = viewport.height;
      var pageRatio = pageWidth / pageHeight;
      var canvasWidth = _tools__WEBPACK_IMPORTED_MODULE_3__["THUMBNAIL_WIDTH"];
      var canvasHeight = canvasWidth / pageRatio | 0;
      return {
        width: canvasWidth,
        height: canvasHeight,
        viewport: viewport
      };
    });

    _defineProperty(_assertThisInitialized(_this), "getThumbViewItem", function (pageNum) {
      return new Promise(function (resolve) {
        var pageTumbInfo = _this.state.thumViews[pageNum - 1];
        var pdfPage = _this.props.viewers[pageNum - 1].page;
        var viewport = pageTumbInfo.viewport;
        var pageWidth = viewport.width;
        var width = pageTumbInfo.width;
        var height = pageTumbInfo.height;
        var scale = width / pageWidth;
        var canvas = document.createElement('canvas');
        canvas.mozOpaque = true;
        var ctx = canvas.getContext('2d', {
          alpha: false
        });
        var outputScale = Object(_tools__WEBPACK_IMPORTED_MODULE_3__["getOutputScale"])(ctx);
        canvas.width = width * outputScale.sx | 0;
        canvas.height = height * outputScale.sy | 0;
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';

        if (outputScale.scaled) {
          ctx.scale(outputScale.sx, outputScale.sy);
        }

        var drawViewport = viewport.clone({
          scale: scale
        });
        var renderContext = {
          canvasContext: ctx,
          viewport: drawViewport
        };
        var renderTask = pdfPage.render(renderContext);
        renderTask.promise.then(function () {
          pdfPage.cleanup();
          resolve({
            src: canvas.toDataURL(),
            pageNum: pageNum,
            renderState: 1
          });
        }, function (error) {
          console.log('slidebar render err', error);
          pdfPage.cleanup();
          resolve({
            src: '',
            pageNum: pageNum,
            renderState: 2
          });
        });
      });
    });

    _defineProperty(_assertThisInitialized(_this), "goToPage", function (pageNum) {
      _this.props.goToPage(pageNum);
    });

    _defineProperty(_assertThisInitialized(_this), "rotateRight", function () {
      var _this$props = _this.props,
          rotateRight = _this$props.rotateRight,
          activePageNum = _this$props.activePageNum;

      if (rotateRight) {
        rotateRight(activePageNum);
      }
    });

    _defineProperty(_assertThisInitialized(_this), "rotateLeft", function () {
      var _this$props2 = _this.props,
          rotateLeft = _this$props2.rotateLeft,
          activePageNum = _this$props2.activePageNum;

      if (rotateLeft) {
        rotateLeft(activePageNum);
      }
    });

    _this.state = {
      activePageNum: props.activePageNum || 1,
      thumViews: props.viewers.map(function (item) {
        var pageNum = item.pageNum;

        var sizeInfo = _this.getThumbSize(pageNum);

        return _objectSpread({
          renderState: 0,
          id: pageNum,
          pageNum: pageNum
        }, sizeInfo);
      })
    };
    return _this;
  }

  _createClass(SliderBar, [{
    key: "componentDidMount",
    value: function () {
      var _componentDidMount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var _this2 = this;

        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._isAmounted = true;
                this.sidebarContent = document.getElementById('sidebarContent');
                this.thumbnailView = document.getElementById('thumbnailView');
                this.foreceRender();
                Object(_tools__WEBPACK_IMPORTED_MODULE_3__["watchScroll"])(this.thumbnailView, function () {
                  _this2.foreceRender();
                });

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee2, this);
      }));

      function componentDidMount() {
        return _componentDidMount.apply(this, arguments);
      }

      return componentDidMount;
    }()
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this._isAmounted = false;
    }
  }, {
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      return nextProps.activePageNum !== this.props.activePageNum || nextState.thumViews !== this.state.thumViews;
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var newNum = nextProps.activePageNum;

      if (newNum !== this.props.activePageNum) {
        var top = 0;
        var thumViews = this.state.thumViews || [];

        for (var i = 0; i < newNum; i++) {
          top += thumViews[i].height + 14 + 5 + 2;
        }

        var preTop = top - (thumViews[newNum - 1].height + 14 + 5 + 2);

        if (newNum === 1) {
          this.thumbnailView.scrollTop = 0;
        } else if (newNum === thumViews.length) {
          this.thumbnailView.scrollTop = this.thumbnailView.scrollHeight - this.thumbnailView.clientHeight;
        } else {
          if (top > this.thumbnailView.clientHeight + this.thumbnailView.scrollTop) {
            if (preTop + this.thumbnailView.clientHeight > this.thumbnailView.scrollHeight) {
              preTop = this.thumbnailView.scrollHeight - this.thumbnailView.clientHeight;
            }

            this.thumbnailView.scrollTop = preTop;
          } else if (preTop < this.thumbnailView.scrollTop) {
            if (newNum === 1) {
              this.thumbnailView.scrollTop = 0;
            } else {
              this.thumbnailView.scrollTop = preTop;
            }
          }
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var thumViews = this.state.thumViews;
      var activePageNum = this.props.activePageNum;
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: "toolbarSidebar"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: "toolbarSidebar"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        className: "splitToolbarButton toggled"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        id: "viewThumbnail",
        className: "toolbarButton group toggled",
        title: "\u663E\u793A\u7F29\u7565\u56FE",
        tabIndex: "2",
        "data-l10n-id": "thumbs"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "thumbs_label"
      }, "\u7F29\u7565\u56FE")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        id: "viewOutline",
        className: "toolbarButton group",
        title: "\u663E\u793A\u6587\u6863\u5927\u7EB2",
        tabIndex: "3",
        "data-l10n-id": "outline",
        disabled: true
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "outline_label"
      }, "\u6587\u6863\u5927\u7EB2")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        id: "viewAttachments",
        className: "toolbarButton group",
        title: "\u663E\u793A\u9644\u4EF6",
        tabIndex: "4",
        "data-l10n-id": "attachments",
        disabled: true
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "attachments_label"
      }, "\u9644\u4EF6")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        id: "ViewRotateRight",
        className: "toolbarButton group",
        title: "\u987A\u65F6\u9488\u65CB\u8F6C",
        tabIndex: "5",
        "data-l10n-id": "rotateRight",
        onClick: function onClick() {
          return _this3.rotateRight();
        }
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "rotateRight_label"
      }, "\u9644\u4EF6")), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("button", {
        id: "ViewRotateLeft",
        className: "toolbarButton group",
        title: "\u9006\u65F6\u9488\u65CB\u8F6C",
        tabIndex: "6",
        "data-l10n-id": "rotateLeft",
        onClick: function onClick() {
          return _this3.rotateLeft();
        }
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("span", {
        "data-l10n-id": "rotateLeft_label"
      }, "\u9644\u4EF6"))))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: "sidebarContent"
      }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
        id: "thumbnailView",
        className: "thumbnail"
      }, thumViews.map(function (item) {
        var pageNum = item.pageNum,
            _item$src = item.src,
            src = _item$src === void 0 ? '' : _item$src,
            width = item.width,
            height = item.height;
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          key: pageNum,
          onClick: function onClick() {
            return _this3.goToPage(pageNum);
          },
          id: 'thumbnailContainer' + pageNum,
          className: activePageNum === pageNum ? 'thumbnail selected' : 'thumbnail',
          "data-loaded": "true"
        }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          className: "thumbnailSelectionRing",
          style: {
            width: width + 2,
            height: height + 2
          }
        }, src ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("img", {
          id: 'thumbnail' + pageNum,
          className: "thumbnailImage",
          "aria-label": '页面' + pageNum + '的缩略图',
          src: src,
          style: {
            width: width,
            height: height
          }
        }) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement("div", {
          style: {
            width: width,
            height: height
          },
          className: "thumbnailImage iconImage"
        }, "\xA0")));
      }))));
    }
  }]);

  return SliderBar;
}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);

SliderBar.propTypes = {
  activePageNum: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.number,
  viewers: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.array,
  goToPage: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
  rotateRight: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,
  rotateLeft: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func
};
/* harmony default export */ __webpack_exports__["default"] = (SliderBar);

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ })
/******/ ]);
});